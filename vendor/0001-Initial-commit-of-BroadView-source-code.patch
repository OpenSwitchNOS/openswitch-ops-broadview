From d212da8530cd618001a4451a7e0661156b020c96 Mon Sep 17 00:00:00 2001
From: Yelamandeswara Rao <yeeswar@broadcom.com>
Date: Wed, 14 Oct 2015 23:43:58 -0700
Subject: [PATCH] Initial commit of BroadView source code.

Signed-off-by: Yelamandeswara Rao <yeeswar@broadcom.com>
---
 .gitignore                                         |    0
 .gitreview                                         |    4 +
 .test                                              |    1 +
 DESIGN.md                                          |  150 ++
 Feature_design.md                                  |  116 +
 Makefile                                           |    9 +
 README.md                                          |   31 +
 example/bst_app/Makefile                           |   35 +
 example/bst_app/bstapp.h                           |  120 +
 example/bst_app/bstapp_config.c                    |  216 ++
 example/bst_app/bstapp_config.cfg                  |    4 +
 example/bst_app/bstapp_debug.h                     |  102 +
 example/bst_app/bstapp_http.c                      |  173 ++
 example/bst_app/bstapp_json.c                      |  263 +++
 example/bst_app/bstapp_log.c                       |  107 +
 example/bst_app/bstapp_main.c                      |   85 +
 example/bst_app/bstapp_menu.c                      |  552 +++++
 example/bst_app/bstapp_menu_json.c                 |  181 ++
 example/bst_app/bstapp_reports.c                   |  101 +
 feature_user_guide.md                              |   58 +
 output/Makefile                                    |   29 +
 output/feature.h                                   |    6 +
 output/package.cfg                                 |   16 +
 platform/UB-OVSDB/platform.h                       |  125 ++
 platform/common/platform_spec.h                    |   43 +
 platform/tomahawk/platform.h                       |  126 ++
 platform/trident2/platform.h                       |  124 ++
 src/apps/agent/agent.c                             |   61 +
 src/apps/bst/Makefile                              |   40 +
 src/apps/bst/api/bst_json_encoder.c                |  705 ++++++
 src/apps/bst/api/bst_json_encoder.h                |  171 ++
 src/apps/bst/api/bst_json_encoder_egress.c         |  822 +++++++
 src/apps/bst/api/bst_json_encoder_ingress.c        |  501 +++++
 src/apps/bst/api/bst_json_memory.c                 |  421 ++++
 src/apps/bst/api/bst_json_memory.h                 |   50 +
 src/apps/bst/api/clear_bst_statistics.c            |  132 ++
 src/apps/bst/api/clear_bst_statistics.h            |   54 +
 src/apps/bst/api/clear_bst_thresholds.c            |  133 ++
 src/apps/bst/api/clear_bst_thresholds.h            |   54 +
 src/apps/bst/api/configure_bst_feature.c           |  240 ++
 src/apps/bst/api/configure_bst_feature.h           |   74 +
 src/apps/bst/api/configure_bst_thresholds.c        |  346 +++
 src/apps/bst/api/configure_bst_thresholds.h        |   71 +
 src/apps/bst/api/configure_bst_tracking.c          |  257 +++
 src/apps/bst/api/configure_bst_tracking.h          |   66 +
 src/apps/bst/api/get_bst_feature.c                 |  133 ++
 src/apps/bst/api/get_bst_feature.h                 |   54 +
 src/apps/bst/api/get_bst_report.c                  |  247 +++
 src/apps/bst/api/get_bst_report.h                  |   65 +
 src/apps/bst/api/get_bst_thresholds.c              |  246 +++
 src/apps/bst/api/get_bst_thresholds.h              |   65 +
 src/apps/bst/api/get_bst_tracking.c                |  133 ++
 src/apps/bst/api/get_bst_tracking.h                |   54 +
 src/apps/bst/api/get_switch_properties.c           |  134 ++
 src/apps/bst/api/get_switch_properties.h           |   54 +
 src/apps/bst/bst.c                                 |  982 ++++++++
 src/apps/bst/bst_app.h                             | 1019 +++++++++
 src/apps/bst/bst_main.c                            | 1349 +++++++++++
 src/apps/bst/bst_nb_api.c                          |  735 ++++++
 src/apps/bst/bst_trigger.c                         |  519 +++++
 src/infrastructure/logging/Makefile                |   35 +
 src/infrastructure/logging/openapp_log.c           |  383 ++++
 src/infrastructure/module_mgr/Makefile             |   34 +
 src/infrastructure/module_mgr/modulemgr.c          |  364 +++
 src/infrastructure/system/Makefile                 |   35 +
 src/infrastructure/system/system.c                 |  146 ++
 src/infrastructure/system/system_time.c            |  169 ++
 src/nb_plugin/rest/Makefile                        |   35 +
 src/nb_plugin/rest/agent_config.cfg                |    4 +
 src/nb_plugin/rest/rest.h                          |  238 ++
 src/nb_plugin/rest/rest_api.c                      |  387 ++++
 src/nb_plugin/rest/rest_config.c                   |  220 ++
 src/nb_plugin/rest/rest_debug.h                    |   94 +
 src/nb_plugin/rest/rest_http.h                     |   39 +
 src/nb_plugin/rest/rest_http_client.c              |  319 +++
 src/nb_plugin/rest/rest_http_server.c              |  461 ++++
 src/nb_plugin/rest/rest_session.c                  |  110 +
 src/public/asic.h                                  |   89 +
 src/public/broadview.h                             |  127 ++
 src/public/bst.h                                   |  514 +++++
 src/public/json.h                                  |  167 ++
 src/public/modulemgr.h                             |  110 +
 src/public/openapps_feature.h                      |   63 +
 src/public/openapps_log_api.h                      |   98 +
 src/public/packet_trace.h                          |  331 +++
 src/public/rest_api.h                              |   57 +
 src/public/sb_redirector_api.h                     |   75 +
 src/public/sbplugin_api.h                          |   48 +
 src/public/sbplugin_redirect_bst.h                 |  696 ++++++
 src/public/sbplugin_redirect_packet_trace.h        |  204 ++
 src/public/sbplugin_redirect_system.h              |  451 ++++
 src/public/system.h                                |  140 ++
 src/sb_plugin/include/sbfeature.h                  |   48 +
 src/sb_plugin/include/sbfeature_bst.h              |  131 ++
 src/sb_plugin/include/sbfeature_packet_trace.h     |   74 +
 src/sb_plugin/include/sbplugin.h                   |   49 +
 src/sb_plugin/include/sbplugin_system.h            |   79 +
 src/sb_plugin/sb_ovsdb/Makefile                    |   69 +
 src/sb_plugin/sb_ovsdb/bst/include/ovsdb_bst_ctl.h |  103 +
 .../sb_ovsdb/bst/include/sbplugin_bst_cache.h      |  201 ++
 src/sb_plugin/sb_ovsdb/bst/ovsdb_bst_ctl.c         |  750 +++++++
 src/sb_plugin/sb_ovsdb/bst/sbplugin_bst.c          | 2335 ++++++++++++++++++++
 src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_cache.c    |  325 +++
 src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_ovsdb.c    |  528 +++++
 src/sb_plugin/sb_ovsdb/include/sbplugin_bst.h      |  828 +++++++
 src/sb_plugin/sb_ovsdb/include/sbplugin_bst_map.h  |  131 ++
 .../sb_ovsdb/include/sbplugin_bst_ovsdb.h          |  197 ++
 src/sb_plugin/sb_ovsdb/include/sbplugin_ovsdb.h    |   74 +
 .../sb_ovsdb/include/sbplugin_system_map.h         |  252 +++
 src/sb_plugin/sb_ovsdb/ovsdb_config.cfg            |    2 +
 src/sb_plugin/sb_ovsdb/sbplugin_init.c             |   87 +
 src/sb_plugin/sb_ovsdb/system/sbplugin_system.c    |  482 ++++
 src/sb_plugin/sb_redirector/Makefile               |   35 +
 .../sb_redirector/include/sbplugin_redirect.h      |  150 ++
 .../sb_redirector/sbplugin_redirect_bst.c          | 1967 +++++++++++++++++
 .../sb_redirector/sbplugin_redirect_core.c         |  390 ++++
 .../sb_redirector/sbplugin_redirect_packet_trace.c |  462 ++++
 .../sb_redirector/sbplugin_redirect_system.c       | 1275 +++++++++++
 tests/BST_Feature_test.md                          |  362 +++
 tests/BstRestService.py                            |  265 +++
 tests/bstRest.py                                   |   98 +
 tests/bstUtil.py                                   |   46 +
 tests/clear_bst_statistics_api_ct.py               |   89 +
 tests/clear_bst_thresholds_api_ct.py               |   89 +
 tests/configure_bst_feature_api_ct.py              |  134 ++
 tests/configure_bst_thresholds_api_ct.py           |  127 ++
 tests/configure_bst_tracking_api_ct.py             |  136 ++
 tests/get_bst_feature_api_ct.py                    |   96 +
 tests/get_bst_report_api_ct.py                     |  121 +
 tests/get_bst_thresholds_api_ct.py                 |  121 +
 tests/get_bst_tracking_api_ct.py                   |   96 +
 tests/serverDetails.ini                            |    4 +
 tests/testCaseJsonStrings.ini                      |  119 +
 tests/test_bstd_ct_rest_all.py                     |  218 ++
 tools/Make.common                                  |  552 +++++
 tools/Make.common.ovsdb                            |   62 +
 tools/Make.common.platform                         |  115 +
 tools/Make.local                                   |   51 +
 tools/make.configure                               |    0
 tools/relativepath                                 |   29 +
 vendor/cjson/Makefile                              |   31 +
 vendor/cjson/cJSON.c                               |  596 +++++
 vendor/cjson/cJSON.h                               |  143 ++
 143 files changed, 33731 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 .gitreview
 create mode 100644 .test
 create mode 100755 DESIGN.md
 create mode 100755 Feature_design.md
 create mode 100755 Makefile
 create mode 100755 README.md
 create mode 100755 example/bst_app/Makefile
 create mode 100755 example/bst_app/bstapp.h
 create mode 100755 example/bst_app/bstapp_config.c
 create mode 100755 example/bst_app/bstapp_config.cfg
 create mode 100755 example/bst_app/bstapp_debug.h
 create mode 100755 example/bst_app/bstapp_http.c
 create mode 100755 example/bst_app/bstapp_json.c
 create mode 100755 example/bst_app/bstapp_log.c
 create mode 100755 example/bst_app/bstapp_main.c
 create mode 100755 example/bst_app/bstapp_menu.c
 create mode 100755 example/bst_app/bstapp_menu_json.c
 create mode 100755 example/bst_app/bstapp_reports.c
 create mode 100755 feature_user_guide.md
 create mode 100755 output/Makefile
 create mode 100755 output/feature.h
 create mode 100755 output/package.cfg
 create mode 100755 platform/UB-OVSDB/platform.h
 create mode 100755 platform/common/platform_spec.h
 create mode 100755 platform/tomahawk/platform.h
 create mode 100755 platform/trident2/platform.h
 create mode 100755 src/apps/agent/agent.c
 create mode 100755 src/apps/bst/Makefile
 create mode 100755 src/apps/bst/api/bst_json_encoder.c
 create mode 100755 src/apps/bst/api/bst_json_encoder.h
 create mode 100755 src/apps/bst/api/bst_json_encoder_egress.c
 create mode 100755 src/apps/bst/api/bst_json_encoder_ingress.c
 create mode 100755 src/apps/bst/api/bst_json_memory.c
 create mode 100755 src/apps/bst/api/bst_json_memory.h
 create mode 100755 src/apps/bst/api/clear_bst_statistics.c
 create mode 100755 src/apps/bst/api/clear_bst_statistics.h
 create mode 100755 src/apps/bst/api/clear_bst_thresholds.c
 create mode 100755 src/apps/bst/api/clear_bst_thresholds.h
 create mode 100755 src/apps/bst/api/configure_bst_feature.c
 create mode 100755 src/apps/bst/api/configure_bst_feature.h
 create mode 100755 src/apps/bst/api/configure_bst_thresholds.c
 create mode 100755 src/apps/bst/api/configure_bst_thresholds.h
 create mode 100755 src/apps/bst/api/configure_bst_tracking.c
 create mode 100755 src/apps/bst/api/configure_bst_tracking.h
 create mode 100755 src/apps/bst/api/get_bst_feature.c
 create mode 100755 src/apps/bst/api/get_bst_feature.h
 create mode 100755 src/apps/bst/api/get_bst_report.c
 create mode 100755 src/apps/bst/api/get_bst_report.h
 create mode 100755 src/apps/bst/api/get_bst_thresholds.c
 create mode 100755 src/apps/bst/api/get_bst_thresholds.h
 create mode 100755 src/apps/bst/api/get_bst_tracking.c
 create mode 100755 src/apps/bst/api/get_bst_tracking.h
 create mode 100755 src/apps/bst/api/get_switch_properties.c
 create mode 100755 src/apps/bst/api/get_switch_properties.h
 create mode 100755 src/apps/bst/bst.c
 create mode 100755 src/apps/bst/bst_app.h
 create mode 100755 src/apps/bst/bst_main.c
 create mode 100755 src/apps/bst/bst_nb_api.c
 create mode 100755 src/apps/bst/bst_trigger.c
 create mode 100755 src/infrastructure/logging/Makefile
 create mode 100755 src/infrastructure/logging/openapp_log.c
 create mode 100755 src/infrastructure/module_mgr/Makefile
 create mode 100755 src/infrastructure/module_mgr/modulemgr.c
 create mode 100755 src/infrastructure/system/Makefile
 create mode 100755 src/infrastructure/system/system.c
 create mode 100755 src/infrastructure/system/system_time.c
 create mode 100755 src/nb_plugin/rest/Makefile
 create mode 100755 src/nb_plugin/rest/agent_config.cfg
 create mode 100755 src/nb_plugin/rest/rest.h
 create mode 100755 src/nb_plugin/rest/rest_api.c
 create mode 100755 src/nb_plugin/rest/rest_config.c
 create mode 100755 src/nb_plugin/rest/rest_debug.h
 create mode 100755 src/nb_plugin/rest/rest_http.h
 create mode 100755 src/nb_plugin/rest/rest_http_client.c
 create mode 100755 src/nb_plugin/rest/rest_http_server.c
 create mode 100755 src/nb_plugin/rest/rest_session.c
 create mode 100755 src/public/asic.h
 create mode 100755 src/public/broadview.h
 create mode 100755 src/public/bst.h
 create mode 100755 src/public/json.h
 create mode 100755 src/public/modulemgr.h
 create mode 100755 src/public/openapps_feature.h
 create mode 100755 src/public/openapps_log_api.h
 create mode 100755 src/public/packet_trace.h
 create mode 100755 src/public/rest_api.h
 create mode 100755 src/public/sb_redirector_api.h
 create mode 100755 src/public/sbplugin_api.h
 create mode 100755 src/public/sbplugin_redirect_bst.h
 create mode 100755 src/public/sbplugin_redirect_packet_trace.h
 create mode 100755 src/public/sbplugin_redirect_system.h
 create mode 100755 src/public/system.h
 create mode 100755 src/sb_plugin/include/sbfeature.h
 create mode 100755 src/sb_plugin/include/sbfeature_bst.h
 create mode 100755 src/sb_plugin/include/sbfeature_packet_trace.h
 create mode 100755 src/sb_plugin/include/sbplugin.h
 create mode 100755 src/sb_plugin/include/sbplugin_system.h
 create mode 100755 src/sb_plugin/sb_ovsdb/Makefile
 create mode 100755 src/sb_plugin/sb_ovsdb/bst/include/ovsdb_bst_ctl.h
 create mode 100755 src/sb_plugin/sb_ovsdb/bst/include/sbplugin_bst_cache.h
 create mode 100755 src/sb_plugin/sb_ovsdb/bst/ovsdb_bst_ctl.c
 create mode 100755 src/sb_plugin/sb_ovsdb/bst/sbplugin_bst.c
 create mode 100755 src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_cache.c
 create mode 100755 src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_ovsdb.c
 create mode 100755 src/sb_plugin/sb_ovsdb/include/sbplugin_bst.h
 create mode 100755 src/sb_plugin/sb_ovsdb/include/sbplugin_bst_map.h
 create mode 100755 src/sb_plugin/sb_ovsdb/include/sbplugin_bst_ovsdb.h
 create mode 100755 src/sb_plugin/sb_ovsdb/include/sbplugin_ovsdb.h
 create mode 100755 src/sb_plugin/sb_ovsdb/include/sbplugin_system_map.h
 create mode 100755 src/sb_plugin/sb_ovsdb/ovsdb_config.cfg
 create mode 100755 src/sb_plugin/sb_ovsdb/sbplugin_init.c
 create mode 100755 src/sb_plugin/sb_ovsdb/system/sbplugin_system.c
 create mode 100755 src/sb_plugin/sb_redirector/Makefile
 create mode 100755 src/sb_plugin/sb_redirector/include/sbplugin_redirect.h
 create mode 100755 src/sb_plugin/sb_redirector/sbplugin_redirect_bst.c
 create mode 100755 src/sb_plugin/sb_redirector/sbplugin_redirect_core.c
 create mode 100755 src/sb_plugin/sb_redirector/sbplugin_redirect_packet_trace.c
 create mode 100755 src/sb_plugin/sb_redirector/sbplugin_redirect_system.c
 create mode 100755 tests/BST_Feature_test.md
 create mode 100644 tests/BstRestService.py
 create mode 100644 tests/bstRest.py
 create mode 100644 tests/bstUtil.py
 create mode 100644 tests/clear_bst_statistics_api_ct.py
 create mode 100644 tests/clear_bst_thresholds_api_ct.py
 create mode 100644 tests/configure_bst_feature_api_ct.py
 create mode 100644 tests/configure_bst_thresholds_api_ct.py
 create mode 100644 tests/configure_bst_tracking_api_ct.py
 create mode 100644 tests/get_bst_feature_api_ct.py
 create mode 100644 tests/get_bst_report_api_ct.py
 create mode 100644 tests/get_bst_thresholds_api_ct.py
 create mode 100644 tests/get_bst_tracking_api_ct.py
 create mode 100644 tests/serverDetails.ini
 create mode 100644 tests/testCaseJsonStrings.ini
 create mode 100644 tests/test_bstd_ct_rest_all.py
 create mode 100755 tools/Make.common
 create mode 100755 tools/Make.common.ovsdb
 create mode 100755 tools/Make.common.platform
 create mode 100755 tools/Make.local
 create mode 100755 tools/make.configure
 create mode 100755 tools/relativepath
 create mode 100755 vendor/cjson/Makefile
 create mode 100755 vendor/cjson/cJSON.c
 create mode 100755 vendor/cjson/cJSON.h

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..e69de29
diff --git a/.gitreview b/.gitreview
new file mode 100644
index 0000000..9f0d323
--- /dev/null
+++ b/.gitreview
@@ -0,0 +1,4 @@
+[gerrit]
+host=review.openswitch.net
+port=29418
+project=openswitch/ops-broadview.git
diff --git a/.test b/.test
new file mode 100644
index 0000000..3ad1d44
--- /dev/null
+++ b/.test
@@ -0,0 +1 @@
+init replicate
diff --git a/DESIGN.md b/DESIGN.md
new file mode 100755
index 0000000..7641c87
--- /dev/null
+++ b/DESIGN.md
@@ -0,0 +1,150 @@
+High level design of BroadView Daemon
+============================
+
+Networks have become business critical and Network Operators are demanding greater instrumentation and telemetry capabilities so that they can get better visibility into their networks. Increased visibility would allow them to identify problems leading to poor network performance proactively. It also helps network operator to better plan and fine tune their networks to meet strict SLAs and improve and maintain Application performance. Broadcom has introduced [BroadView Instrumentation](https://github.com/Broadcom-Switch/BroadView-Instrumentation), an industry first, software suite that provides unprecedented visibility into switch silicon. BroadView Instrumentation will expose the various instrumentation capabilities in Broadcom silicon and ease adoption of it by working with the ecosystem partners.
+
+The suite consists of an Agent that runs on the switch and Applications that interface with the Agent over Open REST API. Applications visualize, analyze data exported by the Agent and provide ability to operator to fine tune the network. The Agent is Open and portable across different Network Operating Systems. BroadView Daemon is the implementation of the Agent functionality on OpenSwitch.
+
+The BroadView Daemon is based on the modular BroadView Agent developed and open sourced by Broadcom. The BroadView Agent has been ported to OpenSwitch OS and adapted to support the Interface/API mechanism provided by OpenSwitch. The Daemon consists of a NB plugin which is responsible for marshalling and unmarshalling of REST messages and interfacing with the Core Agent module. The NB plugin interfaces with the REST service of OpenSwitch. The SB plugin for this implementation has been modified to interface with the OVSDB Server.
+
+In this release the BroadView Daemon collects the BST Instrumentation Statistics from the Broadcom Silicon and exports those via the BroadView Instrumentation REST (JSON) API. Instrumentation Collectors and Apps interface with the BroadView Daemon to obtain these statistics and use them for visualization, analytics, etc. An example of Visualization App is Ganglia. 
+
+Reponsibilities
+---------------
+BroadView Daemon's main responsiblity it to collect the BST Instrumentation Statistics from the Broadcom Silicon and exports those via the BroadView Instrumentation REST (JSON) API. It is also responsible to configure the silicon for configuration related to the Instrumentation feature.
+
+Design choices
+--------------
+Discuss any design choices that were made.
+
+Relationships to external OpenSwitch entities
+---------------------------------------------
+
+                          +----+                           
++--------------------+    | O  |                           
+|                    |    | V  |                           
+| BroadView Daemon   <--->+ S  |                           
+|                    |    | D  |                           
++--------------------+    | B  |                           
+                          | |  |                           
+                          | S  |                           
+                          | e  |     +--------------------+
+                          | r  |     |                    |
+                          | v  <---->+                    |
+                          | e  |     |     Driver         |
+                          | r  |     +--------------------+
+                          |    |                           
+                          |    |                           
+                          |    |                           
+                          +----+                           
+
+The BroadView Daemon interfaces with the OVSDB-Server so it is loosely coupled with the Driver. The Driver is the one responsible for obtaining the statistics from the Switch Silicon and populating the BST statistics counters defined via the OVSDB schema.The Driver is the Publisher of the data and the BroadView Daemon is the Subscriber (consumer) to the data. This allows the design to be very modular and keeping the interfaces simple and well-defined.
+
+OVSDB-Schema
+------------
+"bufmon": {
+            "columns": {
+                "counter_value": {
+                    "ephemeral": true,
+                    "type": {
+                        "key": {
+                            "minInteger": 0,
+                            "type": "integer"
+                        },
+                        "max": 1,
+                        "min": 0
+                    }
+                },
+                "counter_vendor_specific_info": {
+                    "type": {
+                        "key": "string",
+                        "max": "unlimited",
+                        "min": 0,
+                        "value": "string"
+                    }
+                },
+                "enabled": {
+                    "type": "boolean"
+                },
+                "hw_unit_id": {
+                    "type": "integer"
+                },
+                "name": {
+                    "type": "string"
+                },
+                "status": {
+                    "type": {
+                        "key": {
+                            "enum": [
+                                "set",
+                                [
+                                    "ok",
+                                    "not-properly-configured",
+                                    "triggered"
+                                ]
+                            ],
+                            "type": "string"
+                        },
+                        "max": 1,
+                        "min": 0
+                    }
+                },
+                "trigger_threshold": {
+                    "type": {
+                        "key": {
+                            "minInteger": 0,
+                            "type": "integer"
+                        },
+                        "max": 1,
+                        "min": 0
+                    }
+                }
+            },
+            "indexes": [
+                [
+                    "hw_unit_id",
+                    "name"
+                ]
+            ],
+            "isRoot": true
+        }
+
+BroadView Daemon gets the configuration from the OVSDB schema, it exports statistics via its REST API using JSON messaging to a Collector or Controller. 
+
+Internal structure
+------------------
+The picture below is a very high level simple description.
+
+           ^  REST (JSON)
+           |             
++----------+---------+   
+|                    |   
+|   NorthBound (NB)  <   
+|       Plugin       |   
++--------------------+   
+                         
++--------------------+   
+|                    |   
+|   Core Agent       |   
+|                    |   
++--------------------+   
+                         
+ +-------------------+   
+ |                   |   
+ |  SouthBound (SB)  |   
+ |      Plugin       |   
+ +-------------------+   
+
+The Daemon consists of a NB plugin which is responsible for marshalling and unmarshalling of REST messages and interfacing with the Core Agent module. The NB plugin interfaces with the REST service of OpenSwitch. The SB plugin for this implementation has been modified to interface with the OVSDB Server. 
+
+Detailed Design Description can be found at the [BroadView Instrumentation Design Documentation](http://broadcom-switch.github.io/BroadView-Instrumentation/doc/html/dc/d12/DESIGN.html) as also [functional details](http://broadcom-switch.github.io/BroadView-Instrumentation/doc/html/modules.html) on BroadView Instrumentation GitHub.
+Any other sections that are relevant for the module
+---------------------------------------------------
+
+References
+----------
+* [Reference 1](http://www.openswitch.net/docs/redest1)
+* ...
+
+Include references to any other modules that interact with this module directly or through the database model. For example, CLI, REST, etc.
+ops-fand might provide reference to ops-sensord, etc.
diff --git a/Feature_design.md b/Feature_design.md
new file mode 100755
index 0000000..60502ad
--- /dev/null
+++ b/Feature_design.md
@@ -0,0 +1,116 @@
+High level design of FEATURE
+============================
+
+High level description of a FEATURE design. 
+
+Please also refer to DESIGN.md document of the repo that contains BroadView daemon. 
+
+Design choices
+--------------
+The BroadView Daemon was chosen, as it would export the BST Instrumentation Statistics in the Open BroadView Instrumentation defined REST API (JSON). This allows OpenSwitch to have the BroadView Instrumentation REST API support and allows Collectors and Instrumentation Apps to support OpenSwitch based switches. The same statistics are also available from the OVSDB Schema and would serve Collectors and Management systems that support OVSDB.
+
+Participating modules
+---------------------
+
+                          +----+                           
++--------------------+    | O  |                           
+|                    |    | V  |                           
+| BroadView Daemon   <--->+ S  |                           
+|                    |    | D  |                           
++--------------------+    | B  |                           
+                          | |  |                           
+                          | S  |                           
+                          | e  |     +--------------------+
+                          | r  |     |                    |
+                          | v  <---->+                    |
+                          | e  |     |     Driver         |
+                          | r  |     +--------------------+
+                          |    |                           
+                          |    |                           
+                          |    |                           
+                          +----+                           
+
+The BroadView Daemon interfaces with the OVSDB-Server, so it is loosely coupled with the Driver. The Driver is responsible for obtaining the statistics from the Switch Silicon and populating the BST statistics counters defined via the OVSDB schema. The Driver is the Publisher of the data and the BroadView Daemon is the Subscriber (consumer) of the data. This allows the design to be modular, with simple, well-defined interfaces.
+
+OVSDB-Schema
+------------
+"bufmon": {
+            "columns": {
+                "counter_value": {
+                    "ephemeral": true,
+                    "type": {
+                        "key": {
+                            "minInteger": 0,
+                            "type": "integer"
+                        },
+                        "max": 1,
+                        "min": 0
+                    }
+                },
+                "counter_vendor_specific_info": {
+                    "type": {
+                        "key": "string",
+                        "max": "unlimited",
+                        "min": 0,
+                        "value": "string"
+                    }
+                },
+                "enabled": {
+                    "type": "boolean"
+                },
+                "hw_unit_id": {
+                    "type": "integer"
+                },
+                "name": {
+                    "type": "string"
+                },
+                "status": {
+                    "type": {
+                        "key": {
+                            "enum": [
+                                "set",
+                                [
+                                    "ok",
+                                    "not-properly-configured",
+                                    "triggered"
+                                ]
+                            ],
+                            "type": "string"
+                        },
+                        "max": 1,
+                        "min": 0
+                    }
+                },
+                "trigger_threshold": {
+                    "type": {
+                        "key": {
+                            "minInteger": 0,
+                            "type": "integer"
+                        },
+                        "max": 1,
+                        "min": 0
+                    }
+                }
+            },
+            "indexes": [
+                [
+                    "hw_unit_id",
+                    "name"
+                ]
+            ],
+            "isRoot": true
+        }
+
+The BroadView Daemon gets the configuration from the OVSDB schema. It exports statistics via its REST API using JSON messaging to a Collector or Controller. 
+
+
+Any other sections that are relevant for the module
+---------------------------------------------------
+
+References
+----------
+* [Reference 1](http://www.openswitch.net/docs/redest1)
+* ...
+
+Include references to DESIGN.md of any module that participates in the feature.
+Include reference to user guide of the feature.
diff --git a/Makefile b/Makefile
new file mode 100755
index 0000000..5299289
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,9 @@
+
+export OPENAPPS_OUTPATH := $(PWD)/output
+export OPENAPPS_BASE := $(PWD)
+
+-include $(OPENAPPS_OUTPATH)/package.cfg
+
+-include $(OPENAPPS_OUTPATH)/Makefile
+
+include tools/make.configure
diff --git a/README.md b/README.md
new file mode 100755
index 0000000..b2914ab
--- /dev/null
+++ b/README.md
@@ -0,0 +1,31 @@
+BroadView Daemon
+=======
+
+What is BroadView Daemon?
+----------------
+
+Networks have become business critical and Network Operators are demanding greater instrumentation and telemetry capabilities so that they can get better visibility into their networks. Increased visibility enables them to proactively identify problems that may lead to poor network performance. It also helps network operators to better plan and fine tune their networks to meet strict SLAs and improve and maintain Application performance. Broadcom has introduced the [BroadView Instrumentation](https://github.com/Broadcom-Switch/BroadView-Instrumentation) software suite -- an industry first -- that provides unprecedented visibility into switch silicon. BroadView Instrumentation exposes the various instrumentation capabilities in Broadcom silicon and eases adoption of it by working with the ecosystem partners.
+
+The suite consists of an Agent that runs on the switch and Applications that interface with the Agent over the Open REST API. Applications visualize, analyze data exported by the Agent, and provide the operator the ability to fine tune the network. The Agent is Open and portable across different Network Operating Systems. The BroadView Daemon is the implementation of the Agent functionality on OpenSwitch.
+
+The BroadView Daemon is responsible for providing Instrumentation and visibility into the silicon in [OpenSwitch](http://www.openswitch.net) project. In this release, the BroadView Daemon supports Buffer Statistics Tracking (BST) which provides unprecedented visibility into MMU buffer utilization, enabling an operator to detect microbursts and fine tune the configuration to meet SLA for certain traffic, such as lossless traffic (e.g., storage).
+
+The BroadView Daemon is heavily based on project [BroadView Instrumentation](https://github.com/Broadcom-Switch/BroadView-Instrumentation) and will be frequently upstreaming its changes to the parent project.
+
+What is the structure of the repository?
+----------------------------------------
+
+* tests/ contains all the component tests of BroadView Daemon based on [ops-test-framework](http://git.openswitch.net/openswitch/ops-test-framework)
+* configs/ contains all the example YAML files required by BroadView Daemon
+* bar/ contains the modified parent project sources
+
+What is the license?
+--------------------
+Being heavily based on project bar, ops-foo inherits its Apache 2.0 license. For more details refer to [COPYING](COPYING)
+
+What other documents are available?
+-----------------------------------
+For the high level design of ops-foo, refer to [DESIGN.md](DESIGN.md)
+For the current list of contributors and maintainers, refer to [AUTHORS.md](AUTHORS.md)
+
+For general information about OpenSwitch project refer to http://www.openswitch.net
diff --git a/example/bst_app/Makefile b/example/bst_app/Makefile
new file mode 100755
index 0000000..5432d3a
--- /dev/null
+++ b/example/bst_app/Makefile
@@ -0,0 +1,35 @@
+MODULE := bviewbstapp
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+CFLAGS += -Wall -g -I. -I../../src/public/ -I$(OPENAPPS_OUTPATH) -I../../vendor/cjson
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+export OUT_BSTAPP=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_BSTAPP=$(MODULE).a
+
+OBJECTS_BSTAPP := $(patsubst %.c,%.o,$(wildcard *.c))
+
+$(OUT_BSTAPP)/%.o : %.c
+	@mkdir -p $(OUT_BSTAPP) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_BSTAPP)/$(LIBS_BSTAPP): $(patsubst %,$(OUT_BSTAPP)/%,$(subst :, ,$(OBJECTS_BSTAPP))) 
+	@cd $(OUT_BSTAPP) && $(AR) rvs $(MODULE).a $(OBJECTS_BSTAPP)  
+#	@cd $(OUT_BSTAPP) && $(CC) $(CFLAGS) -L../ -L. -o $(MODULE) $(OBJECTS_BSTAPP) -lm -lcjson -lpthread
+
+#default target
+$(MODULE) all: $(OUT_BSTAPP)/$(LIBS_BSTAPP) 
+	$(NOOP)
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_BSTAPP)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_BSTAPP=$(OUT_BSTAPP)"
+	@echo "LIBS_BSTAPP=$(LIBS_BSTAPP)"
diff --git a/example/bst_app/bstapp.h b/example/bst_app/bstapp.h
new file mode 100755
index 0000000..68a79c9
--- /dev/null
+++ b/example/bst_app/bstapp.h
@@ -0,0 +1,120 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+
+#ifndef INCLUDE_BST_APP_H
+#define	INCLUDE_BST_APP_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <arpa/inet.h>
+
+#define BSTAPP_MAX_STRING_LENGTH      128
+#define BSTAPP_MAX_HTTP_BUFFER_LENGTH 2048
+#define BSTAPP_MAX_ASIC_LENGTH 16
+
+#define BSTAPP_MAX_REPORT_LENGTH    (8192*10)
+
+#define BSTAPP_MAX_IP_ADDR_LENGTH    20
+
+/* file from where the configuration properties are read. */
+#define BSTAPP_CONFIG_FILE    "bstapp_config.cfg"
+
+#define BSTAPP_CONFIG_PROPERTY_AGENT_IP   "agent_ip"
+#define BSTAPP_CONFIG_PROPERTY_AGENT_IP_DEFAULT   "127.0.0.1"    
+
+#define BSTAPP_CONFIG_PROPERTY_AGENT_PORT   "agent_port"
+#define BSTAPP_CONFIG_PROPERTY_AGENT_PORT_DEFAULT   8080
+
+#define BSTAPP_CONFIG_PROPERTY_LOCAL_PORT "bstapp_port"
+#define BSTAPP_CONFIG_PROPERTY_LOCAL_PORT_DEFAULT 9070
+
+#define BSTAPP_CONFIG_PROPERTY_MAX_REPORTS "bstapp_max_reports"
+#define BSTAPP_CONFIG_PROPERTY_MAX_REPORTS_DEFAULT 10
+
+#define BSTAPP_MAX_INPUT 10
+#define BSTAPP_DEFAULT_ASIC_ID "1"
+#define BSTAPP_DEFAULT_COLLECTION_INTERVAL "60"
+#define BSTAPP_DEFAULT_THRESHOLD "1000"
+#define BSTAPP_DISABLE 0
+#define BSTAPP_ENABLE 1
+#define BSTAPP_DEFAULT_ENABLE "1"
+#define BSTAPP_DEFAULT_DISABLE "0"
+
+#define BSTAPP_COMMUNICATION_LOG_FILE   "/tmp/bstapp_communication.log"   
+
+#define BSTAPP_HTTP_TWIN_CRLF     "\r\n\r\n"
+
+typedef struct _bstapp_config_
+{
+    char agentIp[BSTAPP_MAX_IP_ADDR_LENGTH];
+
+    int agentPort;
+
+    int localPort;
+
+    int maxReports;
+} BSTAPP_CONFIG_t;
+
+typedef struct _bstapp_rest_msg_ {
+    char *httpMethod;
+    char *method;
+    char *json;
+    char *descr;
+}BSTAPP_REST_MSG_t;
+
+typedef struct _bstapp_rest_menu_msg_ {
+    char *httpMethod;
+    char *method;
+    char *json;
+    char *descr;
+}BSTAPP_REST_MENU_MSG_t;
+
+typedef enum _bstapp_usrinput_status_ {
+  USER_INPUT_OK = 0,
+  USER_INPUT_NONE,
+  USER_INPUT_ERROR
+} BSTAPP_USRINPUT_STATUS_t;
+
+/* initialize configurations */
+int bstapp_config_init(BSTAPP_CONFIG_t *config);
+
+/* for communication logging */
+int bstapp_logging_init(void);
+
+int bstapp_message_log(char *message, int length, bool isFromAgent);
+
+int bstapp_communicate_with_agent(void *config);
+
+int bstapp_debug_menu(void *config);
+
+int bstapp_http_server_run(BSTAPP_CONFIG_t *config);
+
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_BST_APP_H */
+
diff --git a/example/bst_app/bstapp_config.c b/example/bst_app/bstapp_config.c
new file mode 100755
index 0000000..b541620
--- /dev/null
+++ b/example/bst_app/bstapp_config.c
@@ -0,0 +1,216 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <arpa/inet.h>
+
+#include "bstapp.h"
+#include "bstapp_debug.h"
+
+#define _BSTAPP_CONFIGFILE_LINE_MAX_LEN   256
+#define _BSTAPP_CONFIGFILE_READ_MODE      "r"
+#define _BSTAPP_CONFIGFILE_DELIMITER      "="
+
+/******************************************************************
+ * @brief  Sets the configuration, to defaults.
+ *
+ * @param[in]   config      config to be setup
+ *                           
+ * @retval   0  when configuration is initialized successfully
+ *
+ * @note     
+ *********************************************************************/
+
+static int bstapp_config_set_defaults(BSTAPP_CONFIG_t *config)
+{
+    _BSTAPP_LOG(_BSTAPP_DEBUG_INFO, "BSTAPP : Setting configuration to defaults \n");
+
+    memset(config, 0, sizeof (BSTAPP_CONFIG_t));
+
+    /* setup default client IP */
+    strncpy(&config->agentIp[0], BSTAPP_CONFIG_PROPERTY_AGENT_IP_DEFAULT, BSTAPP_MAX_IP_ADDR_LENGTH);
+
+    /* setup default client port */
+    config->agentPort = BSTAPP_CONFIG_PROPERTY_AGENT_PORT_DEFAULT;
+
+    /* setup default local port */
+    config->localPort = BSTAPP_CONFIG_PROPERTY_LOCAL_PORT_DEFAULT;
+
+    /* maximum reports */
+    config->maxReports = BSTAPP_CONFIG_PROPERTY_MAX_REPORTS_DEFAULT;
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_INFO, "BSTAPP : Using default configuration %s:%d <-->local:%d, Max %d Reports \n",
+                config->agentIp, config->agentPort, config->localPort, config->maxReports);
+
+    return 0;
+}
+
+/******************************************************************
+ * @brief  Reads configuration from a file.
+ *
+ * @param[in]   config      config to be setup
+ *                           
+ * @retval   0  when configuration is initialized successfully
+ * @retval  -1  on any error
+ *
+ * @note     
+ *********************************************************************/
+
+static int bstapp_config_read(BSTAPP_CONFIG_t *config)
+{
+    FILE *configFile;
+    char line[_BSTAPP_CONFIGFILE_LINE_MAX_LEN] = { 0 };
+    int numLinesRead = 0;
+
+    /* dummy structure for validating IP address */
+    struct sockaddr_in clientIpAddr;
+    int temp;
+
+    /* for string manipulation */
+    char *property, *value;
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_INFO, "BSTAPP : Reading configuration from %s \n", BSTAPP_CONFIG_FILE);
+
+    memset(config, 0, sizeof (BSTAPP_CONFIG_t));
+
+    /* open the file. if file not available/readable, return appropriate error */
+    configFile = fopen(BSTAPP_CONFIG_FILE, _BSTAPP_CONFIGFILE_READ_MODE);
+
+    if (configFile == NULL)
+    {
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR,
+                    "BSTAPP : Configuration file %s not found:\n",
+                    BSTAPP_CONFIG_FILE);
+        return -1;
+    }
+
+    /* read the lines one-by-one. if any of the lines is corrupted 
+     * i.e., doesn't contain valid tokens, return error 
+     */
+
+    while (numLinesRead < 4)
+    {
+        memset (&line[0], 0, _BSTAPP_CONFIGFILE_LINE_MAX_LEN);
+
+        /* read one line from the file */
+        property = fgets(&line[0], _BSTAPP_CONFIGFILE_LINE_MAX_LEN, configFile);
+        _BSTAPP_ASSERT_CONFIG_FILE_ERROR(property != NULL);
+
+        numLinesRead++;
+
+        /* split the line into tokens, based on the file format */
+        property = strtok(&line[0], _BSTAPP_CONFIGFILE_DELIMITER);
+        _BSTAPP_ASSERT_CONFIG_FILE_ERROR(property != NULL);
+        value = property + strlen(property) + 1;
+
+        /* Is this token the agent IP address ?*/
+        if (strcmp(property, BSTAPP_CONFIG_PROPERTY_AGENT_IP) == 0)
+        {
+            /* truncate the newline characters */
+            value[strlen(value) - 1] = 0;
+
+            /* is this IP address valid ? */
+            temp = inet_pton(AF_INET, value, &(clientIpAddr.sin_addr));
+            _BSTAPP_ASSERT_CONFIG_FILE_ERROR(temp > 0);
+
+            /* copy the agent ip address */
+            strncpy(&config->agentIp[0], value, BSTAPP_MAX_IP_ADDR_LENGTH - 1);
+            continue;
+        }
+
+        /* Is this token the agent port number ?*/
+        if (strcmp(property, BSTAPP_CONFIG_PROPERTY_AGENT_PORT) == 0)
+        {
+            /* is this port number valid ? */
+            temp = strtol(value, NULL, 10);
+            _BSTAPP_ASSERT_CONFIG_FILE_ERROR( errno != ERANGE);
+
+            /* copy the agent port number */
+            config->agentPort = temp;
+            continue;
+        }
+
+        /* Is this token the local port number ?*/
+        if (strcmp(property, BSTAPP_CONFIG_PROPERTY_LOCAL_PORT) == 0)
+        {
+            /* is this port number valid ? */
+            temp = strtol(value, NULL, 10);
+            _BSTAPP_ASSERT_CONFIG_FILE_ERROR( errno != ERANGE);
+
+            /* copy the client port number */
+            config->localPort = temp;
+            continue;
+        }
+        
+        /* Is this token the Max Reports  ?*/
+        if (strcmp(property, BSTAPP_CONFIG_PROPERTY_MAX_REPORTS) == 0)
+        {
+            /* is this port number valid ? */
+            temp = strtol(value, NULL, 10);
+            _BSTAPP_ASSERT_CONFIG_FILE_ERROR( errno != ERANGE);
+
+            /* copy the client port number */
+            config->maxReports = temp;
+            continue;
+        }
+
+        /* unknown property */
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR,
+                    "BSTAPP : Unknown property in configuration file : %s \n",
+                    property);
+        fclose(configFile);
+        return -1;
+    }
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_INFO, "BSTAPP : Using default configuration %s:%d <-->local:%d, Max %d Reports \n",
+                config->agentIp, config->agentPort, config->localPort, config->maxReports);
+
+    fclose(configFile);
+    return 0;
+}
+
+/******************************************************************
+ * @brief  Initializes configuration, reads it from file or assumes defaults.
+ *
+ * @param[in]   config      config to be setup
+ *                           
+ * @retval   0  when configuration is initialized successfully
+ *
+ * @note     
+ *********************************************************************/
+int bstapp_config_init(BSTAPP_CONFIG_t *config)
+{
+    int status;
+
+    /* aim to read */
+    _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "BSTAPP : Configuring ...");
+
+    status = bstapp_config_read(config);
+    if (status != 0)
+    {
+        bstapp_config_set_defaults(config);
+    }
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "BSTAPP : Configuration Complete");
+
+    return 0;
+}
+
+
diff --git a/example/bst_app/bstapp_config.cfg b/example/bst_app/bstapp_config.cfg
new file mode 100755
index 0000000..fa7435b
--- /dev/null
+++ b/example/bst_app/bstapp_config.cfg
@@ -0,0 +1,4 @@
+agent_ip=127.0.0.1
+bstapp_port=9070
+agent_port=8080
+bstapp_max_reports=10
diff --git a/example/bst_app/bstapp_debug.h b/example/bst_app/bstapp_debug.h
new file mode 100755
index 0000000..2f8bf3f
--- /dev/null
+++ b/example/bst_app/bstapp_debug.h
@@ -0,0 +1,102 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+
+#ifndef INCLUDE_BST_APP_DEBUG_H
+#define	INCLUDE_BST_APP_DEBUG_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#define _BSTAPP_DEBUG
+#define _BSTAPP_DEBUG_LEVEL        _BSTAPP_DEBUG_ALL
+
+#define _BSTAPP_DEBUG_TRACE        (0x1)
+#define _BSTAPP_DEBUG_INFO         (0x01 << 1)
+#define _BSTAPP_DEBUG_ERROR        (0x01 << 2)
+#define _BSTAPP_DEBUG_DUMPJSON     (0x01 << 3)
+#define _BSTAPP_DEBUG_ALL          (0xFF)
+
+#ifdef _BSTAPP_DEBUG
+#define _BSTAPP_LOG(level, format,args...)   do { \
+            if ((level) & _BSTAPP_DEBUG_LEVEL) { \
+                printf(format, ##args); \
+            } \
+        }while(0)
+#else 
+#define _BSTAPP_LOG(level, format,args...)
+#endif
+
+/* Utility Macros for parameter validation */
+#define _BSTAPP_ASSERT_ERROR(condition, errcode) do { \
+    if (!(condition)) { \
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, \
+                    "BSTAPP (%s:%d) Invalid Input Parameter  \n", \
+                    __func__, __LINE__); \
+        return (errcode); \
+    } \
+} while(0)
+
+#define _BSTAPP_ASSERT(condition) _BSTAPP_ASSERT_ERROR((condition), (-1))
+
+/* Utility Logging Macros */
+
+#define _BSTAPP_ASSERT_NET_ERROR(condition, errString) do { \
+    if (!(condition)) { \
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, \
+                    "BSTAPP (%s:%d) %s. [ERRNO : %s ] \n", \
+                    __func__, __LINE__, (errString), strerror(errno)); \
+        return (-1); \
+    } \
+} while(0)
+
+#define _BSTAPP_PASSIVE_ASSERT_NET_ERROR(condition, errString) do { \
+    if (!(condition)) { \
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, \
+                    "BSTAPP (%s:%d) %s. [ERRNO : %s ] \n", \
+                    __func__, __LINE__, (errString), strerror(errno)); \
+    } \
+} while(0)
+
+#define _BSTAPP_ASSERT_NET_SOCKET_ERROR(condition, errString,listenFd) do { \
+    if (!(condition)) { \
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, \
+                    "BSTAPP (%s:%d) %s. [ERRNO : %s ] \n", \
+                    __func__, __LINE__, (errString), strerror(errno)); \
+        close(listenFd); \
+        return (-1); \
+    } \
+} while(0)
+
+#define _BSTAPP_ASSERT_CONFIG_FILE_ERROR(condition) do { \
+    if (!(condition)) { \
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, \
+                    "BSTAPP (%s:%d) Unrecognized Config File format, may be corrupted. Errno : %s  \n", \
+                    __func__, __LINE__, strerror(errno)); \
+        fclose(configFile); \
+        return (-1); \
+    } \
+} while(0)
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_BST_APP_DEBUG_H */
+
diff --git a/example/bst_app/bstapp_http.c b/example/bst_app/bstapp_http.c
new file mode 100755
index 0000000..ac2eecf
--- /dev/null
+++ b/example/bst_app/bstapp_http.c
@@ -0,0 +1,173 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <pthread.h>
+
+#include "bstapp.h"
+#include "bstapp_debug.h"
+
+extern BSTAPP_REST_MSG_t bstRestMessages[];
+
+/******************************************************************
+ * @brief  This function processes incoming http request .
+ *
+ * @param[in]   fd      socket to read request data from
+ * 
+ * @note     All errors are processed internally. Caller ignores the RV
+ *********************************************************************/
+int bstapp_read_from_agent (int fd )
+{
+    char *buf;
+    int length = 0;
+    int temp = 0;
+    char report[BSTAPP_MAX_REPORT_LENGTH];
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Extracting data from incoming report  \n");
+
+    buf = &report[0];
+
+    /* Read data from incoming request into the buffer */
+    do
+    {
+        temp = read(fd, (buf + length), (BSTAPP_MAX_REPORT_LENGTH - length));
+        if (temp > 0)
+        {
+            length += temp;
+        }
+        /* Make socket as non-blocking, so that it doesn't block for connection */
+/*        sopts = fcntl(fd, F_GETFL, 0);
+        fcntl(fd, F_SETFL, sopts | O_NONBLOCK); */
+
+    } while (temp > 0);
+
+    close(fd);
+
+    /* if there is any error reading */
+    if ((temp < 0) && (length <= 0))
+    {
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR,
+                    "BSTAPP : Error reading data on incoming report, closing socket [%d : %s] \n",
+                    errno, strerror(errno));
+        return -1;
+    }
+
+    bstapp_message_log(buf, length, true);
+
+    return 0;
+}
+
+/******************************************************************
+ * @brief  sends an commands to agent and logs the received responses 
+ *
+ * 
+ * @note     
+ *********************************************************************/
+int  bstapp_communicate_with_agent(void *param)
+{
+    BSTAPP_CONFIG_t *config = (BSTAPP_CONFIG_t *) param;
+    char *header = "%s /broadview/bst/%s HTTP/1.1\r\n"
+            "Host: BroadViewAgent \r\n"
+            "User-Agent: BroadView BST App\r\n"
+            "Accept: text/html,application/xhtml+xml,application/xml\r\n"
+            "Content-Length: %d\r\n"
+            "\r\n";
+
+    char sendBuf[BSTAPP_MAX_HTTP_BUFFER_LENGTH] = { 0 };
+    int clientFd;
+    struct sockaddr_in clientAddr;
+    int temp = 0;
+    int i = 0;
+    BSTAPP_REST_MSG_t *restMsg;
+
+    _BSTAPP_ASSERT(config != NULL);
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Starting communication with agent ");
+
+    for (i=0; i < 13; i++)
+    {
+        restMsg = &bstRestMessages[i];
+
+        _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Now attempting : %s ", restMsg->descr);
+
+
+        memset(sendBuf, 0, sizeof (sendBuf));
+        snprintf(sendBuf, BSTAPP_MAX_HTTP_BUFFER_LENGTH, header,
+                 restMsg->httpMethod, restMsg->method, strlen(restMsg->json));
+
+        /* create socket to send data to */
+        clientFd = socket(AF_INET, SOCK_STREAM, 0);
+        if (clientFd == -1) {
+            _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error Creating server socket : %s \n", strerror(errno));
+            continue;
+        }
+        /* setup the socket */
+        memset(&clientAddr, 0, sizeof (struct sockaddr_in));
+        clientAddr.sin_family = AF_INET;
+        clientAddr.sin_port = htons(config->agentPort);
+        temp = inet_pton(AF_INET, &config->agentIp[0], &clientAddr.sin_addr);
+        if (temp <= 0) {
+            _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error Creating server socket %s \n", strerror(errno));
+            close(clientFd);
+            continue;
+        }
+
+        /* connect to the peer */
+        temp = connect(clientFd, (struct sockaddr *) &clientAddr, sizeof (clientAddr));
+        if (temp == -1) {
+            _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error connecting to client for sending async reports %s \n", strerror(errno));
+            close(clientFd);
+            continue;
+        }
+
+        /* log what is being sent */
+        bstapp_message_log(sendBuf, strlen(sendBuf), false);
+        bstapp_message_log(restMsg->json, strlen(restMsg->json), false);
+
+        /* send data */
+        temp = send(clientFd, sendBuf, strlen(sendBuf), MSG_MORE);
+        if (temp == -1) {
+            _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error sending data %s \n", strerror(errno));
+            close(clientFd);
+            continue;
+        }
+        temp = send(clientFd, restMsg->json, strlen(restMsg->json), 0);
+        if (temp == -1) {
+            _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error sending data %s \n", strerror(errno));
+            close(clientFd);
+            continue;
+        }
+         
+        /*Now read from the socket for the response */
+        bstapp_read_from_agent(clientFd);
+        sleep(2);
+    }
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Completed communication with agent, exiting ");
+
+    pthread_exit(NULL);
+
+}
diff --git a/example/bst_app/bstapp_json.c b/example/bst_app/bstapp_json.c
new file mode 100755
index 0000000..d440a21
--- /dev/null
+++ b/example/bst_app/bstapp_json.c
@@ -0,0 +1,263 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+
+#include "bstapp.h"
+BSTAPP_REST_MSG_t bstRestMessages[] = {
+    {
+     .httpMethod = "POST",
+     .descr = "Setting up BST Feature",
+     .method = "configure-bst-feature",
+     .json = "{     \
+                \"jsonrpc\": \"2.0\", \
+                \"method\": \"configure-bst-feature\", \
+                \"asic-id\": \"1\", \
+                \"params\": { \
+                \"bst-enable\": 1, \
+                \"send-async-reports\": 0, \
+                \"collection-interval\": 10, \
+                \"stat-units-in-cells\": 1, \
+                \"send-snapshot-on-trigger\": 1, \
+                \"trigger-rate-limit\": 1, \
+                \"trigger-rate-limit-interval\": 5, \
+                \"async-full-reports\": 0, \
+                \"stats-in-percentage\": 0 \
+                }, \
+                \"id\": 1 \
+                }"
+    },
+    {
+     .httpMethod = "POST",
+     .descr = "Setting up BST Tracking ",
+     .method = "configure-bst-tracking",
+     .json = "{ \
+                     \"jsonrpc\": \"2.0\", \
+                     \"method\": \"configure-bst-tracking\", \
+                     \"asic-id\": \"1\", \
+                     \"params\": { \
+		     \"track-peak-stats\" : 1, \
+		     \"track-ingress-port-priority-group\" : 1, \
+		     \"track-ingress-port-service-pool\" : 1, \
+		     \"track-ingress-service-pool\" : 1, \
+		     \"track-egress-port-service-pool\" : 1, \
+		     \"track-egress-service-pool\" : 1, \
+		     \"track-egress-uc-queue\" : 1, \
+		     \"track-egress-uc-queue-group\" : 1, \
+		     \"track-egress-mc-queue\" : 1, \
+		     \"track-egress-cpu-queue\" : 1, \
+		     \"track-egress-rqe-queue\" : 1, \
+		     \"track-device\" : 1 \
+		     }, \
+		     \"id\": 2 \
+		     } "
+    },
+    {
+     .httpMethod = "GET",
+     .descr = "Obtaining current feature status ",
+     .method = "get-bst-feature",
+     .json = "{ \
+                       \"jsonrpc\": \"2.0\", \
+                       \"method\": \"get-bst-feature\", \
+                       \"asic-id\": \"1\", \
+                       \"params\": { \
+                       }, \
+                       \"id\": 3 \
+                       }"
+    },
+
+
+    {
+     .httpMethod = "GET",
+     .descr = "Obtaining current tracking status ",
+     .method = "get-bst-tracking",
+     .json = "{ \
+                       \"jsonrpc\": \"2.0\", \
+                       \"method\": \"get-bst-tracking\", \
+                       \"asic-id\": \"1\", \
+                       \"params\": { \
+                       }, \
+                       \"id\": 4 \
+                       }"
+    },
+
+    {
+     .httpMethod = "GET",
+     .descr = "Obtaining a snapshot report ",
+     .method = "get-bst-report",
+     .json = "{ \
+		       \"jsonrpc\": \"2.0\", \
+		       \"method\": \"get-bst-report\", \
+		       \"asic-id\": \"1\", \
+               \"params\": { \
+		      \"include-ingress-port-priority-group\" : 1, \
+		      \"include-ingress-port-service-pool\" : 0, \
+		      \"include-ingress-service-pool\" : 0, \
+		      \"include-egress-port-service-pool\" : 0, \
+		      \"include-egress-service-pool\" : 1, \
+		      \"include-egress-uc-queue\" : 1, \
+		      \"include-egress-uc-queue-group\" : 0, \
+		      \"include-egress-mc-queue\" : 1, \
+		      \"include-egress-cpu-queue\" : 1, \
+		      \"include-egress-rqe-queue\" : 0, \
+		      \"include-device\" : 1 \
+			}, \
+              \"id\": 5\
+            } "
+    },
+
+    {
+     .httpMethod = "GET",
+     .descr = "Obtaining the thresholds ",
+     .method = "get-bst-thresholds",
+     .json = "{ \
+		       \"jsonrpc\": \"2.0\", \
+		       \"method\": \"get-bst-thresholds\", \
+		       \"asic-id\": \"1\", \
+               \"params\": { \
+		      \"include-ingress-port-priority-group\" : 1, \
+		      \"include-ingress-port-service-pool\" : 0, \
+		      \"include-ingress-service-pool\" : 0, \
+		      \"include-egress-port-service-pool\" : 0, \
+		      \"include-egress-service-pool\" : 1, \
+		      \"include-egress-uc-queue\" : 1, \
+		      \"include-egress-uc-queue-group\" : 0, \
+		      \"include-egress-mc-queue\" : 1, \
+		      \"include-egress-cpu-queue\" : 1, \
+		      \"include-egress-rqe-queue\" : 0, \
+		      \"include-device\" : 1 \
+			}, \
+              \"id\": 6\
+            } "
+    },
+    {
+     .httpMethod = "POST",
+     .descr = "Setting up few thresholds to enable trigger",
+     .method = "configure-bst-thresholds",
+     .json = "{ \
+			\"jsonrpc\": \"2.0\", \
+                             \"method\": \"configure-bst-thresholds\", \
+			\"asic-id\": \"1\", \
+                       \"params\": { \
+                             \"realm\": \"device\", \
+                             \"threshold\": 1000 \
+                       }, \
+                       \"id\": 7 \
+                       }"
+    },
+    
+    {
+     .httpMethod = "GET",
+     .descr = "Obtaining current feature status ",
+     .method = "get-bst-feature",
+     .json = "{ \
+                       \"jsonrpc\": \"2.0\", \
+                       \"method\": \"get-bst-feature\", \
+                       \"asic-id\": \"1\", \
+                       \"params\": { \
+                       }, \
+                       \"id\": 8 \
+                       }"
+    },
+    {
+     .httpMethod = "GET",
+     .descr = "Obtaining current feature status ",
+     .method = "get-bst-feature",
+     .json = "{ \
+                       \"jsonrpc\": \"2.0\", \
+                       \"method\": \"get-bst-feature\", \
+                       \"asic-id\": \"1\", \
+                       \"params\": { \
+                       }, \
+                       \"id\": 9 \
+                       }"
+    },
+
+    {
+     .httpMethod = "POST",
+     .descr = "configure bst feature with different params",
+     .method = "configure-bst-feature",
+     .json = "{     \
+                \"jsonrpc\": \"2.0\", \
+                \"method\": \"configure-bst-feature\", \
+                \"asic-id\": \"1\", \
+                \"params\": { \
+                \"bst-enable\": 1, \
+                \"send-async-reports\": 0, \
+                \"collection-interval\": 3, \
+                \"stat-units-in-cells\": 1, \
+                \"send-snapshot-on-trigger\": 1, \
+                \"trigger-rate-limit\": 2, \
+                \"trigger-rate-limit-interval\": 10, \
+                \"async-full-reports\": 0, \
+                \"stats-in-percentage\": 0 \
+                }, \
+                \"id\": 10 \
+                }"
+    },
+
+
+    {
+     .httpMethod = "GET",
+     .descr = "Obtaining current feature status ",
+     .method = "get-bst-feature",
+     .json = "{ \
+                              \"jsonrpc\": \"2.0\", \
+                       \"method\": \"get-bst-feature\", \
+                              \"asic-id\": \"1\", \
+                              \"params\": { \
+                              },\
+                               \"id\": 11 \
+                              }"
+    },
+    {
+     .httpMethod = "POST",
+     .descr = "Clearing Statistics ",
+     .method = "clear-bst-statistics",
+     .json = "{ \
+			\"jsonrpc\": \"2.0\", \
+			\"method\": \"clear-bst-statistics\", \
+			\"asic-id\": \"1\", \
+                       \"params\": { \
+                       }, \
+                       \"id\": 12 \
+                       }"
+    },
+    {
+     .httpMethod = "POST",
+     .descr = "Enabling ASYNC Reports",
+     .method = "configure-bst-feature to turn on ASYNC reports",
+     .json = "{     \
+                \"jsonrpc\": \"2.0\", \
+                \"method\": \"configure-bst-feature\", \
+                \"asic-id\": \"1\", \
+                \"params\": { \
+                \"bst-enable\": 1, \
+                \"send-async-reports\": 1, \
+                \"collection-interval\": 1, \
+                \"stat-units-in-cells\": 1, \
+                \"send-snapshot-on-trigger\": 1, \
+                \"trigger-rate-limit\": 2, \
+                \"trigger-rate-limit-interval\": 3, \
+                \"async-full-reports\": 0, \
+                \"stats-in-percentage\": 0 \
+                }, \
+                \"id\": 13 \
+                }"
+    },
+
+};
+
diff --git a/example/bst_app/bstapp_log.c b/example/bst_app/bstapp_log.c
new file mode 100755
index 0000000..8fad51c
--- /dev/null
+++ b/example/bst_app/bstapp_log.c
@@ -0,0 +1,107 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+
+#include <arpa/inet.h>
+
+#include "bstapp.h"
+#include "bstapp_debug.h"
+
+static pthread_mutex_t logLock;
+
+/******************************************************************
+ * @brief  Initializes Logging
+ *
+ * @retval   0  when logging is initialized successfully
+ *
+ * @note     
+ *********************************************************************/
+int bstapp_logging_init(void)
+{
+    int rv = 0;
+    FILE *fp;
+
+    /* initialize the mutex*/
+    rv = pthread_mutex_init(&logLock, NULL);
+    _BSTAPP_ASSERT_NET_ERROR( (rv == 0), "BSTAPP : Error creating logging mutex \n");
+
+    /* truncate the logging file if already available */
+    fp = fopen(BSTAPP_COMMUNICATION_LOG_FILE, "w");
+    if (fp != NULL)
+    {
+        fclose(fp);
+    }
+
+    return 0;
+}
+
+/******************************************************************
+ * @brief  Logs a message
+ *
+ * @retval   0  when message is logged successfully
+ *
+ * @note     
+ *********************************************************************/
+int bstapp_message_log(char *message, int length, bool isFromAgent)
+{
+    FILE *fp = NULL;
+    char timeString[BSTAPP_MAX_STRING_LENGTH] = { 0 };
+    time_t logtime;
+    struct tm *timeinfo;
+    int i = 0;
+
+    time(&logtime);
+    timeinfo = localtime(&logtime);
+    strftime(timeString, BSTAPP_MAX_STRING_LENGTH, "%Y-%m-%d %H:%M:%S ", timeinfo);
+
+    pthread_mutex_lock(&logLock);
+    fp = fopen(BSTAPP_COMMUNICATION_LOG_FILE, "a");
+
+    if (fp == NULL)
+    {
+        _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Log : Unable to open file for logging [%d:%s] \n",
+                    errno, strerror(errno));
+        pthread_mutex_unlock(&logLock);
+        return -1;
+    }
+
+    fputs(timeString, fp);
+
+    if (isFromAgent)
+    {
+        fputs("Message from Agent \n", fp);
+    }
+    else
+    {
+        fputs("Message to Agent \n", fp);
+    }
+
+    for (i = 0; i < length; i++)
+    {
+        fputc(message[i], fp);
+    }
+
+    fputs("\n", fp);
+    fclose(fp);
+
+    pthread_mutex_unlock(&logLock);
+    return 0;
+}
+
diff --git a/example/bst_app/bstapp_main.c b/example/bst_app/bstapp_main.c
new file mode 100755
index 0000000..ce2d32f
--- /dev/null
+++ b/example/bst_app/bstapp_main.c
@@ -0,0 +1,85 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <pthread.h>
+
+#include "bstapp.h"
+#include "bstapp_debug.h"
+#include "version.h"
+
+BSTAPP_CONFIG_t config;
+
+int main(int argc, char** argv)
+{
+    pthread_t httpThread;
+    int rv;
+
+    printf("BroadViewBstApp Version %s\n",RELEASE_STRING);
+
+    /* initialize configuration */
+    rv = bstapp_config_init(&config);
+    _BSTAPP_ASSERT(rv == 0);
+
+    /* setup logging */
+    rv = bstapp_logging_init();
+    _BSTAPP_ASSERT(rv == 0);
+    
+   /* No argument given */    
+   if(argc == 1 )
+    {
+        /* spawn off the agent communicator as a spearate thread */
+        rv = pthread_create(&httpThread, NULL, (void *)&bstapp_communicate_with_agent, (void *)&config);
+        _BSTAPP_ASSERT(rv == 0);
+    }
+   /* Argument given */
+   else if(argc == 2)
+    {
+        /*Argument equal to -d the Debug menu driven communication starts */
+        if (strcmp(argv[1],"-d") == 0)
+        {
+            bstapp_debug_menu((void *)&config);
+        }
+        else if(strcmp(argv[1],"-help") == 0)
+        {
+            /*Help string */
+            printf("\n\nArguments\tUsage "
+                   "\nNone\tDefault "
+                   "\n-d\tDebug Mode "
+                   "\n-help\tHelp String \n");
+        }
+        else
+        {
+            printf("\n Invalid \n ");
+        }
+    }
+ 
+    /* start the report receiver thread */
+    bstapp_http_server_run(&config);
+
+    pthread_exit(NULL);
+    return (0);
+}
+
diff --git a/example/bst_app/bstapp_menu.c b/example/bst_app/bstapp_menu.c
new file mode 100755
index 0000000..b61503d
--- /dev/null
+++ b/example/bst_app/bstapp_menu.c
@@ -0,0 +1,552 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <pthread.h>
+
+#include "bstapp.h"
+#include "bstapp_debug.h"
+
+extern BSTAPP_REST_MENU_MSG_t bstRestMenuMessages[];
+extern int bstapp_read_from_agent (int fd );
+
+/******************************************************************
+ * @brief      Read input string from user
+ *
+ * @param[in]   usrInput       Buffer to hold the string
+ *              sizeOfDest     Max size of the buffer
+ *
+ * @retval   USER_INPUT_NONE    There is no input from user
+ *           USER_INPUT_ERROR   Input is incorrect
+ *           USER_INPUT_OK      Input is successfully read.
+ * @note
+ *********************************************************************/
+static int  bstapp_get_string_from_user(char *usrInput, int sizeofinput)
+{
+
+  char inputBuf[BSTAPP_MAX_STRING_LENGTH] = { 0 };
+  int originalLen = 0;
+  
+  while(1)
+  {
+    if(fgets(inputBuf, sizeof(inputBuf), stdin) != NULL)
+    {
+      if (strlen(inputBuf) == 1)
+      {
+        return USER_INPUT_NONE;
+      }
+      originalLen = strlen(inputBuf);
+      inputBuf[originalLen-1] = 0;
+
+      if (strlen(inputBuf) > (sizeofinput-1))
+      {
+        printf("\t\t Maximum allowed is %u characters!\n", (sizeofinput-1));
+        fflush(stdin);
+        return USER_INPUT_ERROR;
+      }
+      strncpy(usrInput, inputBuf, strlen(inputBuf)+1);
+      fflush(stdin);
+      break;
+    }
+    return USER_INPUT_NONE; 
+  }
+  return USER_INPUT_OK; 
+}
+
+
+/******************************************************************
+ * @brief      Read input string from user and convert it to boolean
+ *
+ * @param[in]   usrInput        Buffer to hold the integer
+ *
+ * @retval   USER_INPUT_OK      Input is successfully read and converted to integer
+ * @note
+ *********************************************************************/
+
+int bstapp_get_bool_from_user(int *usrInput)
+{
+  char inputBuf[BSTAPP_MAX_STRING_LENGTH] = { 0 };
+  int originalLen = 0;
+
+  if (fgets(inputBuf, sizeof(inputBuf), stdin) != NULL)
+  { /* fgets reads next line char(\n) as part of string */
+    /* only \n is present */
+    if(strlen(inputBuf) == 1)
+    {
+      strncpy(inputBuf, BSTAPP_DEFAULT_ENABLE, sizeof(inputBuf));
+      *usrInput = atoi(inputBuf);
+    }
+    else
+    {
+      originalLen = strlen(inputBuf);
+      inputBuf[originalLen-1] = 0;
+
+      *usrInput = atoi(inputBuf);
+      if(*usrInput == 0)
+      {
+        *usrInput = BSTAPP_DISABLE;
+      }
+      else 
+      {
+        *usrInput = BSTAPP_ENABLE;
+      }
+    }
+  }
+  return USER_INPUT_OK; 
+}
+ 
+
+/******************************************************************
+ * @brief      Read input string from user and convert it to integer
+ *
+ * @param[in]   usrInput        Buffer to hold the integer
+ *
+ * @retval   USER_INPUT_NONE    There is no input from user
+ *           USER_INPUT_ERROR   Input is incorrect
+ *           USER_INPUT_OK      Input is successfully read and converted to integer
+ * @note
+ *********************************************************************/
+static int bstapp_get_uint_from_user(int *usrInput)
+{
+  char inputBuf[BSTAPP_MAX_STRING_LENGTH] = { 0 };
+  int originalLen = 0;
+   
+  while (1)
+  {
+    if (fgets(inputBuf, sizeof(inputBuf), stdin) != NULL)
+    {
+      /* fgets reads next line char(\n) as part of string */
+      /* only \n is present */
+      if (strlen(inputBuf) == 1)
+      {
+        return USER_INPUT_NONE;
+      }
+      originalLen = strlen(inputBuf);
+      inputBuf[originalLen-1] = 0;
+
+      if (1 == sscanf(inputBuf, "%u", usrInput))
+      {
+        fflush(stdin);
+        break;
+      }
+      else
+      {
+        fflush(stdin);
+        return USER_INPUT_ERROR;
+      }
+    }
+    return USER_INPUT_NONE;
+  }
+
+  return USER_INPUT_OK;
+}
+
+
+/******************************************************************
+ * @brief      Function that provides menu to get parameters from user
+ *
+ * @param[in]  param 
+ *
+ * @retval    0         If user input is correct and packet is prepared successfully
+ *           -1         If user input is incorrect or failed to prepare packet
+ *
+ * @note
+ *********************************************************************/
+int bstapp_debug_menu(void *param)
+{
+  BSTAPP_CONFIG_t *config = (BSTAPP_CONFIG_t *) param;
+  char *header = "%s /broadview/bst/%s HTTP/1.1\r\n"
+            "Host: BroadViewAgent \r\n"
+            "User-Agent: BroadView BST App\r\n"
+            "Accept: text/html,application/xhtml+xml,application/xml\r\n"
+            "Content-Length: %d\r\n"
+            "\r\n";
+
+
+  char sendBuf[BSTAPP_MAX_HTTP_BUFFER_LENGTH] = { 0 };
+  char jsonBuf[BSTAPP_MAX_HTTP_BUFFER_LENGTH]= { 0 };
+  int clientFd;
+  struct sockaddr_in clientAddr;
+  int temp = 0;
+  int input;
+  char inputBuf[BSTAPP_MAX_STRING_LENGTH] = { 0 };
+  char asic_id[BSTAPP_MAX_ASIC_LENGTH] = { 0 };
+  int bst_enable;
+  int collection_interval;
+  int async_report;
+  int stat_units_in_cells;
+  int track_peak_stats;
+  int track_ingress_port_priority_group;
+  int track_ingress_port_service_pool;
+  int track_ingress_service_pool;  
+  int track_egress_port_service_pool;
+  int track_egress_service_pool;
+  int track_egress_uc_queue;
+  int track_egress_uc_queue_group;
+  int track_egress_mc_queue;
+  int track_egress_cpu_queue;
+  int track_egress_rqe_queue;
+  int track_device;
+  int threshold;
+  char clearBst[BSTAPP_MAX_STRING_LENGTH] = { 0 };
+  int retValue;
+
+  BSTAPP_REST_MENU_MSG_t *restMsg;
+
+  _BSTAPP_ASSERT(config != NULL);
+
+  _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Starting communication with agent ");
+
+  while(1)	
+  {
+    printf("\n 1.Configure BST feature \n 2.Configure BST tracking \n 3.Configure BST threshold \n "
+    "4.Clear BST statistics \n 5.Clear BST threshold \n 6.Get BST feature \n 7.Get BST tracking \n "
+    "8.Get BST thresholds \n 9.Get BST report \n 10.Exit ");
+    printf("\n Select an option from the menu: ");
+    bstapp_get_uint_from_user(&input);
+ 
+    if (input > BSTAPP_MAX_INPUT || input <= 0)
+    {	
+      printf("\nInvalid Selection, Select again:\n");
+      continue; 
+    }
+    if (input == BSTAPP_MAX_INPUT)
+    {
+      exit(0);
+    }		
+    restMsg = &bstRestMenuMessages[input-1];
+
+    switch(input)
+    {			
+      case 1:
+      {	
+        /* asic id*/
+        printf("\n\t Provide asic-id (string)[1]: ");
+        retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id)); 
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+        }
+ 
+       /* bst-enable*/	
+        printf("\n\t Provide bst-enable (0/1) [1]: ");
+        bstapp_get_bool_from_user(&bst_enable);
+	
+        /* async-reports*/
+        printf("\n\t Provide asyn-report (0/1) [1]: ");
+        bstapp_get_bool_from_user(&async_report);
+					
+        /*collection-interval*/
+        printf("\n\t Provide collection-interval (0-600) [60]:  ");
+        retValue = bstapp_get_uint_from_user(&collection_interval);
+
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(inputBuf, BSTAPP_DEFAULT_COLLECTION_INTERVAL, sizeof(inputBuf));
+          collection_interval = atoi(inputBuf);
+        }
+    
+        /*stat-units-in-cells*/
+        printf("\n\t Provide stat-units-in-cells (0/1) [1]: ");
+        bstapp_get_bool_from_user(&stat_units_in_cells);
+
+        sprintf(jsonBuf, restMsg->json, asic_id, bst_enable, async_report, collection_interval, stat_units_in_cells);
+        break;
+      }	
+      
+      case 2:
+      {
+        printf("\n\t Provide asic-id(string) [1]: ");
+        retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+        }
+
+        /* track peak_stats */
+        printf("\n\t Provide track-peak-stats(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_peak_stats);
+
+        /*track_ingress_port_priority_group */
+        printf("\n\t Provide track-ingress-port-priority-group(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_ingress_port_priority_group);
+
+        /*track_ingress_port_service_pool */
+        printf("\n\t Provide track-ingress-port-service-pool(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_ingress_port_service_pool);
+       
+        /*track_ingress_service_pool */
+        printf("\n\t Provide track-ingress-service-pool(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_ingress_service_pool);
+
+        /* track_egress_port_service_pool */
+        printf("\n\t Provide track-egress-port-service-pool(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_egress_port_service_pool);
+        
+        /* track_egress_service_pool */
+        printf("\n\t Provide track-egres-service-pool(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_egress_service_pool);
+     
+        /* track_egress_uc_queue  */
+        printf("\n\t Provide track-egress-uc-queue(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_egress_uc_queue);
+
+        /* track_egress_uc_queue_group  */
+        printf("\n\t Provide track-egress-uc-queue-group(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_egress_uc_queue_group);
+        
+        /* track_egress_mc_queue  */
+        printf("\n\t Provide track-egress-mc-queue(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_egress_mc_queue);
+ 
+        /* track_egress_cpu_queue  */
+        printf("\n\t Provide track-egress-cpu-queue(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_egress_cpu_queue);
+
+        /* track_egress_rqe_queue  */
+        printf("\n\t Provide track-egres-rqe-queue(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_egress_rqe_queue);
+
+        /* track_device  */
+        printf("\n\t Provide track-device(0/1) [1]: ");
+        bstapp_get_bool_from_user(&track_device);
+        
+        sprintf(jsonBuf, restMsg->json, asic_id, track_peak_stats, track_ingress_port_priority_group,
+          track_ingress_port_service_pool, track_ingress_service_pool, track_egress_port_service_pool,
+          track_egress_service_pool, track_egress_uc_queue, track_egress_uc_queue_group,
+          track_egress_mc_queue, track_egress_cpu_queue, track_egress_rqe_queue, track_device);
+        break;
+      } 
+     
+      case 3:
+      {
+        /* asic id*/
+        printf("\n\t Provide asic-id(string) [1]: ");
+        retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+        
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+        }
+
+        /*Threshold*/
+        printf("\n\t Provide threshold [1000]: ");
+        retValue = bstapp_get_uint_from_user(&threshold);
+
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(inputBuf, BSTAPP_DEFAULT_THRESHOLD, sizeof(asic_id));
+          threshold = atoi(inputBuf);
+        }
+
+        sprintf(jsonBuf,restMsg -> json, asic_id, threshold);
+        break;
+      }
+      case 4:
+      {  
+        printf("\n\t Do you want to Clear-BST-Statistics(yes/no) [yes]: ");
+        retValue = bstapp_get_string_from_user(clearBst, sizeof(clearBst));
+        
+        if(retValue == USER_INPUT_NONE)
+        {
+          printf("\n\t\t Provide asic-id(string) [1]: ");
+          retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+          if (retValue == USER_INPUT_NONE)
+          {
+            strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+          }
+
+          sprintf(jsonBuf,restMsg -> json, asic_id);
+          break;
+        }
+
+        if (strcmp(clearBst, "yes") == 0) 
+        {/* asic id*/
+          printf("\n\t\t Provide asic-id(string) [1]: ");
+          retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+          if (retValue == USER_INPUT_NONE)
+          {
+            strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+          }
+
+          sprintf(jsonBuf,restMsg -> json, asic_id);
+          break;
+        } 
+        else
+        {
+         printf("\t BST-Statistics not cleared");
+         continue;
+        }  
+       
+      }
+      case 5:
+      {
+        printf("\n\t Do you want to Clear-BST-Threshold(yes/no) [yes]: ");
+        retValue = bstapp_get_string_from_user(clearBst, sizeof(clearBst));
+        
+        if(retValue == USER_INPUT_NONE)
+        {
+          printf("\n\t\t Provide asic-id(string) [1]: ");
+          retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+          if (retValue == USER_INPUT_NONE)
+          {
+            strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+          }
+
+          sprintf(jsonBuf,restMsg -> json, asic_id);
+          break;
+        }
+
+        if (strcmp(clearBst, "yes") == 0)
+        {/* asic id*/
+          printf("\n\t\t Provide asic-id(string) [1]: ");
+          retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+          if (retValue == USER_INPUT_NONE)
+          {
+            strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+          }
+
+          sprintf(jsonBuf,restMsg -> json, asic_id);
+          break;
+        }
+        else
+        {
+           printf("\t BST-Statistics not cleared");
+           continue;
+        }
+      }
+
+      case 6:
+      {
+        /* asic id*/
+        printf("\n\t Provide asic-id(string) [1]: ");
+        retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+        }
+
+        sprintf(jsonBuf,restMsg -> json, asic_id);
+        break;	
+      }		
+      case 7:
+      {
+        /* asic id*/
+        printf("\n\t Provide asic-id [1]: ");
+        retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+        }
+
+        sprintf(jsonBuf,restMsg -> json, asic_id);
+        break;
+      }	
+      case 8:
+      {
+        /* asic id*/
+        printf("\n\t Provide asic-id [1]: ");
+        retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+        }
+
+        sprintf(jsonBuf,restMsg -> json, asic_id);
+        break;
+      }
+      case 9:
+      {
+        /* asic id*/
+        printf("\n\t Provide asic-id [1]: ");
+        retValue = bstapp_get_string_from_user(asic_id, sizeof(asic_id));
+        if (retValue == USER_INPUT_NONE)
+        {
+          strncpy(asic_id, BSTAPP_DEFAULT_ASIC_ID, sizeof(asic_id));
+        }
+
+        sprintf(jsonBuf,restMsg -> json, asic_id);
+        break;
+      }
+    }
+    _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "\n Now attempting : %s ", restMsg->descr);
+
+    memset(sendBuf, 0, sizeof (sendBuf));
+    snprintf(sendBuf, BSTAPP_MAX_HTTP_BUFFER_LENGTH, header,
+    restMsg->httpMethod, restMsg->method, strlen(jsonBuf));
+    
+    /* create socket to send data to */
+    clientFd = socket(AF_INET, SOCK_STREAM, 0);
+    if (clientFd == -1) {
+      _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "\n Error Creating server socket : %s \n", strerror(errno));
+    continue;        
+    }
+    /* setup the socket */
+    memset(&clientAddr, 0, sizeof (struct sockaddr_in));
+    clientAddr.sin_family = AF_INET;
+    clientAddr.sin_port = htons(config->agentPort);
+    temp = inet_pton(AF_INET, &config->agentIp[0], &clientAddr.sin_addr);
+    if (temp <= 0) {
+      _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error Creating server socket %s \n", strerror(errno));
+      close(clientFd);
+      continue;
+    }
+        
+    /* connect to the peer */
+    temp = connect(clientFd, (struct sockaddr *) &clientAddr, sizeof (clientAddr));
+    if (temp == -1) {
+      _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error connecting to client for sending async reports %s \n", strerror(errno));
+      close(clientFd);
+      continue;
+    }
+
+    /* log what is being sent */
+    bstapp_message_log(sendBuf, strlen(sendBuf), false);
+    bstapp_message_log(jsonBuf, strlen(jsonBuf), false);
+   
+    /* send data */
+    temp = send(clientFd, sendBuf, strlen(sendBuf), MSG_MORE);
+    if (temp == -1) {
+      _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error sending data %s \n", strerror(errno));
+      close(clientFd);
+      continue;
+    }
+    temp = send(clientFd, jsonBuf, strlen(jsonBuf), 0);
+    if (temp == -1) {
+      _BSTAPP_LOG(_BSTAPP_DEBUG_ERROR, "Error sending data %s \n", strerror(errno));
+      close(clientFd);
+      continue;
+    }
+
+   /*Now read from the socket for the response */
+   bstapp_read_from_agent(clientFd);
+   sleep(2);
+   close(clientFd);
+ }
+
+  _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Completed communication with agent, exiting ");
+
+  pthread_exit(NULL);
+
+}                       
diff --git a/example/bst_app/bstapp_menu_json.c b/example/bst_app/bstapp_menu_json.c
new file mode 100755
index 0000000..da05871
--- /dev/null
+++ b/example/bst_app/bstapp_menu_json.c
@@ -0,0 +1,181 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+#include "bstapp.h"
+
+BSTAPP_REST_MENU_MSG_t bstRestMenuMessages[] = {
+  {
+    .httpMethod = "POST",
+    .descr = "Setting up BST Feature",
+    .method = "configure-bst-feature",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"configure-bst-feature\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+               \"bst-enable\": %d, \
+               \"send-async-reports\": %d, \
+               \"collection-interval\": %d, \
+               \"stat-units-in-cells\": %d \
+               }, \
+              \"id\": 1 \
+             }"
+  },
+  {
+    .httpMethod = "POST",
+    .descr = "Setting up BST Tracking ",
+    .method = "configure-bst-tracking",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"configure-bst-tracking\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+               \"track-peak-stats\" :%d, \
+               \"track-ingress-port-priority-group\" : %d, \
+               \"track-ingress-port-service-pool\" : %d, \
+               \"track-ingress-service-pool\" : %d, \
+               \"track-egress-port-service-pool\" : %d, \
+               \"track-egress-service-pool\" : %d, \
+               \"track-egress-uc-queue\" :%d , \
+               \"track-egress-uc-queue-group\" : %d, \
+               \"track-egress-mc-queue\" : %d, \
+               \"track-egress-cpu-queue\" : %d, \
+               \"track-egress-rqe-queue\" : %d, \
+               \"track-device\" : %d \
+                }, \
+                \"id\": 2 \
+             } "
+  },
+  {
+    .httpMethod = "POST",
+    .descr = "Setting up few thresholds to enable trigger",
+    .method = "configure-bst-thresholds",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"configure-bst-thresholds\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+                 \"realm\": \"device\", \
+                 \"threshold\": %d \
+               }, \
+               \"id\": 3 \
+             }"
+  },
+  {
+    .httpMethod = "POST",
+    .descr = "Clearing Statistics ",
+    .method = "clear-bst-statistics",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"clear-bst-statistics\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+               }, \
+               \"id\": 4 \
+             }"
+  },
+  {
+    .httpMethod = "POST",
+    .descr = "Clearing Thresholds ",
+    .method = "clear-bst-thresholds",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"clear-bst-thresholds\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+               }, \
+               \"id\": 5 \
+             }"
+  },
+
+  {
+    .httpMethod = "GET",
+    .descr = "Obtaining current feature status ",
+    .method = "get-bst-feature",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"get-bst-feature\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+               }, \
+               \"id\": 6 \
+             }"
+  },
+{
+    .httpMethod = "GET",
+    .descr = "Obtaining current tracking status ",
+    .method = "get-bst-tracking",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"get-bst-tracking\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+               }, \
+               \"id\": 7 \
+             }"
+  },
+  {
+    .httpMethod = "GET",
+    .descr = "Obtaining the thresholds ",
+    .method = "get-bst-thresholds",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"get-bst-thresholds\", \
+               \"asic-id\": \"%s\", \
+               \"params\": { \
+                 \"include-ingress-port-priority-group\" : 1, \
+                 \"include-ingress-port-service-pool\" : 0, \
+                 \"include-ingress-service-pool\" : 0, \
+                 \"include-egress-port-service-pool\" : 0, \
+                 \"include-egress-service-pool\" : 1, \
+                 \"include-egress-uc-queue\" : 1, \
+                 \"include-egress-uc-queue-group\" : 0, \
+                 \"include-egress-mc-queue\" : 1, \
+                 \"include-egress-cpu-queue\" : 1, \
+                 \"include-egress-rqe-queue\" : 0, \
+                 \"include-device\" : 1 \
+                 }, \
+               \"id\": 8 \
+            }"
+  },
+  {
+    .httpMethod = "GET",
+    .descr = "Obtaining a snapshot report ",
+    .method = "get-bst-report",
+    .json = "{ \
+               \"jsonrpc\": \"2.0\", \
+               \"method\": \"get-bst-report\", \
+               \"asic-id\" : \"%s\", \
+               \"params\": { \
+                 \"include-ingress-port-priority-group\" : 1, \
+                 \"include-ingress-port-service-pool\" : 0, \
+                 \"include-ingress-service-pool\" : 0, \
+                 \"include-egress-port-service-pool\" : 0, \
+                 \"include-egress-service-pool\" : 1, \
+                 \"include-egress-uc-queue\" : 1, \
+                 \"include-egress-uc-queue-group\" : 0, \
+                 \"include-egress-mc-queue\" : 1, \
+                 \"include-egress-cpu-queue\" : 1, \
+                 \"include-egress-rqe-queue\" : 0, \
+                 \"include-device\" : 1 \
+                 }, \
+              \"id\": 9\
+             }"
+  },
+};
+
+
diff --git a/example/bst_app/bstapp_reports.c b/example/bst_app/bstapp_reports.c
new file mode 100755
index 0000000..bd19f51
--- /dev/null
+++ b/example/bst_app/bstapp_reports.c
@@ -0,0 +1,101 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "bstapp.h"
+#include "bstapp_debug.h"
+extern int bstapp_read_from_agent (int fd );
+static int numReports = 0;
+
+/******************************************************************
+ * @brief  This function starts a web server and never returns (unless an error).
+ *
+ * @param[in]   bstapp      BSTAPP context for operation
+ *                           
+ * @retval   -1 Error creating web server
+ *
+ * @note     IPv4 only, non-multi-threaded.
+ *********************************************************************/
+int bstapp_http_server_run(BSTAPP_CONFIG_t *config)
+{
+    int listenFd, connectionFd;
+    int temp;
+    struct sockaddr_in serverAddr;
+    struct sockaddr_in peerAddr;
+    socklen_t peerLen;
+
+    _BSTAPP_ASSERT(config != NULL);
+
+    _BSTAPP_LOG(_BSTAPP_DEBUG_INFO, "Starting HTTP server on port %d \n", config->localPort);
+
+    /* setup listening socket */
+    listenFd = socket(AF_INET, SOCK_STREAM, 0);
+    _BSTAPP_ASSERT_NET_ERROR((listenFd != -1), "Error Creating server socket");
+
+    /* Initialize the server address and bind to the required port */
+    memset(&serverAddr, 0, sizeof (struct sockaddr_in));
+    serverAddr.sin_family = AF_INET;
+    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    serverAddr.sin_port = htons(config->localPort);
+
+    /* bind to the socket, */
+    temp = bind(listenFd, (struct sockaddr*) &serverAddr, sizeof (serverAddr));
+    _BSTAPP_ASSERT_NET_SOCKET_ERROR((temp != -1), "Error binding to the port",listenFd);
+
+    /* Listen for connections */
+    temp = listen(listenFd, 1);
+    _BSTAPP_ASSERT_NET_SOCKET_ERROR((temp != -1), "Error listening (making socket as passive) ",listenFd);
+
+    /* Every thing set, start accepting connections */
+    while (numReports <= config->maxReports)
+    {
+        _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Waiting for HTTP connections on port %d \n", config->localPort);
+
+        peerLen = sizeof (peerAddr);
+
+        /* wait for an incoming connection */
+        temp = accept(listenFd, (struct sockaddr*) &peerAddr, &peerLen);
+        if (temp == -1)
+        {
+          _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Accept Failed \n");
+          continue;
+        }
+        _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "Received connection \n");
+
+        /* initialize the connection socket */
+        connectionFd = temp;
+
+        /* process the request */
+        if (bstapp_read_from_agent(connectionFd) == 0)
+            numReports++;
+    }
+
+    /* execution  shouldn't reach here */
+    _BSTAPP_LOG(_BSTAPP_DEBUG_TRACE, "HTTP Server , exiting [%d: %s] \n", errno, strerror(errno));
+    close(listenFd);
+    return 0;
+
+}
diff --git a/feature_user_guide.md b/feature_user_guide.md
new file mode 100755
index 0000000..3089042
--- /dev/null
+++ b/feature_user_guide.md
@@ -0,0 +1,58 @@
+<!--  See the https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet for additional information about markdown text.
+Here are a few suggestions in regards to style and grammar:
+* Use active voice. With active voice, the subject is the doer of the action. Tell the reader what
+to do by using the imperative mood, for example, Press Enter to view the next screen. See https://en.wikipedia.org/wiki/Active_voice for more information about the active voice. 
+* Use present tense. See https://en.wikipedia.org/wiki/Present_tense for more information about using the present tense. 
+* Avoid the use of I or third person. Address your instructions to the user. In text, refer to the reader as you (second person) rather than as the user (third person). The exception to not using the third-person is when the documentation is for an administrator. In that case, *the user* is someone the reader interacts with, for example, teach your users how to back up their laptop. 
+* See https://en.wikipedia.org/wiki/Wikipedia%3aManual_of_Style for an online style guide.
+Note regarding anchors:
+--StackEdit automatically creates an anchor tag based off of each heading.  Spaces and other nonconforming characters are substituted by other characters in the anchor when the file is converted to HTML. 
+ --> 
+ 
+BroadView Daemon
+=======
+<!--Provide the title of the feature-->
+
+ [TOC]
+ 
+## Overview ##
+Networks have become business critical and Network Operators are demanding greater instrumentation and telemetry capabilities so that they can get better visibility into their networks. Increased visibility enables them to proactively identify problems that may lead to poor network performance. It also helps network operators to better plan and fine tune their networks to meet strict SLAs and improve and maintain Application performance. Broadcom has introduced the [BroadView Instrumentation](https://github.com/Broadcom-Switch/BroadView-Instrumentation)software suite -- an industry first -- that provides unprecedented visibility into switch silicon. BroadView Instrumentation exposes the various instrumentation capabilities in Broadcom silicon and eases adoption of it by working with the ecosystem partners.
+
+The suite consists of an Agent that runs on the switch and Applications that interface with the Agent over Open REST API. Applications visualize, analyze data exported by the Agent, and provide the operator the ability to fine tune the network. The Agent is Open and portable across different Network Operating Systems. The BroadView Daemon is the implementation of the Agent functionality on OpenSwitch.
+
+The BroadView Daemon provides instrumentation capability for OpenSwitch. In the current release, it obtains MMU Buffer Statistics from Broadcom silicon and exports them via the REST API. This allows Instrumentation collectors or Apps to obtain the MMU Buffer stats and visualize buffer utilization patterns and detect microbursts. These help an operator to get visibility into the network and switch performance and fine tune the network. Some traffic, such as storage, requires lossless capability, and operators whose network carries these types of traffic are interested in learning about microbursts and tuning network to avoid packet drops during related congestion events.
+
+The BroadView Daemon is recommended to be used with OpenSwitch running on a hardware platform (e.g. AS5712 from Accton).
+ 
+## (Optional) Conceptual or reference info here ##
+<!--Change heading for conceptual or reference info, such as Prerequisites. -->
+## How to use the feature ##
+
+###Setting up the basic configuration
+
+ 1. Step 1
+
+###Setting up the optional configuration
+
+ 1. Step 1
+
+###Verifying the configuration
+
+ 1. Step 1
+
+###Troubleshooting the configuration
+
+#### Condition 
+Type the symptoms for the issue.
+#### Cause 
+Type the cause for the issue.
+#### Remedy  
+Type the solution.
+## CLI ##
+There are no CLI for BroadView Daemon.
+## REST API ##
+Instrumentation Collectors and Apps interface with the BroadView Daemon via [REST API](http://broadcom-switch.github.io/BroadView-Instrumentation/doc/html/dc/d3f/REST.html)  
+## Related features ##
+(<!-- Enter content into this section to describe features that may need to be considered in relation to this particular feature, under what conditions and why.  Provide a hyperlink to each related feature.  Sample text is included below as a potential example or starting point.  -->
+When configuring the switch for FEATURE_NAME, it might also be necessary to configure [RELATED_FEATURE1](https://openswitch.net./tbd/other_filefeatures/related_feature1.html#first_anchor) so that....
+
diff --git a/output/Makefile b/output/Makefile
new file mode 100755
index 0000000..d9144a3
--- /dev/null
+++ b/output/Makefile
@@ -0,0 +1,29 @@
+
+#  global definitions
+#
+
+-include package.cfg
+
+ifeq ($(OPENAPPS_BASE),)
+   OPENAPPS_BASE := $(shell echo $(dir $(abspath $(firstword $(MAKEFILE_LIST)))) | sed -e 's/\(.*\)\/output\/.*/\1/')
+endif
+export OPENAPPS_BASE
+
+ifeq ($(OPENAPPS_OUTPATH),)
+   OPENAPPS_OUTPATH = $(shell echo $(dir $(abspath $(firstword $(MAKEFILE_LIST)))) | sed -e 's/\(.*\)\//\1/')
+endif
+export OPENAPPS_OUTPATH
+
+#ifeq ($(CROSS_COMPILE),)
+#   CROSS_COMPILE = /usr/bin/
+#endif
+#export CROSS_COMPILE
+
+ifeq ($(platform),)
+   platform = gto-2_6
+endif
+export platform
+
+export __BYTE_ORDER =__BIG_ENDIAN
+
+include $(OPENAPPS_BASE)/tools/Make.common
diff --git a/output/feature.h b/output/feature.h
new file mode 100755
index 0000000..e9b03b8
--- /dev/null
+++ b/output/feature.h
@@ -0,0 +1,6 @@
+#ifndef FEATURE_H
+#define FEATURE_H
+
+#define FEAT_BST 1
+
+#endif /* FEATURE_H */
diff --git a/output/package.cfg b/output/package.cfg
new file mode 100755
index 0000000..18625ba
--- /dev/null
+++ b/output/package.cfg
@@ -0,0 +1,16 @@
+export COMPONENTS=bst
+export CPU=x86_64
+export CUSTOMER=Broadcom
+export PLATFORM=OP-OVSDB
+export SBPLUGIN=ovsdb
+export TARGETOS=Linux
+export TARGETOS_VARIANT=ubuntu_14
+export VERSION=v2.3.1
+export BCM_REL_NUM=2
+export BCM_VER_NUM=0
+export BCM_MAINT_NUM=4
+export BCM_BUILD_NUM=3
+export BUILD_ID=UB-OVSDB
+##########################
+#     Flex Options       #
+##########################
diff --git a/platform/UB-OVSDB/platform.h b/platform/UB-OVSDB/platform.h
new file mode 100755
index 0000000..1d1ec42
--- /dev/null
+++ b/platform/UB-OVSDB/platform.h
@@ -0,0 +1,125 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+
+#ifndef INCLUDE_PLATFORM_H
+#define INCLUDE_PLATFORM_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* BST:*/
+/*Default The BST_Threshold for the Egress UC Queues in units of bytes.*/
+#define BVIEW_BST_UCAST_THRES_DEFAULT                 (0x3FFF * 208)
+
+/*Default The BST_Threshold for the Egress MC Queues*/
+#define BVIEW_BST_MCAST_THRES_DEFAULT                 (0x1FFFF * 208)
+
+
+/*Default BST_Threshold for the Egress Per (Port, SP) UC shared in units of bytes.*/
+#define BVIEW_BST_E_P_SP_UC_THRES_DEFAULT             (0x3FFF * 208)
+
+
+
+/*Default BST_Threshold for the Egress Per (Port, SP) MC/UC+MC shared in units of bytes*/
+#define BVIEW_BST_E_P_SP_UCMC_THRES_DEFAULT           (0x1FFFF * 208)
+
+ /*  Default BST_Threshold for each of the 4 Egress
+  *  SPs Shared use-counts (UC+MC)in units of bytes.
+  */
+
+#define BVIEW_BST_E_SP_UCMC_THRES_DEFAULT             (0x1FFFF * 208)
+
+ /*  Default BST_Threshold for each of the 4 Egress
+  * SPs Shared use-counts (MC) in units of bytes.
+  */
+
+#define BVIEW_BST_E_SP_MC_THRES_DEFAULT               (0x1FFFF * 208)
+
+
+ /*  Default BST_Threshold for each of the Egress
+  *  CPU queues use-counts (UC+MC)in units of bytes.
+  */
+
+#define BVIEW_BST_E_CPU_UCMC_THRES_DEFAULT            (0x1FFFF * 208)
+
+ /*  Default BST_Threshold for each of the Egress
+  *  RQE queues use-counts  in units of bytes.
+  */
+
+#define BVIEW_BST_E_RQE_THRES_DEFAULT                 (0x1FFFF * 208)
+
+/*  Default The BST_Threshold for the
+ * (Ingress Port, PG) UC plus MC Shared use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_P_PG_UCMC_SHARED_THRES_DEFAULT   (0x1FFFF * 208)
+
+
+/*  Default The BST_Threshold for the
+ * (Ingress Port, PG) UC plus MC Headroom use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_P_PG_UCMC_HDRM_THRES_DEFAULT     (0xFFF * 208)
+
+
+/* Default The BST_Threshold for the
+ * (Ingress Port, SP) UC plus MC shared use-count in units of bytes.
+ */
+#define  BVIEW_BST_I_P_SP_UCMC_SHARED_THRES_DEFAULT   (0x1FFFF * 208)
+/* Default The BST_Threshold for the Ingress SP
+ * UC plus MC use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_SP_UCMC_SHARED_THRES_DEFAULT     (0x1FFFF * 208)
+
+
+/* Default The BST_Threshold for Device Use-Countin units of bytes.*/
+
+#define  BVIEW_BST_DEVICE_THRES_DEFAULT               (0x1FFFF * 208)
+
+#define  BVIEW_BST_UCAST_QUEUE_GROUP_DEFAULT          (0x3FFF * 208)
+
+
+/* default settings of the BST buffers */
+#define SB_BRCM_BST_STAT_ID_DEVICE_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PRI_GROUP_SHARED_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PRI_GROUP_HEADROOM_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PORT_POOL_DEFAULT 0xEA77
+#define SB_BRCM_BST_STAT_ID_ING_POOL_DEFAULT 0xDC0B
+#define SB_BRCM_BST_STAT_ID_EGR_UCAST_PORT_SHARED_DEFAULT  0xd942
+#define SB_BRCM_BST_STAT_ID_EGR_PORT_SHARED_DEFAULT 0xd942
+#define SB_BRCM_BST_STAT_ID_EGR_POOL_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_EGR_MCAST_POOL_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_UCAST_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_UCAST_GROUP_DEFAULT 0x1ff
+#define SB_BRCM_BST_STAT_ID_MCAST_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_CPU_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_RQE_QUEUE_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_RQE_POOL_DEFAULT 0xea77
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_PLATFORM_H */
+
diff --git a/platform/common/platform_spec.h b/platform/common/platform_spec.h
new file mode 100755
index 0000000..bda0539
--- /dev/null
+++ b/platform/common/platform_spec.h
@@ -0,0 +1,43 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+#ifndef INCLUDE_PLATFORM_SPEC_H
+#define INCLUDE_PLATFORM_SPEC_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#if defined(BVIEW_CHIP_TD2)
+#include "trident2/platform.h"
+#endif
+
+#if defined(BVIEW_CHIP_TOMAHAWK)
+#include "tomahawk/platform.h"
+#endif
+
+#if defined(BVIEW_CHIP_PCLINUX)
+#include "pclinux/platform.h"
+#endif
+
+#if defined(BVIEW_CHIP_OVSDB)
+#include "UB-OVSDB/platform.h"
+#endif
+
+#endif /* INCLUDE_PLATFORM_SPEC_H */
+
diff --git a/platform/tomahawk/platform.h b/platform/tomahawk/platform.h
new file mode 100755
index 0000000..c2226b7
--- /dev/null
+++ b/platform/tomahawk/platform.h
@@ -0,0 +1,126 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+
+#ifndef INCLUDE_PLATFORM_H
+#define INCLUDE_PLATFORM_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* BST:*/
+/*Default The BST_Threshold for the Egress UC Queues in units of bytes.*/
+#define BVIEW_BST_UCAST_THRES_DEFAULT                 (0xFFF * 208)
+
+/*Default The BST_Threshold for the Egress MC Queues*/
+#define BVIEW_BST_MCAST_THRES_DEFAULT                 (0x7FFF * 208)
+
+
+/*Default BST_Threshold for the Egress Per (Port, SP) UC shared in units of bytes.*/
+#define BVIEW_BST_E_P_SP_UC_THRES_DEFAULT             (0x7FFF * 208)
+
+
+
+/*Default BST_Threshold for the Egress Per (Port, SP) MC/UC+MC shared in units of bytes*/
+#define BVIEW_BST_E_P_SP_UCMC_THRES_DEFAULT           (0x7FFF * 208)
+
+ /*  Default BST_Threshold for each of the 4 Egress
+  *  SPs Shared use-counts (UC+MC)in units of bytes.
+  */
+
+#define BVIEW_BST_E_SP_UCMC_THRES_DEFAULT             (0x7FFF * 208)
+
+ /*  Default BST_Threshold for each of the 4 Egress
+  * SPs Shared use-counts (MC) in units of bytes.
+  */
+
+#define BVIEW_BST_E_SP_MC_THRES_DEFAULT               (0x7FFF * 208)
+
+
+ /*  Default BST_Threshold for each of the Egress
+  *  CPU queues use-counts (UC+MC)in units of bytes.
+  */
+
+#define BVIEW_BST_E_CPU_UCMC_THRES_DEFAULT            (0x7FFF * 208)
+
+ /*  Default BST_Threshold for each of the Egress
+  *  RQE queues use-counts  in units of bytes.
+  */
+
+#define BVIEW_BST_E_RQE_THRES_DEFAULT                 (0x7FFF * 208)
+
+/*  Default The BST_Threshold for the
+ * (Ingress Port, PG) UC plus MC Shared use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_P_PG_UCMC_SHARED_THRES_DEFAULT   (0x7FFF * 208)
+
+
+/*  Default The BST_Threshold for the
+ * (Ingress Port, PG) UC plus MC Headroom use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_P_PG_UCMC_HDRM_THRES_DEFAULT     (0x7FFF * 208)
+
+
+/* Default The BST_Threshold for the
+ * (Ingress Port, SP) UC plus MC shared use-count in units of bytes.
+ */
+#define  BVIEW_BST_I_P_SP_UCMC_SHARED_THRES_DEFAULT   (0x7FFF * 208)
+/* Default The BST_Threshold for the Ingress SP
+ * UC plus MC use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_SP_UCMC_SHARED_THRES_DEFAULT     (0x7FFF * 208)
+
+
+/* Default The BST_Threshold for Device Use-Countin units of bytes.*/
+
+#define  BVIEW_BST_DEVICE_THRES_DEFAULT               (0x7FFF * 208)
+       
+
+/* Default BST_Threshold for Unicast Queue Group*/
+#define  BVIEW_BST_UCAST_QUEUE_GROUP_DEFAULT          (0xFFF * 208)
+
+/* default settings of the BST buffers */
+#define SB_BRCM_BST_STAT_ID_DEVICE_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PRI_GROUP_SHARED_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PRI_GROUP_HEADROOM_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PORT_POOL_DEFAULT 0xEA77
+#define SB_BRCM_BST_STAT_ID_ING_POOL_DEFAULT 0xDC0B
+#define SB_BRCM_BST_STAT_ID_EGR_UCAST_PORT_SHARED_DEFAULT  0xd942
+#define SB_BRCM_BST_STAT_ID_EGR_PORT_SHARED_DEFAULT 0xd942
+#define SB_BRCM_BST_STAT_ID_EGR_POOL_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_EGR_MCAST_POOL_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_UCAST_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_UCAST_GROUP_DEFAULT 0x1ff
+#define SB_BRCM_BST_STAT_ID_MCAST_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_CPU_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_RQE_QUEUE_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_RQE_POOL_DEFAULT 0xea77
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_PLATFORM_H */
+
diff --git a/platform/trident2/platform.h b/platform/trident2/platform.h
new file mode 100755
index 0000000..8d22421
--- /dev/null
+++ b/platform/trident2/platform.h
@@ -0,0 +1,124 @@
+/*****************************************************************************
+*
+* (C) Copyright Broadcom Corporation 2015
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+*
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************************/
+
+#ifndef INCLUDE_PLATFORM_H
+#define INCLUDE_PLATFORM_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* BST:*/
+/*Default The BST_Threshold for the Egress UC Queues in units of bytes.*/
+#define BVIEW_BST_UCAST_THRES_DEFAULT                 (0x3FFF * 208)
+
+/*Default The BST_Threshold for the Egress MC Queues*/
+#define BVIEW_BST_MCAST_THRES_DEFAULT                 (0x1FFFF * 208)
+
+
+/*Default BST_Threshold for the Egress Per (Port, SP) UC shared in units of bytes.*/
+#define BVIEW_BST_E_P_SP_UC_THRES_DEFAULT             (0x3FFF * 208)
+
+
+
+/*Default BST_Threshold for the Egress Per (Port, SP) MC/UC+MC shared in units of bytes*/
+#define BVIEW_BST_E_P_SP_UCMC_THRES_DEFAULT           (0x1FFFF * 208)
+
+ /*  Default BST_Threshold for each of the 4 Egress
+  *  SPs Shared use-counts (UC+MC)in units of bytes.
+  */
+
+#define BVIEW_BST_E_SP_UCMC_THRES_DEFAULT             (0x1FFFF * 208)
+
+ /*  Default BST_Threshold for each of the 4 Egress
+  * SPs Shared use-counts (MC) in units of bytes.
+  */
+
+#define BVIEW_BST_E_SP_MC_THRES_DEFAULT               (0x1FFFF * 208)
+
+
+ /*  Default BST_Threshold for each of the Egress
+  *  CPU queues use-counts (UC+MC)in units of bytes.
+  */
+
+#define BVIEW_BST_E_CPU_UCMC_THRES_DEFAULT            (0x1FFFF * 208)
+
+ /*  Default BST_Threshold for each of the Egress
+  *  RQE queues use-counts  in units of bytes.
+  */
+
+#define BVIEW_BST_E_RQE_THRES_DEFAULT                 (0x1FFFF * 208)
+
+/*  Default The BST_Threshold for the
+ * (Ingress Port, PG) UC plus MC Shared use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_P_PG_UCMC_SHARED_THRES_DEFAULT   (0x1FFFF * 208)
+
+
+/*  Default The BST_Threshold for the
+ * (Ingress Port, PG) UC plus MC Headroom use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_P_PG_UCMC_HDRM_THRES_DEFAULT     (0xFFF * 208)
+
+
+/* Default The BST_Threshold for the
+ * (Ingress Port, SP) UC plus MC shared use-count in units of bytes.
+ */
+#define  BVIEW_BST_I_P_SP_UCMC_SHARED_THRES_DEFAULT   (0x1FFFF * 208)
+/* Default The BST_Threshold for the Ingress SP
+ * UC plus MC use-count in units of bytes.
+ */
+
+#define  BVIEW_BST_I_SP_UCMC_SHARED_THRES_DEFAULT     (0x1FFFF * 208)
+
+
+/* Default The BST_Threshold for Device Use-Countin units of bytes.*/
+
+#define  BVIEW_BST_DEVICE_THRES_DEFAULT               (0x1FFFF * 208)
+
+#define  BVIEW_BST_UCAST_QUEUE_GROUP_DEFAULT          (0x3FFF * 208)
+
+/* default settings of the BST buffers for TD2 */
+#define SB_BRCM_BST_STAT_ID_DEVICE_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PRI_GROUP_SHARED_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PRI_GROUP_HEADROOM_DEFAULT 0xFFFF
+#define SB_BRCM_BST_STAT_ID_PORT_POOL_DEFAULT 0xEA77
+#define SB_BRCM_BST_STAT_ID_ING_POOL_DEFAULT 0xDC0B
+#define SB_BRCM_BST_STAT_ID_EGR_UCAST_PORT_SHARED_DEFAULT  0xd942
+#define SB_BRCM_BST_STAT_ID_EGR_PORT_SHARED_DEFAULT 0xd942
+#define SB_BRCM_BST_STAT_ID_EGR_POOL_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_EGR_MCAST_POOL_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_UCAST_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_UCAST_GROUP_DEFAULT 0x1ff
+#define SB_BRCM_BST_STAT_ID_MCAST_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_CPU_DEFAULT 0xea81
+#define SB_BRCM_BST_STAT_ID_RQE_QUEUE_DEFAULT 0xea77
+#define SB_BRCM_BST_STAT_ID_RQE_POOL_DEFAULT 0xea77
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_PLATFORM_H */
+
diff --git a/src/apps/agent/agent.c b/src/apps/agent/agent.c
new file mode 100755
index 0000000..777579e
--- /dev/null
+++ b/src/apps/agent/agent.c
@@ -0,0 +1,61 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <string.h>
+#include "system.h"
+#include "version.h"
+
+int main(int argc, char **argv)
+{
+  bool debug = false;
+  bool menu = false;
+
+  if (argc > 2)
+  {
+    printf("Invalid number of arguments\n");
+    return -1;
+  }
+
+  if (argc == 2)
+  {
+    if (strcmp(argv[1], "-d") == 0) 
+    {
+      debug = true;
+    }
+    else if (strcmp(argv[1], "-c") == 0)
+    {
+      debug = true;
+      menu = true;
+    }
+    else if (strcmp(argv[1], "-h") == 0)
+    {
+      printf("Usage %s [OPTION]\n", argv[0]);
+      printf("       -d    Driver debug mode\n");
+      printf("       -c    Driver menu mode\n");
+      return 0;
+    }
+    else
+    {
+      printf("Invalid option! Try -h for help\n");
+      return -1;
+    }
+  }
+  printf("BroadViewAgent Version %s\n",RELEASE_STRING);
+  bview_system_init_ph1(debug, menu);
+  return 0;
+}
diff --git a/src/apps/bst/Makefile b/src/apps/bst/Makefile
new file mode 100755
index 0000000..e550909
--- /dev/null
+++ b/src/apps/bst/Makefile
@@ -0,0 +1,40 @@
+MODULE := bst
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+CFLAGS += -Wall -g -I. -I../../public -I../../../public -I./api -I../../sb_plugin/include -I../../../vendor/cjson -I../../../platform
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+export OUT_BST=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_BST=$(MODULE).a
+
+searchdirs = $(realpath $(OPENAPPS_BASE)/src/apps/bst/api)
+
+export CPATH += $(searchdirs)
+OBJECTS_BST := $(notdir $(patsubst %.c,%.o,$(shell find . -name "*.c")))
+
+export VPATH += $(dir $(shell find . -name "*.c"))
+
+$(OUT_BST)/%.o : %.c
+	@mkdir -p $(OUT_BST) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_BST)/$(LIBS_BST): $(patsubst %,$(OUT_BST)/%,$(subst :, ,$(OBJECTS_BST))) 
+	@cd $(OUT_BST) && $(AR) rvs $(MODULE).a $(OBJECTS_BST)  
+
+#default target
+$(MODULE) all: $(OUT_BST)/$(LIBS_BST) 
+	$(NOOP)
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_BST)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_BST=$(OUT_BST)"
+	@echo "LIBS_BST=$(LIBS_BST)"
+	@echo "OBJECTS_BST=$(OBJECTS_BST)"
diff --git a/src/apps/bst/api/bst_json_encoder.c b/src/apps/bst/api/bst_json_encoder.c
new file mode 100755
index 0000000..189aff1
--- /dev/null
+++ b/src/apps/bst/api/bst_json_encoder.c
@@ -0,0 +1,705 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <time.h>
+#include <inttypes.h>
+#include <math.h>
+
+#include "broadview.h"
+#include "cJSON.h"
+
+#include "configure_bst_feature.h"
+#include "configure_bst_tracking.h"
+#include "get_bst_report.h"
+#include "configure_bst_thresholds.h"
+#include "clear_bst_statistics.h"
+#include "clear_bst_thresholds.h"
+
+#include "bst.h"
+
+#include "bst_json_memory.h"
+#include "bst_json_encoder.h"
+#include "bst_app.h"
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-feature" REST API.
+ *
+ * @param[in]   asicId      ASIC for which this data is being encoded.
+ * @param[in]   method      Method ID (from original request) that needs 
+ *                          to be encoded in JSON.
+ * @param[in]   pData       Data structure holding the required parameters.
+ * @param[out]  pJsonBuffer Filled-in JSON buffer
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  Data is encoded into JSON successfully
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE  Internal Error
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+ * @retval   BVIEW_STATUS_OUTOFMEMORY  No available memory to create JSON buffer
+ *
+ * @note     The returned json-encoded-buffer should be freed using the  
+ *           bstjson_memory_free(). Failing to do so leads to memory leaks
+ *********************************************************************/
+BVIEW_STATUS bstjson_encode_get_bst_feature( int asicId,
+                                            int method,
+                                            const BSTJSON_CONFIGURE_BST_FEATURE_t *pData,
+                                            uint8_t **pJsonBuffer
+                                            )
+{
+    char *getBstFeatureTemplate = " {\
+\"jsonrpc\": \"2.0\",\
+\"method\": \"get-bst-feature\",\
+\"asic-id\": \"%s\",\
+\"version\": \"%d\",\
+\"result\": {\
+\"bst-enable\": %d,\
+\"send-async-reports\": %d,\
+\"collection-interval\": %d,\
+\"stat-units-in-cells\": %d,\
+\"trigger-rate-limit\": %d,\
+\"send-snapshot-on-trigger\": %d,\
+\"trigger-rate-limit-interval\": %d,\
+\"async-full-reports\": %d,\
+\"stats-in-percentage\": %d\
+},\
+\"id\": %d\
+}";
+
+    char *jsonBuf;
+    char asicIdStr[JSON_MAX_NODE_LENGTH] = { 0 };
+    BVIEW_STATUS status;
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Request for Get-Bst-Feature \n");
+
+    /* Validate Input Parameters */
+    _JSONENCODE_ASSERT (pData != NULL);
+
+    /* allocate memory for JSON */
+    status = bstjson_memory_allocate(BSTJSON_MEMSIZE_RESPONSE, (uint8_t **) & jsonBuf);
+    _JSONENCODE_ASSERT (status == BVIEW_STATUS_SUCCESS);
+
+    /* clear the buffer */
+    memset(jsonBuf, 0, BSTJSON_MEMSIZE_RESPONSE);
+
+    /* convert asicId to external  notation */
+    JSON_ASIC_ID_MAP_TO_NOTATION(asicId, &asicIdStr[0]);
+
+    /* encode the JSON */
+    snprintf(jsonBuf, BSTJSON_MEMSIZE_RESPONSE, getBstFeatureTemplate,
+             &asicIdStr[0], BVIEW_JSON_VERSION, pData->bstEnable,
+             pData->sendAsyncReports, pData->collectionInterval,
+             pData->statUnitsInCells, 
+             pData->bstMaxTriggers, pData->sendSnapshotOnTrigger,
+             pData->triggerTransmitInterval, (pData->sendIncrementalReport == 0)?1:0, 
+             pData->statsInPercentage, method);
+
+    /* setup the return value */
+    *pJsonBuffer = (uint8_t *) jsonBuf;
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Encoding complete [%d bytes] \n", (int)strlen(jsonBuf));
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_DUMPJSON, "BST-JSON-Encoder : %s \n", jsonBuf);
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the
+ *         "get-switch-properties" REST API.
+ *
+ * @param[in]   asicId      ASIC for which this data is being encoded.
+ * @param[in]   method      Method ID (from original request) that needs
+ *                          to be encoded in JSON.
+ * @param[in]   pData       Data structure holding the required parameters.
+ * @param[out]  pJsonBuffer Filled-in JSON buffer
+ *
+ * @retval   BVIEW_STATUS_SUCCESS  Data is encoded into JSON successfully
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE  Internal Error
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+ * @retval   BVIEW_STATUS_OUTOFMEMORY  No available memory to create JSON buffer
+ *
+ * @note     The returned json-encoded-buffer should be freed using the
+ *           bstjson_memory_free(). Failing to do so leads to memory leaks
+ *********************************************************************/
+BVIEW_STATUS bstjson_encode_get_switch_properties ( int asicId,
+                                            int method,
+                                            BVIEW_SWITCH_PROPERTIES_t *pData,
+                                            uint8_t **pJsonBuffer
+                                            )
+{
+    char *getSwitchPropTemplate = "{\
+\"jsonrpc\": \"2.0\",\
+\"method\": \"get-switch-properties\",\
+\"version\": \"%d\",\
+\"result\": {\"number-of-asics\": %d,\
+\"asic-info\":[%s],\
+\"supported-features\":[%s],\
+\"network-os\":\"%s\"},\
+\"id\":%d }";
+
+   char *asicInfoTemplate = "[\"%s\", \"%s\", %d],";
+   char *featureTemplate = "\"%s\"";
+   char *jsonBuf;
+   BVIEW_STATUS status;
+   char asicInfoStr[JSON_MAX_NODE_LENGTH]={0}; 
+   char featureStr[JSON_MAX_NODE_LENGTH]={0}; 
+   int asic =0;
+   int len = 0;
+   int totalLen = 0;
+
+   _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Request for Get-Switch-Properties \n");
+
+    /* Validate Input Parameters */
+   _JSONENCODE_ASSERT (pData != NULL);
+
+    /* allocate memory for JSON */
+   status = bstjson_memory_allocate(BSTJSON_MEMSIZE_RESPONSE, (uint8_t **) & jsonBuf);
+   _JSONENCODE_ASSERT (status == BVIEW_STATUS_SUCCESS);
+
+   /* clear the buffer */
+   memset(jsonBuf, 0, BSTJSON_MEMSIZE_RESPONSE);
+   
+   for (asic = 0; asic < pData->numAsics ; asic++)
+   {
+     len  = snprintf (&asicInfoStr[totalLen],JSON_MAX_NODE_LENGTH,asicInfoTemplate, 
+            pData->asicInfo[asic].asic_notation, 
+            (pData->asicInfo[asic].asicType == BVIEW_ASIC_TYPE_TD2) ? "BCM56850" : "BCM56960", 
+            pData->asicInfo[asic].numPorts);
+     totalLen += len;
+   }
+   /* Remove comma after last element */
+   asicInfoStr[totalLen -1] = '\0';
+   
+   len = 0;
+   totalLen = 0;
+   if (pData->featureMask & BVIEW_FEATURE_BST)
+   {
+     len = snprintf (&featureStr[totalLen], JSON_MAX_NODE_LENGTH,featureTemplate, "BST");
+     totalLen += len;
+   }
+   if (pData->featureMask & BVIEW_FEATURE_PACKET_TRACE)
+   {
+     len =  snprintf (&featureStr[totalLen], JSON_MAX_NODE_LENGTH, "%s", ",");
+     totalLen += len;
+     len  = snprintf (&featureStr[totalLen], JSON_MAX_NODE_LENGTH, featureTemplate, "PT");
+   } 
+   
+   /* encode the JSON */
+   snprintf(jsonBuf, BSTJSON_MEMSIZE_RESPONSE, getSwitchPropTemplate,
+            BVIEW_JSON_VERSION, pData->numAsics, asicInfoStr, featureStr, pData->networkOs,
+            method);            
+
+    /* setup the return value */
+   *pJsonBuffer = (uint8_t *) jsonBuf;
+
+   _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Encoding complete [%d bytes] \n", (int)strlen(jsonBuf));
+
+   _JSONENCODE_LOG(_JSONENCODE_DEBUG_DUMPJSON, "BST-JSON-Encoder : %s \n", jsonBuf);
+
+   return BVIEW_STATUS_SUCCESS;
+}
+
+   
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-tracking" REST API.
+ *
+ * @param[in]   asicId      ASIC for which this data is being encoded.
+ * @param[in]   method      Method ID (from original request) that needs 
+ *                          to be encoded in JSON.
+ * @param[in]   pData       Data structure holding the required parameters.
+ * @param[out]  pJsonBuffer Filled-in JSON buffer
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  Data is encoded into JSON successfully
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE  Internal Error
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+ * @retval   BVIEW_STATUS_OUTOFMEMORY  No available memory to create JSON buffer
+ *
+ * @note     The returned json-encoded-buffer should be freed using the  
+ *           bstjson_memory_free(). Failing to do so leads to memory leaks
+ *********************************************************************/
+
+BVIEW_STATUS bstjson_encode_get_bst_tracking( int asicId,
+                                             int method,
+                                             const BSTJSON_CONFIGURE_BST_TRACKING_t *pData,
+                                             uint8_t **pJsonBuffer
+                                             )
+{
+    char *getBstTrackingTemplate = " {\
+\"jsonrpc\": \"2.0\",\
+\"method\": \"get-bst-tracking\",\
+\"asic-id\": \"%s\",\
+\"version\": \"%d\",\
+\"result\": {\
+\"track-peak-stats\" : %d, \
+\"track-ingress-port-priority-group\" : %d, \
+\"track-ingress-port-service-pool\" : %d, \
+\"track-ingress-service-pool\" : %d, \
+\"track-egress-port-service-pool\" : %d, \
+\"track-egress-service-pool\" : %d, \
+\"track-egress-uc-queue\" : %d, \
+\"track-egress-uc-queue-group\" : %d, \
+\"track-egress-mc-queue\" : %d, \
+\"track-egress-cpu-queue\" : %d, \
+\"track-egress-rqe-queue\" : %d, \
+\"track-device\" : %d \
+},\
+\"id\": %d\
+}";
+
+    char *jsonBuf;
+    BVIEW_STATUS status;
+    char asicIdStr[JSON_MAX_NODE_LENGTH] = { 0 };
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Request for Get-Bst-Tracking \n");
+
+    /* Validate Input Parameters */
+    _JSONENCODE_ASSERT (pData != NULL);
+
+    /* allocate memory for JSON */
+    status = bstjson_memory_allocate(BSTJSON_MEMSIZE_RESPONSE, (uint8_t **) & jsonBuf);
+    _JSONENCODE_ASSERT (status == BVIEW_STATUS_SUCCESS);
+
+    /* clear the buffer */
+    memset(jsonBuf, 0, BSTJSON_MEMSIZE_RESPONSE);
+
+    /* convert asicId to external  notation */
+    JSON_ASIC_ID_MAP_TO_NOTATION(asicId, &asicIdStr[0]);
+
+    /* encode the JSON */
+    snprintf(jsonBuf, BSTJSON_MEMSIZE_RESPONSE, getBstTrackingTemplate,
+             &asicIdStr[0], BVIEW_JSON_VERSION, pData->trackPeakStats,
+             pData->trackIngressPortPriorityGroup,
+             pData->trackIngressPortServicePool,
+             pData->trackIngressServicePool,
+             pData->trackEgressPortServicePool,
+             pData->trackEgressServicePool,
+             pData->trackEgressUcQueue,
+             pData->trackEgressUcQueueGroup,
+             pData->trackEgressMcQueue,
+             pData->trackEgressCpuQueue,
+             pData->trackEgressRqeQueue,
+             pData->trackDevice, method);
+
+    /* setup the return value */
+    *pJsonBuffer = (uint8_t *) jsonBuf;
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Encoding complete [%d bytes] \n", (int)strlen(jsonBuf));
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_DUMPJSON, "BST-JSON-Encoder : %s \n", jsonBuf);
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - device part.
+ *
+ *********************************************************************/
+
+static BVIEW_STATUS _jsonencode_report_device ( char *jsonBuf,
+                                               const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                               const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                               const BSTJSON_REPORT_OPTIONS_t *options,
+                                               const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                               int bufLen,
+                                               int *length)
+{
+
+  char *getBstDeviceReportTemplate = "{ \"realm\" : \"device\", \"data\" : % " PRIu64 "}";
+  /* Since this is an internal function, with all parameters validated already, 
+   * we jump to the logic straight-away 
+   */
+  uint64_t data;
+  *length = 0;
+  uint64_t defaultVal = 0;
+
+  _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding device data \n");
+
+  /* if collector is not interested in device stats, ignore it*/
+  if (options->includeDevice == false)
+  {
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Device data not needed \n");
+    return BVIEW_STATUS_SUCCESS;
+  }
+
+  /* if there is no change in stats since we reported last time, ignore it*/
+  if  ((previous != NULL) && (current->device.bufferCount == previous->device.bufferCount))
+  {
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Device data %" PRIu64 " has not changed since last reading \n",
+        current->device.bufferCount);
+    return BVIEW_STATUS_SUCCESS;
+  }
+  /* data to be sent to collector */
+  data = current->device.bufferCount;
+  defaultVal = options->bst_defaults_ptr->device.bufferCount;
+
+  bst_json_convert_data(options, asic, &data, defaultVal);
+
+  /* encode the JSON */
+  *length = snprintf(jsonBuf, bufLen, getBstDeviceReportTemplate, data);
+  _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding device data [%d] complete \n", *length);
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+static BVIEW_STATUS bstjson_realm_to_indices_get(char *realm, char *index1, char *index2)
+{
+  static BSTJSON_REALM_INDEX_t bst_realm_indices_map [] = {
+    {"device" ,NULL, NULL},
+    {"ingress-service-pool", "service-pool", NULL},
+    {"ingress-port-service-pool", "port", "service-pool" },
+    {"ingress-port-priority-group", "port", "priority-group"},
+    {"egress-port-service-pool", "port", "service-pool"},
+    {"egress-service-pool", "service-pool", NULL},
+    {"egress-uc-queue", "queue", NULL},
+    {"egress-uc-queue-group", "queue-group", NULL},
+    {"egress-mc-queue", "queue", NULL},
+    {"egress-cpu-queue", "queue", NULL},
+    {"egress-rqe-queue", "queue", NULL}
+  };
+
+  unsigned int i;
+
+  if ((NULL == realm)||
+      (NULL == index1) ||
+      (NULL == index2))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  for (i = 0; i < 11; i++)
+  {
+    if (0 == strcmp(realm, bst_realm_indices_map[i].realm))
+    {
+      if (NULL != bst_realm_indices_map[i].index1)
+      {
+        strncpy(index1, bst_realm_indices_map[i].index1, strlen(bst_realm_indices_map[i].index1));
+      }
+
+      if (NULL != bst_realm_indices_map[i].index2)
+      {
+        strncpy(index2, bst_realm_indices_map[i].index2, strlen(bst_realm_indices_map[i].index2));
+      }
+
+      return BVIEW_STATUS_SUCCESS;
+    }
+  }
+
+  return BVIEW_STATUS_FAILURE;
+
+}
+
+BVIEW_STATUS bstjson_encode_trigger_realm_index_info(char *buffer, int asicId,
+                                                     int bufLen,int *length,
+                                                     char *index, int port, int queue)
+{
+  char portStr[JSON_MAX_NODE_LENGTH] = { 0 };
+
+  char * portTemplate = "\"port\" : \"%s\",";
+  char * indexTemplate = "\"%s\" : %d,";
+
+  if (index != NULL)
+  {
+    if (0 == strcmp("port", index))
+    {
+      /* convert the port to an external representation */
+      memset(&portStr[0], 0, JSON_MAX_NODE_LENGTH);
+      JSON_PORT_MAP_TO_NOTATION(port, asicId, &portStr[0]);
+       *length = snprintf(buffer, bufLen, portTemplate, &portStr[0]);
+    }
+    else
+    {
+       *length = snprintf(buffer, bufLen, indexTemplate, index, queue);
+    }
+    return BVIEW_STATUS_SUCCESS;
+  }
+    return BVIEW_STATUS_FAILURE;
+
+}
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API.
+ *
+ * @param[in]   asicId      ASIC for which this data is being encoded.
+ * @param[in]   method      Method ID (from original request) that needs 
+ *                          to be encoded in JSON.
+ * @param[in]   pData       Data structure holding the required parameters.
+ * @param[out]  pJsonBuffer Filled-in JSON buffer
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  Data is encoded into JSON successfully
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE  Internal Error
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+ * @retval   BVIEW_STATUS_OUTOFMEMORY  No available memory to create JSON buffer
+ *
+ * @note     The returned json-encoded-buffer should be freed using the  
+ *           bstjson_memory_free(). Failing to do so leads to memory leaks
+ *********************************************************************/
+
+BVIEW_STATUS bstjson_encode_get_bst_report ( int asicId,
+                                            int method,
+                                            const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                            const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                            const BSTJSON_REPORT_OPTIONS_t *options,
+                                            const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                            const BVIEW_TIME_t *time,
+                                            uint8_t **pJsonBuffer
+                                            )
+{
+    char *jsonBuf, *start;
+    BVIEW_STATUS status;
+    int bufferLength = BSTJSON_MEMSIZE_REPORT;
+    int tempLength = 0;
+
+    time_t report_time;
+    struct tm *timeinfo;
+    char timeString[64];
+    char asicIdStr[JSON_MAX_NODE_LENGTH] = { 0 };
+    char index1[256];
+    char index2[256];
+
+
+
+    char *getBstReportStart = " { \
+\"jsonrpc\": \"2.0\",\
+\"method\": \"%s\",\
+\"asic-id\": \"%s\",\
+\"version\": \"%d\",\
+\"time-stamp\": \"%s\",\
+\"report\": [ \
+";
+
+    char *getBstTriggerReportStart = " { \
+\"jsonrpc\": \"2.0\",\
+\"method\": \"%s\",\
+\"asic-id\": \"%s\",\
+\"version\": \"%d\",\
+\"time-stamp\": \"%s\",\
+\"realm\": \"%s\",\
+\"counter\": \"%s\",\
+";
+
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Request for Get-Bst-Report \n");
+
+    /* Validate Input Parameters */
+    _JSONENCODE_ASSERT (options != NULL);
+    _JSONENCODE_ASSERT (current != NULL);
+    _JSONENCODE_ASSERT (time != NULL);
+    _JSONENCODE_ASSERT (asic != NULL);
+
+    /* obtain the time */
+    memset(&timeString, 0, sizeof (timeString));
+    report_time = *(time_t *) time;
+    timeinfo = localtime(&report_time);
+    strftime(timeString, 64, "%Y-%m-%d - %H:%M:%S ", timeinfo);
+
+    /* allocate memory for JSON */
+    status = bstjson_memory_allocate(BSTJSON_MEMSIZE_REPORT, (uint8_t **) & jsonBuf);
+    _JSONENCODE_ASSERT (status == BVIEW_STATUS_SUCCESS);
+
+    start = jsonBuf;
+
+    /* clear the buffer */
+    memset(jsonBuf, 0, BSTJSON_MEMSIZE_REPORT);
+
+    /* convert asicId to external  notation */
+    JSON_ASIC_ID_MAP_TO_NOTATION(asicId, &asicIdStr[0]);
+
+    /* fill the header */
+    /* encode the JSON */
+
+    if (options->reportTrigger == false)
+    {
+      tempLength = snprintf(jsonBuf, bufferLength, getBstReportStart,
+          (options->reportThreshold == true) ? "get-bst-thresholds" :"get-bst-report",
+          &asicIdStr[0], BVIEW_JSON_VERSION, timeString);
+      bufferLength -= tempLength;
+      jsonBuf += tempLength;
+    }
+    else
+    {
+      memset(index1, 0, sizeof(index1));
+      memset(index2, 0, sizeof(index2));
+      if (BVIEW_STATUS_SUCCESS != bstjson_realm_to_indices_get((char *)options->triggerInfo.realm, &index1[0], &index2[0]))
+      {
+        return BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      tempLength = snprintf(jsonBuf, bufferLength, getBstTriggerReportStart,
+          "trigger-report",
+          &asicIdStr[0], BVIEW_JSON_VERSION, timeString, options->triggerInfo.realm, options->triggerInfo.counter);
+
+      jsonBuf += tempLength;
+      bufferLength -= tempLength;
+      if (0 != index1[0])
+      {
+        status = bstjson_encode_trigger_realm_index_info(jsonBuf, asicId, bufferLength, &tempLength, &index1[0], 
+            options->triggerInfo.port, options->triggerInfo.queue);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+        bufferLength -= tempLength;
+        jsonBuf += tempLength;
+      }
+
+
+      if (0 != index2[0])
+      {
+        status = bstjson_encode_trigger_realm_index_info(jsonBuf, asicId, bufferLength, &tempLength, &index2[0], 
+            options->triggerInfo.port, options->triggerInfo.queue);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+        bufferLength -= tempLength;
+        jsonBuf += tempLength;
+      }
+
+      tempLength = snprintf(jsonBuf, bufferLength, "\"report\" : [" ); 
+      bufferLength -= tempLength;
+      jsonBuf += tempLength; 
+    }
+
+    /* get the device report */
+    status = _jsonencode_report_device(jsonBuf, previous, current, options, asic, bufferLength, &tempLength);
+    _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+    if (tempLength)
+    {
+        bufferLength -= tempLength;
+        jsonBuf += tempLength;
+
+        tempLength = snprintf(jsonBuf, bufferLength, " ,");
+
+        bufferLength -= tempLength;
+        jsonBuf += tempLength;
+    }
+
+    /* if any of the ingress encodings are required, add them to report */
+    if (options->includeIngressPortPriorityGroup ||
+        options->includeIngressPortServicePool ||
+        options->includeIngressServicePool)
+    {
+        status = _jsonencode_report_ingress(jsonBuf, asicId, previous, current, options, asic, bufferLength, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        /* adjust the buffer */
+        bufferLength -= (tempLength);
+        jsonBuf += (tempLength);
+
+    }
+
+    /* if any of the egress encodings are required, add them to report */
+    if (options->includeEgressCpuQueue ||
+        options->includeEgressMcQueue ||
+        options->includeEgressPortServicePool ||
+        options->includeEgressRqeQueue ||
+        options->includeEgressServicePool ||
+        options->includeEgressUcQueue ||
+        options->includeEgressUcQueueGroup )
+    {
+        status = _jsonencode_report_egress(jsonBuf, asicId, previous, current, options, asic, bufferLength, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        /* adjust the buffer */
+        bufferLength -= (tempLength);
+        jsonBuf += (tempLength);
+
+    }
+
+    /* finalizing the report */
+
+    bufferLength -= 1;
+    jsonBuf -= 1;
+
+    if (jsonBuf[0] == 0)
+    {
+        bufferLength -= 1;
+        jsonBuf--;
+    }
+
+    tempLength = snprintf(jsonBuf, bufferLength, " ] } ");
+
+    *pJsonBuffer = (uint8_t *) start;
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : Request for Get-Bst-Report Complete [%d] bytes \n", (int)strlen(start));
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_DUMPJSON, "BST-JSON-Encoder : %s \n", start);
+
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+uint64_t round_int( double r ) {
+      return (r > 0.0) ? (r + 0.5) : (r - 0.5); 
+}
+/******************************************************************* 
+   Utility function to convert the data based on config 
+********************************************************************/
+BVIEW_STATUS bst_json_convert_data(const BSTJSON_REPORT_OPTIONS_t *options,
+                                          const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                          uint64_t *value, uint64_t defVal)
+{
+  double percentage =0;
+  uint64_t data = 0;
+
+  if ((NULL == options) ||
+      (NULL == asic) ||
+      (NULL == value))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  data = *value;
+
+
+  /* Report is threshold. */
+  if (true == options->reportThreshold)
+  {
+    if (true == options->statUnitsInCells)
+    {
+      /* threshold comes in bytes from asic */
+      data = data / (asic->cellToByteConv);
+    }
+  }
+  else
+  {
+    /* report is stats */
+    if (true == options->statsInPercentage)
+    {
+      if (0 == defVal)
+      {
+        data = 0;
+      }
+      else
+      {
+        /* we just need the percentage of the configured value */
+        percentage = ((double)(data * 100))/((double)(defVal));
+        data = round_int(percentage);
+      }
+    }
+    else
+    {
+      /* conversion to bytes or cells based on config */
+      if (false == options->statUnitsInCells)
+      {
+     /* check if we need to convert the data to cells
+        the report always comes in cells from asic */
+       data = data * (asic->cellToByteConv);
+      }
+    }
+  }
+
+  *value = data;
+
+  return BVIEW_STATUS_SUCCESS;
+}
diff --git a/src/apps/bst/api/bst_json_encoder.h b/src/apps/bst/api/bst_json_encoder.h
new file mode 100755
index 0000000..66beb7a
--- /dev/null
+++ b/src/apps/bst/api/bst_json_encoder.h
@@ -0,0 +1,171 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_BSTJSONENCODER_H
+#define INCLUDE_BSTJSONENCODER_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "json.h"
+
+#include "bst.h"
+
+/* reporting options */
+typedef struct _bst_reporting_options_
+{
+    bool includeIngressPortPriorityGroup;
+    bool includeIngressPortServicePool;
+    bool includeIngressServicePool;
+    bool includeEgressPortServicePool;
+    bool includeEgressServicePool;
+    bool includeEgressUcQueue;
+    bool includeEgressUcQueueGroup;
+    bool includeEgressMcQueue;
+    bool includeEgressCpuQueue;
+    bool includeEgressRqeQueue;
+    bool includeDevice;
+    bool statUnitsInCells;
+    bool reportTrigger;
+    bool reportThreshold;
+    bool sendSnapShotOnTrigger;
+    BVIEW_BST_TRIGGER_INFO_t triggerInfo;
+    bool sendIncrementalReport;
+    bool statsInPercentage;
+    BVIEW_BST_ASIC_SNAPSHOT_DATA_t *bst_defaults_ptr;
+} BSTJSON_REPORT_OPTIONS_t;
+
+/* structure to map the realms and indices */
+
+typedef struct _bst_realm_index_ {
+  char *realm;
+  char *index1;
+  char *index2;
+}BSTJSON_REALM_INDEX_t;
+
+#define _JSONENCODE_DEBUG
+#define _JSONENCODE_DEBUG_LEVEL         _JSONENCODE_DEBUG_ERROR
+
+#define _JSONENCODE_DEBUG_TRACE        (0x1)
+#define _JSONENCODE_DEBUG_INFO         (0x01 << 1)
+#define _JSONENCODE_DEBUG_ERROR        (0x01 << 2)
+#define _JSONENCODE_DEBUG_DUMPJSON     (0x01 << 3)
+#define _JSONENCODE_DEBUG_ALL          (0xFF)
+
+#ifdef _JSONENCODE_DEBUG
+#define _JSONENCODE_LOG(level, format,args...)   do { \
+            if ((level) & _JSONENCODE_DEBUG_LEVEL) { \
+                printf(format, ##args); \
+            } \
+        }while(0)
+#else 
+#define _JSONENCODE_LOG(level, format,args...)
+#endif
+
+/* Utility Macros for parameter validation */
+#define _JSONENCODE_ASSERT_ERROR(condition, errcode) do { \
+    if (!(condition)) { \
+        _JSONENCODE_LOG(_JSONENCODE_DEBUG_ERROR, \
+                    "BST JSON Encoder (%s:%d) Invalid Input Parameter  \n", \
+                    __func__, __LINE__); \
+        return (errcode); \
+    } \
+} while(0)
+
+#define _JSONENCODE_ASSERT(condition) _JSONENCODE_ASSERT_ERROR((condition), (BVIEW_STATUS_INVALID_PARAMETER))
+
+#define _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actLen, dst, len, lenptr, format, args...) \
+    do { \
+        int xtemp = *(lenptr); \
+        (actLen) = snprintf((dst), (len), format, ##args); \
+        *(lenptr) = (xtemp) + (actLen); \
+        if ( (len) == (actLen)) { \
+            /* Out of buffer here */ \
+            _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (%s:%d) Out of Json memory while encoding \n", __func__, __LINE__); \
+            return BVIEW_STATUS_OUTOFMEMORY; \
+        } \
+        (dst) += (actLen); \
+        (len) -= (actLen); \
+    } while(0)
+
+/* Prototypes */
+
+BVIEW_STATUS bstjson_encode_get_bst_feature(int asicId,
+                                            int method,
+                                            const BSTJSON_CONFIGURE_BST_FEATURE_t *pData,
+                                            uint8_t **pJsonBuffer
+                                            );
+
+BVIEW_STATUS bstjson_encode_get_switch_properties ( int asicId,
+                                            int method,
+                                            BVIEW_SWITCH_PROPERTIES_t *pData,
+                                            uint8_t **pJsonBuffer
+                                            );
+
+BVIEW_STATUS bstjson_encode_get_bst_tracking(int asicId,
+                                             int method,
+                                             const BSTJSON_CONFIGURE_BST_TRACKING_t *pData,
+                                             uint8_t **pJsonBuffer
+                                             );
+
+BVIEW_STATUS bstjson_encode_get_bst_report(int asicId,
+                                           int method,
+                                           const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                           const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                           const BSTJSON_REPORT_OPTIONS_t *options,
+                                           const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                           const BVIEW_TIME_t *reportTime,
+                                           uint8_t **pJsonBuffer
+                                           );
+
+BVIEW_STATUS _jsonencode_report_ingress(char *buffer,
+                                        int asicId,
+                                        const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                        const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                        const BSTJSON_REPORT_OPTIONS_t *options,
+                                        const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                        int bufLen,
+                                        int *length
+                                        );
+
+BVIEW_STATUS _jsonencode_report_egress(char *buffer,
+                                       int asicId,
+                                       const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                       const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                       const BSTJSON_REPORT_OPTIONS_t *options,
+                                       const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                       int bufLen,
+                                       int *length
+                                       );
+
+/******************************************************************* 
+   Utility function to convert the data based on config 
+********************************************************************/
+BVIEW_STATUS bst_json_convert_data(const BSTJSON_REPORT_OPTIONS_t *options,
+                                          const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                          uint64_t *value, uint64_t defVal);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_BSTJSONENCODER_H */
diff --git a/src/apps/bst/api/bst_json_encoder_egress.c b/src/apps/bst/api/bst_json_encoder_egress.c
new file mode 100755
index 0000000..d8a819a
--- /dev/null
+++ b/src/apps/bst/api/bst_json_encoder_egress.c
@@ -0,0 +1,822 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <inttypes.h>
+
+#include "broadview.h"
+
+#include "cJSON.h"
+
+#include "configure_bst_feature.h"
+#include "configure_bst_tracking.h"
+
+#include "bst.h"
+
+#include "bst_json_memory.h"
+#include "bst_json_encoder.h"
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress CPU Queue.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_egress_cpuq ( char *buffer, int asicId,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                    const BSTJSON_REPORT_OPTIONS_t *options,
+                                                    const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                    int bufLen,
+                                                    int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    int queue = 0;
+    uint64_t val = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    char *realmTemplate = " { \"realm\": \"egress-cpu-queue\", \"%s\": [ ";
+    char *cpuqTemplate = " [  %d , %" PRIu64 ", %" PRIu64 " ] ,";
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - CPU Queue data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, realmTemplate, "data");
+
+    /* For each queue, check if there is a difference, and create the report. */
+    for (queue = 1; queue <= asic->numCpuQueues; queue++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((queue-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+        /* lets see if this queue needs to be included in the report at all */
+        /* if this queue needs not be reported, then we move to next queue */
+      if (true == sendIncrReport)
+      {
+        if ((NULL == previous) &&
+            (current->cpqQ.data[queue - 1].cpuBufferCount == 0) &&
+            (current->cpqQ.data[queue - 1].cpuQueueEntries == 0))
+            continue;
+      }
+
+        if ((previous != NULL) &&
+            (previous->cpqQ.data[queue - 1].cpuBufferCount == current->cpqQ.data[queue - 1].cpuBufferCount) &&
+            (previous->cpqQ.data[queue - 1].cpuQueueEntries == current->cpqQ.data[queue - 1].cpuQueueEntries))
+            continue;
+
+             val = current->cpqQ.data[queue - 1].cpuBufferCount;
+             defaultVal = options->bst_defaults_ptr->cpqQ.data[queue - 1].cpuBufferCount;
+             bst_json_convert_data(options, asic, &val, defaultVal);
+        /* Now that this queue needs to be included in the report, add the data to report */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      cpuqTemplate, queue-1,
+                                                      val,
+                                                      current->cpqQ.data[queue - 1].cpuQueueEntries
+                                                      );
+
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - CPU Queue data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress RQE Queue.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_egress_rqeq ( char *buffer, int asicId,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                    const BSTJSON_REPORT_OPTIONS_t *options,
+                                                    const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                    int bufLen,
+                                                    int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    int queue = 0;
+    uint64_t val = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    char *realmTemplate = " { \"realm\": \"egress-rqe-queue\", \"%s\": [ ";
+    char *cpuqTemplate = " [  %d , %" PRIu64 ", %" PRIu64 " ] ,";
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - RQE Queue data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, realmTemplate, "data");
+
+    /* For each queue, check if there is a difference, and create the report. */
+    for (queue = 1; queue <= asic->numRqeQueues; queue++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((queue-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+      if (true == sendIncrReport)
+       {
+        /* lets see if this queue needs to be included in the report at all */
+        /* if this queue needs not be reported, then we move to next queue */
+        if ((NULL == previous) &&
+            (current->rqeQ.data[queue - 1].rqeBufferCount == 0) &&
+            (current->rqeQ.data[queue - 1].rqeQueueEntries == 0))
+            continue;
+      }
+
+        if ((previous != NULL) &&
+            (previous->rqeQ.data[queue - 1].rqeBufferCount == current->rqeQ.data[queue - 1].rqeBufferCount) &&
+            (previous->rqeQ.data[queue - 1].rqeQueueEntries == current->rqeQ.data[queue - 1].rqeQueueEntries))
+            continue;
+
+             val = current->rqeQ.data[queue - 1].rqeBufferCount;
+             defaultVal = options->bst_defaults_ptr->rqeQ.data[queue - 1].rqeBufferCount;
+             bst_json_convert_data(options, asic, &val, defaultVal);
+        /* Now that this queue needs to be included in the report, add the data to report */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      cpuqTemplate, queue-1,
+                                                      val,
+                                                      current->rqeQ.data[queue - 1].rqeQueueEntries
+                                                      );
+
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - RQE Queue data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress Multicast Queue.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_egress_mcq ( char *buffer, int asicId,
+                                                   const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                   const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                   const BSTJSON_REPORT_OPTIONS_t *options,
+                                                   const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                   int bufLen,
+                                                   int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    int queue = 0;
+    uint64_t val = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    char *realmTemplate = " { \"realm\": \"egress-mc-queue\", \"%s\": [ ";
+    char *dataTemplate = " [  %d , \"%s\" ,  %" PRIu64 ", %" PRIu64 " ] ,";
+    char portStr[JSON_MAX_NODE_LENGTH] = { 0 };
+
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - MC Queue data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, realmTemplate, "data");
+
+    /* For each service pool, check if there is a difference, and create the report. */
+    for (queue = 1; queue <= asic->numMulticastQueues; queue++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((queue-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+
+      if (true == sendIncrReport)
+      {
+        /* lets see if this queue needs to be included in the report at all */
+        /* if this queue needs not be reported, then we move to next queue */
+        if ((NULL == previous) &&
+            (current->eMcQ.data[queue - 1].mcBufferCount == 0) &&
+            (current->eMcQ.data[queue - 1].mcQueueEntries == 0) )
+            continue;
+      }
+        if ((previous != NULL) &&
+            (previous->eMcQ.data[queue - 1].mcBufferCount == current->eMcQ.data[queue - 1].mcBufferCount ) &&
+            (previous->eMcQ.data[queue - 1].mcQueueEntries == current->eMcQ.data[queue - 1].mcQueueEntries))
+            continue;
+
+        /* convert the port to an external representation */
+        memset(&portStr[0], 0, JSON_MAX_NODE_LENGTH);
+        JSON_PORT_MAP_TO_NOTATION(current->eMcQ.data[queue - 1].port, asicId, &portStr[0]);
+
+        val = current->eMcQ.data[queue - 1].mcBufferCount;
+        defaultVal = options->bst_defaults_ptr->eMcQ.data[queue - 1].mcBufferCount;
+        bst_json_convert_data(options, asic, &val, defaultVal);
+
+        /* Now that this pool needs to be included in the report, add the data to report */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      dataTemplate, queue-1,
+                                                      &portStr[0],
+                                                      val,
+                                                      current->eMcQ.data[queue - 1].mcQueueEntries
+                                                      );
+
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - MC Queue data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress UC Queue.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_egress_ucq ( char *buffer, int asicId,
+                                                   const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                   const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                   const BSTJSON_REPORT_OPTIONS_t *options,
+                                                   const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                   int bufLen,
+                                                   int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    int queue = 0;
+    uint64_t val = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    char *realmTemplate = " { \"realm\": \"egress-uc-queue\", \"%s\": [ ";
+    char *dataTemplate = " [  %d , \"%s\" , %" PRIu64 " ] ,";
+    char portStr[JSON_MAX_NODE_LENGTH] = { 0 };
+
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - UC Queue data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, realmTemplate, "data");
+
+    /* For each unicast queues, check if there is a difference, and create the report. */
+    for (queue = 1; queue <= asic->numUnicastQueues; queue++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((queue-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+
+
+      if (true == sendIncrReport)
+      {
+        /* lets see if this queue needs to be included in the report at all */
+        /* if this queue needs not be reported, then we move to next queue */
+        if ((NULL == previous) &&
+            (current->eUcQ.data[queue - 1].ucBufferCount == 0))
+            continue;
+      }
+        if ((previous != NULL) &&
+            (previous->eUcQ.data[queue - 1].ucBufferCount == current->eUcQ.data[queue - 1].ucBufferCount))
+            continue;
+
+        /* convert the port to an external representation */
+        memset(&portStr[0], 0, JSON_MAX_NODE_LENGTH);
+        JSON_PORT_MAP_TO_NOTATION(current->eUcQ.data[queue - 1].port, asicId, &portStr[0]);
+
+         val = current->eUcQ.data[queue - 1].ucBufferCount;
+         defaultVal = options->bst_defaults_ptr->eUcQ.data[queue - 1].ucBufferCount;
+         bst_json_convert_data(options, asic, &val, defaultVal);
+        /* Now that this ucq needs to be included in the report, add the data to report */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      dataTemplate, queue-1,
+                                                      &portStr[0],
+                                                      val 
+                                                      );
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - UC Queue data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress UC Queue Group.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_egress_ucqg ( char *buffer, int asicId,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                    const BSTJSON_REPORT_OPTIONS_t *options,
+                                                    const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                    int bufLen,
+                                                    int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    int qg = 0;
+    uint64_t val = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    char *realmTemplate = " { \"realm\": \"egress-uc-queue-group\", \"%s\": [ ";
+    char *dataTemplate = " [  %d , %" PRIu64 " ] ,";
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - UC Queue Group data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, realmTemplate, "data");
+
+    /* For each unicast queue groups, check if there is a difference, and create the report. */
+    for (qg = 1; qg <= asic->numUnicastQueueGroups; qg++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((qg-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+
+
+      if (true == sendIncrReport)
+      {
+        /* lets see if this queue needs to be included in the report at all */
+        /* if this queue needs not be reported, then we move to next queue */
+        if ((NULL == previous) &&
+            (current->eUcQg.data[qg - 1].ucBufferCount == 0))
+            continue;
+     }
+        if ((previous != NULL) &&
+            (previous->eUcQg.data[qg - 1].ucBufferCount == current->eUcQg.data[qg - 1].ucBufferCount))
+            continue;
+
+              val = current->eUcQg.data[qg - 1].ucBufferCount;
+              defaultVal = options->bst_defaults_ptr->eUcQg.data[qg - 1].ucBufferCount;
+              bst_json_convert_data(options, asic, &val, defaultVal);
+        /* Now that this ucqg needs to be included in the report, add the data to report */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      dataTemplate, qg-1,
+                                                      val 
+                                                      );
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - UC Queue Group data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress Service Pools .
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_egress_sp ( char *buffer, int asicId,
+                                                  const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                  const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                  const BSTJSON_REPORT_OPTIONS_t *options,
+                                                  const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                  int bufLen,
+                                                  int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    int pool = 0;
+    uint64_t val1 = 0, val2 = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    char *realmTemplate = " { \"realm\": \"egress-service-pool\", \"%s\": [ ";
+    char *dataTemplate = " [  %d , %" PRIu64 " , %" PRIu64 ", %" PRIu64 " ] ,";
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - Service Pool data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, realmTemplate, "data");
+
+    /* For each service pool, check if there is a difference, and create the report. */
+    for (pool = 1; pool <= asic->numServicePools; pool++)
+    {
+      if ((pool-1 != options->triggerInfo.queue) && 
+	  (false == options->sendSnapShotOnTrigger) && 
+	  (true == options->reportTrigger))
+      {
+	continue;
+      }
+
+
+      if (true == sendIncrReport)
+      {
+        /* lets see if this sp needs to be included in the report at all */
+        /* if this sp needs not be reported, then we move to next sp */
+        if ((NULL == previous) &&
+            (current->eSp.data[pool - 1].umShareBufferCount == 0) &&
+            (current->eSp.data[pool - 1].mcShareBufferCount == 0)  &&
+            (current->eSp.data[pool - 1].mcShareQueueEntries == 0) )
+            continue;
+      }
+
+        if ((previous != NULL) &&
+            (previous->eSp.data[pool - 1].umShareBufferCount == current->eSp.data[pool - 1].umShareBufferCount ) &&
+            (previous->eSp.data[pool - 1].mcShareBufferCount == current->eSp.data[pool - 1].mcShareBufferCount ) &&
+            (previous->eSp.data[pool - 1].mcShareQueueEntries == current->eSp.data[pool - 1].mcShareQueueEntries ))
+            continue;
+
+             val1 = current->eSp.data[pool - 1].umShareBufferCount;
+             defaultVal = options->bst_defaults_ptr->eSp.data[pool - 1].umShareBufferCount;
+             bst_json_convert_data(options, asic, &val1, defaultVal);
+
+             val2 = current->eSp.data[pool - 1].mcShareBufferCount;
+             defaultVal = options->bst_defaults_ptr->eSp.data[pool - 1].mcShareBufferCount;
+             bst_json_convert_data(options, asic, &val2, defaultVal);
+        /* Now that this pool needs to be included in the report, add the data to report */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      dataTemplate, pool-1, val1,val2,
+                                                      current->eSp.data[pool - 1].mcShareQueueEntries
+                                                      );
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - Service Pool data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress-port-service-pool.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_egress_epsp ( char *buffer, int asicId,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                    const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                    const BSTJSON_REPORT_OPTIONS_t *options,
+                                                    const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                    int bufLen,
+                                                    int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    bool includePort = false;
+    uint64_t val1 = 0, val2 = 0, val3 = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    int includeServicePool[BVIEW_ASIC_MAX_SERVICE_POOLS] = { 0 };
+    int port = 0, pool = 0;
+
+    char *epspTemplate = " { \"realm\": \"egress-port-service-pool\", \"%s\": [ ";
+    char *epspPortTemplate = " { \"port\": \"%s\", \"data\": [ ";
+    char *epspServicePoolTemplate = " [  %d , %" PRIu64 " , %" PRIu64 " , %" PRIu64 " ] ,";
+    char portStr[JSON_MAX_NODE_LENGTH] = { 0 };
+
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - EPSP data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, epspTemplate, "data");
+
+    /* For each port, and for each service pool in that port, 
+     *  1. attempt to see if this port needs to be reported.
+     *  2. create the report.
+     */
+    for (port = 1; port <= asic->numPorts; port++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((port-1 != options->triggerInfo.port) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+         {
+           continue;
+         }
+        includePort = false;
+        memset (&includeServicePool[0], 0, sizeof (includeServicePool));
+
+        /* lets see if this port needs to be included in the report at all */
+        for (pool = 1; pool <= asic->numServicePools; pool++)
+        {
+      /* check if the trigger report request should contain snap shot */
+        if ((pool-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+         {
+           continue;
+         }
+            /* By default, we plan to include the pool */
+            includeServicePool[pool - 1] = 1;
+
+      if (true == sendIncrReport)
+      {
+            /* If there is no traffic reported for this priority group, ignore it */
+               if ((NULL == previous) &&
+                (current->ePortSp.data[port - 1][pool - 1].umShareBufferCount == 0) &&
+                (current->ePortSp.data[port - 1][pool - 1].ucShareBufferCount == 0) &&
+                (current->ePortSp.data[port - 1][pool - 1].mcShareBufferCount == 0) &&
+                (current->ePortSp.data[port - 1][pool - 1].mcShareQueueEntries == 0))
+            {
+                includeServicePool[pool - 1] = 0;
+                continue;
+            }
+      }
+            /* If this is snapshot report, include the port in the data  */
+            if (previous == NULL)
+            {
+                includePort = true;
+                continue;
+            }
+
+            /* if there is traffic reported since the last snapshot, we can't ignore this pool */
+            if ( (previous->ePortSp.data[port - 1][pool - 1].umShareBufferCount
+                  != current->ePortSp.data[port - 1][pool - 1].umShareBufferCount) ||
+                (previous->ePortSp.data[port - 1][pool - 1].ucShareBufferCount
+                 != current->ePortSp.data[port - 1][pool - 1].ucShareBufferCount) ||
+                (previous->ePortSp.data[port - 1][pool - 1].mcShareBufferCount
+                 != current->ePortSp.data[port - 1][pool - 1].mcShareBufferCount) ||
+                (previous->ePortSp.data[port - 1][pool - 1].mcShareQueueEntries
+                 != current->ePortSp.data[port - 1][pool - 1].mcShareQueueEntries) )
+            {
+                includePort = true;
+                continue;
+            }
+
+            /* since there is no reason to include the pool, we can ignore it*/
+            includeServicePool[pool - 1] = 0;
+        }
+
+        /* if this port needs not be reported, then we move to next port */
+        if (includePort == false)
+        {
+            continue;
+        }
+
+        /* convert the port to an external representation */
+        memset(&portStr[0], 0, JSON_MAX_NODE_LENGTH);
+        JSON_PORT_MAP_TO_NOTATION(port, asicId, &portStr[0]);
+
+        /* Now that this port needs to be included in the report, copy the header */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, epspPortTemplate, &portStr[0]);
+
+        /* for each priority-group, prepare the data */
+        for (pool = 1; pool <= asic->numServicePools; pool++)
+        {
+            /* we ignore if there is no data to be reported */
+            if (includeServicePool[pool - 1] == 0)
+                continue;
+
+            val1 = current->ePortSp.data[port - 1][pool - 1].ucShareBufferCount;
+            defaultVal = options->bst_defaults_ptr->ePortSp.data[port - 1][pool - 1].ucShareBufferCount;
+            bst_json_convert_data(options, asic, &val1, defaultVal);
+
+            val2 = current->ePortSp.data[port - 1][pool - 1].umShareBufferCount;
+            defaultVal = options->bst_defaults_ptr->ePortSp.data[port - 1][pool - 1].umShareBufferCount;
+            bst_json_convert_data(options, asic, &val2, defaultVal);
+
+            val3 = current->ePortSp.data[port - 1][pool - 1].mcShareBufferCount;
+            defaultVal = options->bst_defaults_ptr->ePortSp.data[port - 1][pool - 1].mcShareBufferCount;
+            bst_json_convert_data(options, asic, &val3, defaultVal);
+            /* add the data to the report */
+            _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                          epspServicePoolTemplate, pool-1,
+                                                          val1, val2, val3,
+                                                          current->ePortSp.data[port - 1][pool - 1].mcShareQueueEntries
+                                                          );
+        }
+
+        /* adjust the buffer to remove the last ',' */
+        buffer = buffer - 1;
+        remLength += 1;
+        *length -= 1;
+
+        /* add the "] } ," for the next port */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      "] } ," );
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS - EPSP data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - egress part.
+ *
+ *********************************************************************/
+BVIEW_STATUS _jsonencode_report_egress ( char *buffer, int asicId,
+                                        const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                        const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                        const BSTJSON_REPORT_OPTIONS_t *options,
+                                        const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                        int bufLen,
+                                        int *length)
+{
+    BVIEW_STATUS status;
+    int tempLength = 0;
+
+    *length = 0;
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS data \n");
+
+    /* If CPU realm is asked for, lets encode the corresponding data */
+
+    if (options->includeEgressCpuQueue)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_egress_cpuq(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If Egress Multicast queue realm is asked for, lets encode the corresponding data */
+    if (options->includeEgressMcQueue)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_egress_mcq(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If Egress Port - Service Pool realm is asked for, lets encode the corresponding data */
+
+    if (options->includeEgressPortServicePool)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_egress_epsp(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If Egress RQE queue realm is asked for, lets encode the corresponding data */
+    if (options->includeEgressRqeQueue)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_egress_rqeq(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If Egress Service Pool realm is asked for, lets encode the corresponding data */
+    if (options->includeEgressServicePool)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_egress_sp(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If Egress Unicast queue realm is asked for, lets encode the corresponding data */
+    if (options->includeEgressUcQueue)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_egress_ucq(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If Egress Unicast queue group realm is asked for, lets encode the corresponding data */
+    if (options->includeEgressUcQueueGroup)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_egress_ucqg(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+
+    }
+
+    if (tempLength != 0)
+    {
+        *(length) -= 1;
+    }
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding EGRESS data complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+}
diff --git a/src/apps/bst/api/bst_json_encoder_ingress.c b/src/apps/bst/api/bst_json_encoder_ingress.c
new file mode 100755
index 0000000..31e20e1
--- /dev/null
+++ b/src/apps/bst/api/bst_json_encoder_ingress.c
@@ -0,0 +1,501 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <inttypes.h>
+
+#include "broadview.h"
+
+#include "cJSON.h"
+
+#include "configure_bst_feature.h"
+#include "configure_bst_tracking.h"
+
+#include "bst.h"
+
+#include "bst_json_memory.h"
+#include "bst_json_encoder.h"
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - ingress-port-port-group.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_ingress_ippg ( char *buffer, int asicId,
+                                                     const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                     const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                     const BSTJSON_REPORT_OPTIONS_t *options,
+                                                     const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                     int bufLen,
+                                                     int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    bool includePort = false;
+    uint64_t val1 = 0;
+    uint64_t val2 = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+
+    int includePriorityGroups[BVIEW_ASIC_MAX_PRIORITY_GROUPS] = { 0 };
+    int port = 0, priGroup = 0;
+    char portStr[JSON_MAX_NODE_LENGTH] = { 0 };
+
+    char *ippgTemplate = " { \"realm\": \"ingress-port-priority-group\", \"%s\": [ ";
+    char *ippgPortTemplate = " { \"port\": \"%s\", \"data\": [ ";
+    char *ippgPortGroupTemplate = " [  %d , %" PRIu64 " , %" PRIu64 " ] ,";
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS - IPPG data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, ippgTemplate, "data");
+
+    /* For each port, and for each priority group in that port, 
+     *  1. attempt to see if this port needs to be reported.
+     *  2. create the report.
+     */
+    for (port = 1; port <= asic->numPorts; port++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((port-1 != options->triggerInfo.port) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+        includePort = false;
+        memset (&includePriorityGroups[0], 0, sizeof (includePriorityGroups));
+
+        /* lets see if this port needs to be included in the report at all */
+        for (priGroup = 1; priGroup <= asic->numPriorityGroups; priGroup++)
+        {
+      /* check if the trigger report request should contain snap shot */
+           if ((priGroup-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+           {
+             continue;
+           }
+            /* By default, we plan to include the pri-group */
+            includePriorityGroups[priGroup - 1] = 1;
+   
+            if (true == sendIncrReport)
+            {
+            /* If there is no traffic reported for this priority group, ignore it */
+            if ((previous == NULL) && 
+                (current->iPortPg.data[port - 1][priGroup - 1].umShareBufferCount == 0) &&
+                (current->iPortPg.data[port - 1][priGroup - 1].umHeadroomBufferCount == 0) )
+            {
+                includePriorityGroups[priGroup - 1] = 0;
+                continue;
+            }
+           }
+
+            /* If this is snapshot report, include the port in the data  */
+            if (previous == NULL)
+            {
+                includePort = true;
+                continue;
+            }
+
+            /* if there is traffic reported since the last snapshot, we can't ignore this priority group */
+            if (previous->iPortPg.data[port - 1][priGroup - 1].umShareBufferCount
+                != current->iPortPg.data[port - 1][priGroup - 1].umShareBufferCount)
+            {
+                includePort = true;
+                continue;
+            }
+
+            if (previous->iPortPg.data[port - 1][priGroup - 1].umHeadroomBufferCount
+                != current->iPortPg.data[port - 1][priGroup - 1].umHeadroomBufferCount)
+            {
+                includePort = true;
+                continue;
+            }
+
+            /* since there is no reason to include the group, we can ignore it*/
+            includePriorityGroups[priGroup - 1] = 0;
+        }
+
+        /* if this port needs not be reported, then we move to next port */
+        if (includePort == false)
+        {
+            continue;
+        }
+
+          /* convert the port to an external representation */
+          memset(&portStr[0], 0, JSON_MAX_NODE_LENGTH);
+          JSON_PORT_MAP_TO_NOTATION(port, asicId, &portStr[0]);
+
+          /* Now that this port needs to be included in the report, copy the header */
+          _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, ippgPortTemplate, &portStr[0]);
+
+        /* for each priority-group, prepare the data */
+        for (priGroup = 1; priGroup <= asic->numPriorityGroups; priGroup++)
+        {
+            /* we ignore if there is no data to be reported */
+            if (includePriorityGroups[priGroup - 1] == 0)
+                continue;
+
+            val1 = current->iPortPg.data[port - 1][priGroup - 1].umShareBufferCount;
+            defaultVal = options->bst_defaults_ptr->iPortPg.data[port - 1][priGroup - 1].umShareBufferCount;
+            bst_json_convert_data(options, asic, &val1, defaultVal);
+
+            val2 = current->iPortPg.data[port - 1][priGroup - 1].umHeadroomBufferCount;
+            defaultVal = options->bst_defaults_ptr->iPortPg.data[port - 1][priGroup - 1].umHeadroomBufferCount;
+            bst_json_convert_data(options, asic, &val2, defaultVal);
+
+            /* add the data to the report */
+            _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                          ippgPortGroupTemplate, priGroup-1, val1, val2);
+        }
+
+          /* adjust the buffer to remove the last ',' */
+          buffer = buffer - 1;
+          remLength += 1;
+          *length -= 1;
+
+        /* add the "] } ," for the next port */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      "] } ," );
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS - IPPG data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - ingress-port-service-pool.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_ingress_ipsp ( char *buffer, int asicId,
+                                                     const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                     const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                     const BSTJSON_REPORT_OPTIONS_t *options,
+                                                     const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                     int bufLen,
+                                                     int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    bool includePort = false;
+    uint64_t val = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    int includeServicePool[BVIEW_ASIC_MAX_SERVICE_POOLS] = { 0 };
+    int port = 0, pool = 0;
+    char portStr[JSON_MAX_NODE_LENGTH] = { 0 };
+
+
+    char *ipspTemplate = " { \"realm\": \"ingress-port-service-pool\", \"%s\": [ ";
+    char *ipspPortTemplate = " { \"port\": \"%s\", \"data\": [ ";
+    //char *ippgPortGroupTemplate = " { \"pg\" : %d , \"um-share\": %" PRIu64 " , \"um-headroom\": %" PRIu64 " } ,";
+    //char *ippgPortGroupTemplate = " { \"pg\" : %d , \"data\": [ %" PRIu64 " , %" PRIu64 " ] } ,";
+    char *ipspServicePoolTemplate = " [  %d , %" PRIu64 " ] ,";
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS - IPSP data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, ipspTemplate, "data");
+
+    /* For each port, and for each priority group in that port, 
+     *  1. attempt to see if this port needs to be reported.
+     *  2. create the report.
+     */
+    for (port = 1; port <= asic->numPorts; port++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((port-1 != options->triggerInfo.port) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+        includePort = false;
+        memset (&includeServicePool[0], 0, sizeof (includeServicePool));
+
+        /* lets see if this port needs to be included in the report at all */
+        for (pool = 1; pool <= asic->numServicePools; pool++)
+        {
+      /* check if the trigger report request should contain snap shot */
+           if ((pool-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+           {
+             continue;
+           }
+            /* By default, we plan to include the pool */
+            includeServicePool[pool - 1] = 1;
+
+            if (true == sendIncrReport)
+            {
+              /* If there is no traffic reported for this priority group, ignore it */
+              if ((previous == NULL) &&
+                  (current->iPortSp.data[port - 1][pool - 1].umShareBufferCount == 0))
+              {
+                includeServicePool[pool - 1] = 0;
+                continue;
+              }
+            }
+
+            /* If this is snapshot report, include the port in the data  */
+            if (previous == NULL)
+            {
+                includePort = true;
+                continue;
+            }
+
+            /* if there is traffic reported since the last snapshot, we can't ignore this pool */
+            if (previous->iPortSp.data[port - 1][pool - 1].umShareBufferCount
+                != current->iPortSp.data[port - 1][pool - 1].umShareBufferCount)
+            {
+                includePort = true;
+                continue;
+            }
+
+            /* since there is no reason to include the pool, we can ignore it*/
+            includeServicePool[pool - 1] = 0;
+        }
+
+        /* if this port needs not be reported, then we move to next port */
+        if (includePort == false)
+        {
+            continue;
+        }
+
+          /* convert the port to an external representation */
+          memset(&portStr[0], 0, JSON_MAX_NODE_LENGTH);
+          JSON_PORT_MAP_TO_NOTATION(port, asicId, &portStr[0]);
+
+          /* Now that this port needs to be included in the report, copy the header */
+          _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, ipspPortTemplate,  &portStr[0]);
+
+        /* for each priority-group, prepare the data */
+        for (pool = 1; pool <= asic->numServicePools; pool++)
+        {
+            /* we ignore if there is no data to be reported */
+            if (includeServicePool[pool - 1] == 0)
+                continue;
+
+            val = current->iPortSp.data[port - 1][pool - 1].umShareBufferCount;
+            defaultVal = options->bst_defaults_ptr->iPortSp.data[port - 1][pool - 1].umShareBufferCount;
+            bst_json_convert_data(options, asic, &val, defaultVal);
+
+            /* add the data to the report */
+            _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                          ipspServicePoolTemplate, pool-1,val);
+        }
+
+        /* adjust the buffer to remove the last ',' */
+        buffer = buffer - 1;
+        remLength += 1;
+        *length -= 1;
+
+        /* add the "] } ," for the next port */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      "] } ," );
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS - IPSP data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - ingress-service-pool.
+ *
+ *********************************************************************/
+static BVIEW_STATUS _jsonencode_report_ingress_sp ( char *buffer, int asicId,
+                                                   const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                                   const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                                   const BSTJSON_REPORT_OPTIONS_t *options,
+                                                   const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                                   int bufLen,
+                                                   int *length)
+{
+    int remLength = bufLen;
+    int actualLength  = 0;
+    int pool = 0;
+    uint64_t val = 0;
+    uint64_t defaultVal = 0;
+    int sendIncrReport = options->sendIncrementalReport;
+
+    char *ispTemplate = " { \"realm\": \"ingress-service-pool\", \"%s\": [ ";
+    char *ispServicePoolTemplate = " [  %d , %" PRIu64 " ] ,";
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS - ISP data \n");
+
+    /* copying the header . Pointer and Length adjustments are handled by the macro */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length, ispTemplate, "data");
+
+    /* For each service pool, check if there is a difference, and create the report. */
+    for (pool = 1; pool <= asic->numServicePools; pool++)
+    {
+      /* check if the trigger report request should contain snap shot */
+        if ((pool-1 != options->triggerInfo.queue) && 
+            (false == options->sendSnapShotOnTrigger) && 
+            (true == options->reportTrigger))
+        {
+          continue;
+        }
+
+        if (true == sendIncrReport)
+        {
+        /* lets see if this pool needs to be included in the report at all */
+        /* if this pool needs not be reported, then we move to next pool */
+         if ((previous == NULL) &&
+            (current->iSp.data[pool-1].umShareBufferCount == 0))
+            continue;  
+        }
+
+        if ((previous != NULL) &&
+            (previous->iSp.data[pool-1].umShareBufferCount == current->iSp.data[pool-1].umShareBufferCount))
+            continue;
+
+             val = current->iSp.data[pool-1].umShareBufferCount;
+             defaultVal = options->bst_defaults_ptr->iSp.data[pool-1].umShareBufferCount;
+             bst_json_convert_data(options, asic, &val, defaultVal);
+
+        /* Now that this pool needs to be included in the report, add the data to report */
+        _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                      ispServicePoolTemplate, pool-1, val);
+
+    }
+
+    /* adjust the buffer to remove the last ',' */
+    buffer = buffer - 1;
+    remLength += 1;
+    *length -= 1;
+
+    /* add the "] } ," for the next 'realm' */
+    _JSONENCODE_COPY_FORMATTED_STRING_AND_ADVANCE(actualLength, buffer, remLength, length,
+                                                  "] } ," );
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS - ISP data Complete \n");
+
+    return BVIEW_STATUS_SUCCESS;
+
+}
+
+/******************************************************************
+ * @brief  Creates a JSON buffer using the supplied data for the 
+ *         "get-bst-report" REST API - ingress part.
+ *
+ *********************************************************************/
+BVIEW_STATUS _jsonencode_report_ingress ( char *buffer, 
+                                         int asicId,
+                                         const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *previous,
+                                         const BVIEW_BST_ASIC_SNAPSHOT_DATA_t *current,
+                                         const BSTJSON_REPORT_OPTIONS_t *options,
+                                         const BVIEW_ASIC_CAPABILITIES_t *asic,
+                                         int bufLen,
+                                         int *length)
+{
+    BVIEW_STATUS status;
+    int tempLength = 0;
+
+    *length = 0;
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS data \n");
+
+    /* If Port-PriorityGroup realm is asked for, lets encode the corresponding data */
+    if (options->includeIngressPortPriorityGroup)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_ingress_ippg(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If Port-ServicePool realm is asked for, lets encode the corresponding data */
+    if (options->includeIngressPortServicePool)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_ingress_ipsp(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    /* If ServicePool realm is asked for, lets encode the corresponding data */
+    if (options->includeIngressServicePool)
+    {
+        tempLength = 0;
+        status = _jsonencode_report_ingress_sp(buffer, asicId, previous, current, options, asic, bufLen, &tempLength);
+        _JSONENCODE_ASSERT_ERROR((status == BVIEW_STATUS_SUCCESS), status);
+        if (tempLength != 0)
+        {
+            bufLen -= (tempLength);
+            buffer += (tempLength);
+            *(length) += (tempLength);
+        }
+    }
+
+    if (tempLength != 0)
+    {
+        if (! (options->includeEgressCpuQueue ||
+               options->includeEgressMcQueue ||
+               options->includeEgressPortServicePool ||
+               options->includeEgressRqeQueue ||
+               options->includeEgressServicePool ||
+               options->includeEgressUcQueue ||
+               options->includeEgressUcQueueGroup ))
+        {
+            *(length) -= 1;
+        }
+    }
+
+    _JSONENCODE_LOG(_JSONENCODE_DEBUG_TRACE, "BST-JSON-Encoder : (Report) Encoding INGRESS data complete \n");
+
+
+    return BVIEW_STATUS_SUCCESS;
+}
diff --git a/src/apps/bst/api/bst_json_memory.c b/src/apps/bst/api/bst_json_memory.c
new file mode 100755
index 0000000..a1e9134
--- /dev/null
+++ b/src/apps/bst/api/bst_json_memory.c
@@ -0,0 +1,421 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <pthread.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "broadview.h"
+#include "bst_json_memory.h"
+
+#define _BUFPOOL_DEBUG
+#define _BUFPOOL_DEBUG_LEVEL        _BUFPOOL_DEBUG_ERROR
+
+#define _BUFPOOL_DEBUG_TRACE        (0x1)
+#define _BUFPOOL_DEBUG_INFO         (0x01 << 1)
+#define _BUFPOOL_DEBUG_ERROR        (0x01 << 2)
+#define _BUFPOOL_DEBUG_ALL          (0xFF)
+
+#ifdef _BUFPOOL_DEBUG
+#define _BUFPOOL_LOG(level, format,args...)   do { \
+            if ((level) & _BUFPOOL_DEBUG_LEVEL) { \
+                printf(format, ##args); \
+            } \
+        }while(0)
+#else 
+#define _BUFPOOL_LOG(level, format,args...)
+#endif
+
+/* The following are proportional to number of collectors */
+
+#define _BUFPOOL_MAX_RESPONE_SLICES      20
+#define _BUFPOOL_MAX_REPORT_SLICES       4       
+
+/* The following structure represents a memory slice for allocation management */
+
+typedef struct _memory_slice_
+{
+    uint8_t *buffer;
+    BSTJSON_MEMORY_SIZE size;
+    bool inUse;
+    time_t timeTaken;
+    int command;
+} _BUFPOOL_MEMORY_SLICE_t;
+
+/* Buffer Pool, will be filled in during initialization */
+/* There is no necessity for a 'page'/ 'cacheline' alignment */
+/* so, simple static buffers would do just well */
+/* we manipulate the index based on the fact that the memory */
+
+/* is allocated in a contiguous way */
+
+static struct _memory_pool_
+{
+    /* Buffers */
+
+    uint8_t smallBufferPool[_BUFPOOL_MAX_RESPONE_SLICES][BSTJSON_MEMSIZE_RESPONSE];
+    uint8_t largeBufferPool[_BUFPOOL_MAX_REPORT_SLICES][BSTJSON_MEMSIZE_REPORT];
+
+    /* Buffer Descriptors */
+
+    _BUFPOOL_MEMORY_SLICE_t smallSlices[_BUFPOOL_MAX_RESPONE_SLICES];
+    _BUFPOOL_MEMORY_SLICE_t largeSlices[_BUFPOOL_MAX_REPORT_SLICES];
+
+    /* Internal Buffer Management */
+    pthread_mutex_t lock;
+
+    /* timer purposes */
+    time_t start;
+
+} bstJsonMemoryPool;
+
+static struct _memory_pool_ *pBufPool;
+
+/* Utility Macros for parameter validation */
+#define _BUFPOOL_ASSERT_ERROR(condition, errcode) do { \
+    if (!(condition)) { \
+        _BUFPOOL_LOG(_BUFPOOL_DEBUG_ERROR, \
+                    "BST Buffer Pool (%s:%d) Invalid Input Parameter  \n", \
+                    __func__, __LINE__); \
+        return (errcode); \
+    } \
+} while(0)
+
+#define _BUFPOOL_ASSERT(condition) _BUFPOOL_ASSERT_ERROR((condition), (BVIEW_STATUS_INVALID_PARAMETER))
+
+/* Utility Macros */
+
+#define _BUFPOOL_SMALL_POOL_START   ((ptr_to_uint_t) & (pBufPool->smallBufferPool[0][0]))
+#define _BUFPOOL_SMALL_POOL_END     (_BUFPOOL_SMALL_POOL_START + ( (_BUFPOOL_MAX_RESPONE_SLICES-1) * BSTJSON_MEMSIZE_RESPONSE))
+#define _BUFPOOL_LARGE_POOL_START   ((ptr_to_uint_t) & (pBufPool->largeBufferPool[0][0]))
+#define _BUFPOOL_LARGE_POOL_END     (_BUFPOOL_LARGE_POOL_START + ( (_BUFPOOL_MAX_REPORT_SLICES-1) * BSTJSON_MEMSIZE_REPORT))
+
+
+/* Utility Macros for streamlining the buffer pool access */
+
+#define _BUFPOOL_MUTEX_TAKE(lock) do { \
+    int rv; \
+    _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE, "BST BUffer Pool : Acquiring Mutex \n"); \
+    rv = pthread_mutex_lock(&(lock)); \
+    if (rv != 0) { \
+        _BUFPOOL_LOG(_BUFPOOL_DEBUG_ERROR, "BST BUffer Pool : Acquiring Mutex Failed : %d \n", rv); \
+        return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE; \
+    } \
+ } while(0)
+
+#define _BUFPOOL_MUTEX_RELEASE(lock) do { \
+    int rv; \
+    _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE, "BST BUffer Pool : Releasing Mutex \n"); \
+    rv = pthread_mutex_unlock(&(lock)); \
+    if (rv != 0) { \
+        _BUFPOOL_LOG(_BUFPOOL_DEBUG_ERROR, "BST BUffer Pool : Releasing Mutex Failed : %d \n", rv); \
+        return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE; \
+    } \
+ } while(0)
+
+/*****************************************************************//**
+* @brief  Initialize Buffer Pool.
+*
+*
+* @retval   BVIEW_STATUS_SUCCESS    if buffer pool is initialized successfully.
+* @retval   BVIEW_STATUS_FAILURE    on any internal error.
+*
+  *********************************************************************/
+
+BVIEW_STATUS bstjson_memory_init(void)
+{
+    int index = 0;
+
+    _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE, "BST BUffer Pool : Initializing \n");
+
+    /* clear the memory */
+    memset(&bstJsonMemoryPool, 0, sizeof (bstJsonMemoryPool));
+
+    /* Initialize the Buffer Descriptors */
+
+    pBufPool = &bstJsonMemoryPool;
+
+    for (index = 0; index < _BUFPOOL_MAX_RESPONE_SLICES; index++)
+    {
+        pBufPool->smallSlices[index].buffer = &pBufPool->smallBufferPool[index][0];
+        pBufPool->smallSlices[index].size = BSTJSON_MEMSIZE_RESPONSE;
+        pBufPool->smallSlices[index].inUse = false;
+        pBufPool->smallSlices[index].timeTaken = 0;
+    }
+
+    for (index = 0; index < _BUFPOOL_MAX_REPORT_SLICES; index++)
+    {
+        pBufPool->largeSlices[index].buffer = &pBufPool->largeBufferPool[index][0];
+        pBufPool->largeSlices[index].size = BSTJSON_MEMSIZE_REPORT;
+        pBufPool->largeSlices[index].inUse = false;
+        pBufPool->largeSlices[index].timeTaken = 0;
+    }
+
+    /* Create the lock */
+    pthread_mutex_init(&(pBufPool->lock), NULL);
+
+    time(&pBufPool->start);
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Allocates the desired buffer from the corresponding pool
+ *
+ * @param[in]    memSize     Memory Size (RESPONSE | REPORT)
+ * @param[out]   buffer      Pointer to the allocated buffer.
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  Buffer is allocated successfully
+ * @retval   BVIEW_STATUS_OUTOFMEMORY  No free buffers are available
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE  Attempting to take buffer recursively
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+ *
+ * @note     Only predefined (two types) sized buffers are supported.
+ *           See BSTJSON_MEMORY_SIZE.
+ *           The allocated buffer must be freed with a call to 
+ *           bstjson_memory_free()
+ *********************************************************************/
+BVIEW_STATUS bstjson_memory_allocate(BSTJSON_MEMORY_SIZE memSize, uint8_t **buffer)
+{
+    int index, max;
+    _BUFPOOL_MEMORY_SLICE_t *pSlice;
+
+    _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE,
+                 "BST BUffer Pool : Request for allocation of memory size %d \n",
+                 memSize);
+
+    /* Validate Input parameters */
+
+    _BUFPOOL_ASSERT(buffer != NULL);
+    _BUFPOOL_ASSERT((memSize == BSTJSON_MEMSIZE_RESPONSE) ||
+                    (memSize == BSTJSON_MEMSIZE_REPORT));
+
+    /* setup our data for lookup */
+
+    if (memSize == BSTJSON_MEMSIZE_RESPONSE)
+    {
+        pSlice = &pBufPool->smallSlices[0];
+        max = _BUFPOOL_MAX_RESPONE_SLICES;
+    }
+    else
+    {
+        pSlice = &pBufPool->largeSlices[0];
+        max = _BUFPOOL_MAX_REPORT_SLICES;
+    }
+
+    /* Obtain the lock for lookup */
+    _BUFPOOL_MUTEX_TAKE(pBufPool->lock);
+
+    /* The following looks up the buffer list and attempts to find 
+     * a buffer descriptor (a slice) which is 'available'. 
+     * When an available buffer is found, it returns that pointer to the
+     * caller, after necessary house-keeping.
+     */
+
+    for (index = 0; index < max; index++)
+    {
+
+        if ((pSlice->inUse) == false)
+        {
+            pSlice->inUse = true;
+            pSlice->size = memSize;
+            break;
+        }
+
+        pSlice++;
+    }
+
+    /* Release the mutex */
+    _BUFPOOL_MUTEX_RELEASE(pBufPool->lock);
+
+    /* if we found some available buffer, return to caller */
+    if (index != max)
+    {
+        /* update the caller */
+        *buffer = pSlice->buffer;
+        time(&pSlice->timeTaken);
+        _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE,
+                     "BST BUffer Pool : Allocated memory[ %"PRI_PTR_TO_UINT_FMT" - index=%d] size %d at %d \n",
+                     (ptr_to_uint_t)(*buffer), index, memSize, (int) pSlice->timeTaken);
+        return BVIEW_STATUS_SUCCESS;
+    }
+
+    _BUFPOOL_LOG(_BUFPOOL_DEBUG_ERROR,
+                 "BST BUffer Pool : Failed to allocated memory size %d \n",
+                 memSize);
+    return BVIEW_STATUS_OUTOFMEMORY;
+}
+
+/******************************************************************
+ * @brief  Returns the passed buffer to the corresponding pool
+ *
+ * @param[in]   buffer      Pointer to the buffer to be returned to pool.
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  Buffer is returned to pool successfully
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE  Attempting to return buffer recursively
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+ * @retval   BVIEW_STATUS_INVALID_MEMORY  The buffer was not allocated by the Pools
+ *
+ * @note     The buffer should have been originally allocated by  
+ *           bstjson_memory_allocate(). BVIEW_STATUS_INVALID_MEMORY is returned otherwise
+ *********************************************************************/
+BVIEW_STATUS bstjson_memory_free(uint8_t *buffer)
+{
+    /* Time for some pointer arithmetic */
+    /* We have to ensure that the 'buffer' was actually allocated by us. */
+    /* we could easily do a linear search through all slices and confirm it */
+    /* But that would be lot of searching */
+    /* Instead, we take advantage of the facts that */
+    /* 1. The buffer pools are contiguous memory */
+    /* 2. And that only two predefined sizes are allocated */
+    /* This reduces the search time significantly */
+
+    ptr_to_uint_t pointer = (ptr_to_uint_t) (buffer);
+    uint64_t temp = 0;
+    int index = 0;
+    _BUFPOOL_MEMORY_SLICE_t *pSlice;
+
+    _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE, "BST Buffer Pool : Returning %" PRI_PTR_TO_UINT_FMT " to pool \n", pointer);
+
+    /* Validate parameters */
+    _BUFPOOL_ASSERT(buffer != NULL);
+
+    /* Check the range. */
+    _BUFPOOL_ASSERT( (((pointer >= _BUFPOOL_SMALL_POOL_START) && (pointer <= _BUFPOOL_SMALL_POOL_END)) ||
+                      ((pointer >= _BUFPOOL_LARGE_POOL_START) && (pointer <= _BUFPOOL_LARGE_POOL_END))) );
+
+
+    /* check if this pointer is part of the 'small' pool and return to the pool */
+    if ( pointer <= _BUFPOOL_SMALL_POOL_END)
+    {
+        temp = (pointer - _BUFPOOL_SMALL_POOL_START);
+
+        _BUFPOOL_ASSERT_ERROR ( ((temp % BSTJSON_MEMSIZE_RESPONSE) == 0),
+                               BVIEW_STATUS_INVALID_MEMORY);
+
+        index = temp / BSTJSON_MEMSIZE_RESPONSE;
+
+        pSlice = &pBufPool->smallSlices[index];
+
+        if (pSlice->buffer == buffer)
+        {
+            /* Lock the Pools, update shared mem, release the lock */
+            _BUFPOOL_MUTEX_TAKE(pBufPool->lock);
+            pSlice->inUse = false;
+            pSlice->timeTaken = 0;
+            _BUFPOOL_MUTEX_RELEASE(pBufPool->lock);
+
+            _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE,
+                         "BST Buffer Pool : %" PRI_PTR_TO_UINT_FMT " [index %d] returned to RESPONSE pool \n",
+                         pointer, index);
+            return BVIEW_STATUS_SUCCESS;
+        }
+
+        _BUFPOOL_LOG(_BUFPOOL_DEBUG_ERROR,
+                     "BST Buffer Pool : %" PRI_PTR_TO_UINT_FMT " doesn't seem to have been allocated from RESPONSE pool \n",
+                     pointer);
+        return BVIEW_STATUS_INVALID_MEMORY;
+    }
+
+    /* Because of the above assert, the buffer is indeed with in large pool range */
+    if ( pointer <= _BUFPOOL_LARGE_POOL_END)
+    {
+        temp = (pointer - _BUFPOOL_LARGE_POOL_START);
+
+        _BUFPOOL_ASSERT_ERROR ( ((temp % BSTJSON_MEMSIZE_REPORT) == 0),
+                               BVIEW_STATUS_INVALID_MEMORY);
+
+        index = temp / BSTJSON_MEMSIZE_REPORT;
+
+        pSlice = &pBufPool->largeSlices[index];
+
+        if (pSlice->buffer == buffer)
+        {
+            /* Lock the Pools, update shared mem, release the lock */
+            _BUFPOOL_MUTEX_TAKE(pBufPool->lock);
+            pSlice->inUse = false;
+            pSlice->timeTaken = 0;
+            _BUFPOOL_MUTEX_RELEASE(pBufPool->lock);
+
+            _BUFPOOL_LOG(_BUFPOOL_DEBUG_TRACE,
+                         "BST Buffer Pool : %" PRI_PTR_TO_UINT_FMT " [index %d] returned to REPORT pool \n",
+                         pointer, index);
+            return BVIEW_STATUS_SUCCESS;
+        }
+
+        _BUFPOOL_LOG(_BUFPOOL_DEBUG_ERROR,
+                     "BST Buffer Pool : %" PRI_PTR_TO_UINT_FMT " doesn't seem to have been allocated from REPORT pool \n",
+                     pointer);
+        return BVIEW_STATUS_INVALID_MEMORY;
+    }
+
+    _BUFPOOL_LOG(_BUFPOOL_DEBUG_ERROR,
+                 "BST Buffer Pool : %" PRI_PTR_TO_UINT_FMT " doesn't seem to have been allocated any of the pools \n",
+                 pointer);
+
+    return BVIEW_STATUS_INVALID_MEMORY;
+}
+
+/*****************************************************************//**
+* @brief  Dump Buffer Pool.
+*
+*
+* @retval   none
+*
+  *********************************************************************/
+
+void bstjson_memory_dump(void)
+{
+    int index = 0;
+    int inUseCount = 0;
+
+    printf (" BST Buffer Pool Statistics : Total Memory %d bytes \n\n", (int)sizeof (bstJsonMemoryPool));
+
+    for (index = 0; index < _BUFPOOL_MAX_RESPONE_SLICES; index++)
+    {
+        printf (" [%2d] \t %"PRI_PTR_TO_UINT_FMT" \t %d \t %10s %10d\n",
+                index,(ptr_to_uint_t) (pBufPool->smallSlices[index].buffer),
+                pBufPool->smallSlices[index].size,
+                (pBufPool->smallSlices[index].inUse == true) ? "In Use" : "Available",
+                (pBufPool->smallSlices[index].inUse == true) ? (int) ( (pBufPool->smallSlices[index].timeTaken) - pBufPool->start) : 0
+                );
+
+        if (pBufPool->smallSlices[index].inUse == true)
+            inUseCount++;
+    }
+
+    printf("\n RESPONSE Pool - Total %3d -- In Use : %3d -- Available %3d \n\n",
+           _BUFPOOL_MAX_RESPONE_SLICES, inUseCount, (_BUFPOOL_MAX_RESPONE_SLICES - inUseCount));
+
+    inUseCount = 0;
+
+    for (index = 0; index < _BUFPOOL_MAX_REPORT_SLICES; index++)
+    {
+        printf (" [%2d] \t %"PRI_PTR_TO_UINT_FMT" \t %d \t %10s %10d\n",
+                index, (ptr_to_uint_t) (pBufPool->largeSlices[index].buffer),
+                pBufPool->largeSlices[index].size,
+                (pBufPool->largeSlices[index].inUse) ? "In Use" : "Available",
+                (pBufPool->largeSlices[index].inUse == true) ? (int) ( (pBufPool->largeSlices[index].timeTaken) - pBufPool->start) : 0
+                );
+    }
+
+    printf("\n REPORT Pool   - Total %3d -- In Use : %3d -- Available %3d \n\n",
+           _BUFPOOL_MAX_REPORT_SLICES, inUseCount, (_BUFPOOL_MAX_REPORT_SLICES - inUseCount));
+}
diff --git a/src/apps/bst/api/bst_json_memory.h b/src/apps/bst/api/bst_json_memory.h
new file mode 100755
index 0000000..ae4658d
--- /dev/null
+++ b/src/apps/bst/api/bst_json_memory.h
@@ -0,0 +1,50 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_BST_JSON_MEMORY_H
+#define	INCLUDE_BST_JSON_MEMORY_H
+
+#include "broadview.h"
+#include "bst.h"
+
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+/* A small implementation of a memory pool, that offers buffers in two sizes */
+
+typedef enum _bstjson_memory_size_
+{
+    BSTJSON_MEMSIZE_RESPONSE = 1024,
+    BSTJSON_MEMSIZE_REPORT = (sizeof(BVIEW_BST_ASIC_SNAPSHOT_DATA_t)+ 2048),
+} BSTJSON_MEMORY_SIZE;
+
+
+BVIEW_STATUS bstjson_memory_init(void);
+BVIEW_STATUS bstjson_memory_allocate(BSTJSON_MEMORY_SIZE memSize, uint8_t **buffer);
+BVIEW_STATUS bstjson_memory_free(uint8_t *buffer);
+void bstjson_memory_dump(void);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_BST_JSON_MEMORY_H */
+
diff --git a/src/apps/bst/api/clear_bst_statistics.c b/src/apps/bst/api/clear_bst_statistics.c
new file mode 100755
index 0000000..09b9c38
--- /dev/null
+++ b/src/apps/bst/api/clear_bst_statistics.c
@@ -0,0 +1,132 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "clear_bst_statistics.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_clear_bst_statistics (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id,  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_CLEAR_BST_STATISTICS_t command;
+
+    /*memset commented since the structure is empty*/
+    /* memset(&command, 0, sizeof (command));*/
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "clear-bst-statistics" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "clear-bst-statistics");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_clear_bst_statistics_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/clear_bst_statistics.h b/src/apps/bst/api/clear_bst_statistics.h
new file mode 100755
index 0000000..cd16f21
--- /dev/null
+++ b/src/apps/bst/api/clear_bst_statistics.h
@@ -0,0 +1,54 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_CLEAR_BST_STATISTICS_H 
+#define	INCLUDE_CLEAR_BST_STATISTICS_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_clear_bst_statistics_
+{
+} BSTJSON_CLEAR_BST_STATISTICS_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_clear_bst_statistics(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_clear_bst_statistics_impl(void *cookie, int asicId, int id, BSTJSON_CLEAR_BST_STATISTICS_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_CLEAR_BST_STATISTICS_H */ 
+
diff --git a/src/apps/bst/api/clear_bst_thresholds.c b/src/apps/bst/api/clear_bst_thresholds.c
new file mode 100755
index 0000000..92bf283
--- /dev/null
+++ b/src/apps/bst/api/clear_bst_thresholds.c
@@ -0,0 +1,133 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "clear_bst_thresholds.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_clear_bst_thresholds (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id,  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_CLEAR_BST_THRESHOLDS_t command;
+
+    /*memset commented since the structure is empty*/
+    /* memset(&command, 0, sizeof (command));*/
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "clear-bst-thresholds" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "clear-bst-thresholds");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_clear_bst_thresholds_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/clear_bst_thresholds.h b/src/apps/bst/api/clear_bst_thresholds.h
new file mode 100755
index 0000000..39956bf
--- /dev/null
+++ b/src/apps/bst/api/clear_bst_thresholds.h
@@ -0,0 +1,54 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_CLEAR_BST_THRESHOLDS_H 
+#define	INCLUDE_CLEAR_BST_THRESHOLDS_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_clear_bst_thresholds_
+{
+} BSTJSON_CLEAR_BST_THRESHOLDS_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_clear_bst_thresholds(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_clear_bst_thresholds_impl(void *cookie, int asicId, int id, BSTJSON_CLEAR_BST_THRESHOLDS_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_CLEAR_BST_THRESHOLDS_H */ 
+
diff --git a/src/apps/bst/api/configure_bst_feature.c b/src/apps/bst/api/configure_bst_feature.c
new file mode 100755
index 0000000..2dda277
--- /dev/null
+++ b/src/apps/bst/api/configure_bst_feature.c
@@ -0,0 +1,240 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "configure_bst_feature.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_configure_bst_feature (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id, *json_bstEnable, *json_sendAsyncReports;
+    cJSON *json_collectionInterval, *json_statUnitsInCells,  *root, *params;
+    cJSON *json_maxTriggerReports, *json_sendSnapshotTrigger,  *json_triggerTransmitInterval, *json_sendIncrementalReport;
+    cJSON *json_statsInPercentage;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_CONFIGURE_BST_FEATURE_t command;
+
+    memset(&command, 0, sizeof (command));
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "configure-bst-feature" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "configure-bst-feature");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Parsing and Validating 'bst-enable' from JSON buffer */
+    json_bstEnable = cJSON_GetObjectItem(params, "bst-enable");
+    JSON_VALIDATE_JSON_POINTER(json_bstEnable, "bst-enable", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_bstEnable, "bst-enable");
+    /* Copy the value */
+    command.bstEnable = json_bstEnable->valueint;
+    /* Ensure  that the number 'bst-enable' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.bstEnable, 0, 1);
+    command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_ENABLE));
+
+
+    /* Parsing and Validating 'send-async-reports' from JSON buffer */
+    json_sendAsyncReports = cJSON_GetObjectItem(params, "send-async-reports");
+    JSON_VALIDATE_JSON_POINTER(json_sendAsyncReports, "send-async-reports", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_sendAsyncReports, "send-async-reports");
+    /* Copy the value */
+    command.sendAsyncReports = json_sendAsyncReports->valueint;
+    /* Ensure  that the number 'send-async-reports' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.sendAsyncReports, 0, 1);
+    command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_SND_ASYNC_REP));
+
+
+    /* Parsing and Validating 'collection-interval' from JSON buffer */
+    json_collectionInterval = cJSON_GetObjectItem(params, "collection-interval");
+    JSON_VALIDATE_JSON_POINTER(json_collectionInterval, "collection-interval", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_collectionInterval, "collection-interval");
+    /* Copy the value */
+    command.collectionInterval = json_collectionInterval->valueint;
+    /* Ensure  that the number 'collection-interval' is within range of [0,600] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.collectionInterval, 0, 600);
+    command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_COLL_INTRVL));
+
+
+    /* Parsing and Validating 'stat-units-in-cells' from JSON buffer */
+    json_statUnitsInCells = cJSON_GetObjectItem(params, "stat-units-in-cells");
+    JSON_VALIDATE_JSON_POINTER(json_statUnitsInCells, "stat-units-in-cells", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_statUnitsInCells, "stat-units-in-cells");
+    /* Copy the value */
+    command.statUnitsInCells = json_statUnitsInCells->valueint;
+    /* Ensure  that the number 'stat-units-in-cells' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.statUnitsInCells, 0, 1);
+    command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_STATS_UNITS));
+
+    /* Parsing and Validating 'max-trigger-reports' from JSON buffer */
+    json_maxTriggerReports = cJSON_GetObjectItem(params, "trigger-rate-limit");
+    if (NULL != json_maxTriggerReports)
+    {
+      JSON_VALIDATE_JSON_POINTER(json_maxTriggerReports, "trigger-rate-limit", BVIEW_STATUS_INVALID_JSON);
+      JSON_VALIDATE_JSON_AS_NUMBER(json_maxTriggerReports, "trigger-rate-limit");
+      /* Copy the value */
+      command.bstMaxTriggers = json_maxTriggerReports->valueint;
+      JSON_CHECK_VALUE_AND_CLEANUP (command.bstMaxTriggers, 1, 30);
+      command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_TGR_RATE_LIMIT));
+    }
+
+    /* Parsing and Validating 'send-snapshot-on-trigger' from JSON buffer */
+    json_sendSnapshotTrigger = cJSON_GetObjectItem(params, "send-snapshot-on-trigger");
+    if (NULL != json_sendSnapshotTrigger)
+    {
+      JSON_VALIDATE_JSON_POINTER(json_sendSnapshotTrigger, "send-snapshot-on-trigger", BVIEW_STATUS_INVALID_JSON);
+      JSON_VALIDATE_JSON_AS_NUMBER(json_sendSnapshotTrigger, "send-snapshot-on-trigger");
+      /* Copy the value */
+      command.sendSnapshotOnTrigger = json_sendSnapshotTrigger->valueint;
+      JSON_CHECK_VALUE_AND_CLEANUP (command.sendSnapshotOnTrigger, 0, 1);
+      command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_SND_SNAP_TGR));
+    }
+
+    /* Parsing and Validating 'trigger-rate-limit-interval' from JSON buffer */
+    json_triggerTransmitInterval = cJSON_GetObjectItem(params, "trigger-rate-limit-interval");
+    if (NULL != json_triggerTransmitInterval)
+    {
+      JSON_VALIDATE_JSON_POINTER(json_triggerTransmitInterval, "trigger-rate-limit-interval", BVIEW_STATUS_INVALID_JSON);
+      JSON_VALIDATE_JSON_AS_NUMBER(json_triggerTransmitInterval, "trigger-rate-limit-interval");
+      /* Copy the value */
+      command.triggerTransmitInterval = json_triggerTransmitInterval->valueint;
+      JSON_CHECK_VALUE_AND_CLEANUP (command.triggerTransmitInterval, 1, 60);
+      command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_TGR_RL_INTVL));
+    }
+
+    /* Parsing and Validating 'aync-full-reports' from JSON buffer */
+    json_sendIncrementalReport = cJSON_GetObjectItem(params, "async-full-reports");
+    if (NULL != json_sendIncrementalReport)
+    {
+      JSON_VALIDATE_JSON_POINTER(json_sendIncrementalReport, "async-full-reports", BVIEW_STATUS_INVALID_JSON);
+      JSON_VALIDATE_JSON_AS_NUMBER(json_sendIncrementalReport, "async-full-reports");
+      /* Copy the value */
+      command.sendIncrementalReport = json_sendIncrementalReport->valueint;
+      JSON_CHECK_VALUE_AND_CLEANUP (command.sendIncrementalReport, 0, 1);
+      command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_ASYNC_FULL_REP));
+    }
+
+    /* Parsing and Validating 'stats-in-percentage' from JSON buffer */
+    json_statsInPercentage = cJSON_GetObjectItem(params, "stats-in-percentage");
+    if (NULL != json_statsInPercentage)
+    {
+      JSON_VALIDATE_JSON_POINTER(json_statsInPercentage, "stats-in-percentage", BVIEW_STATUS_INVALID_JSON);
+      JSON_VALIDATE_JSON_AS_NUMBER(json_statsInPercentage, "stats-in-percentage");
+      /* Copy the value */
+      command.statsInPercentage = json_statsInPercentage->valueint;
+      /* Ensure  that the number 'stats-in-percentage' is within range of [0,1] */
+      JSON_CHECK_VALUE_AND_CLEANUP (command.statsInPercentage, 0, 1);
+      command.configMask = (command.configMask | (1 << BST_CONFIG_PARAMS_STATS_IN_PERCENT));
+    }
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_configure_bst_feature_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/configure_bst_feature.h b/src/apps/bst/api/configure_bst_feature.h
new file mode 100755
index 0000000..be56c0f
--- /dev/null
+++ b/src/apps/bst/api/configure_bst_feature.h
@@ -0,0 +1,74 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_CONFIGURE_BST_FEATURE_H 
+#define	INCLUDE_CONFIGURE_BST_FEATURE_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+#define BST_CONFIG_PARAMS_ENABLE 0
+#define BST_CONFIG_PARAMS_SND_ASYNC_REP 1
+#define BST_CONFIG_PARAMS_COLL_INTRVL 2
+#define BST_CONFIG_PARAMS_STATS_UNITS 3
+#define BST_CONFIG_PARAMS_TGR_RATE_LIMIT 4
+#define BST_CONFIG_PARAMS_SND_SNAP_TGR 5
+#define BST_CONFIG_PARAMS_TGR_RL_INTVL 6
+#define BST_CONFIG_PARAMS_ASYNC_FULL_REP 7
+#define BST_CONFIG_PARAMS_STATS_IN_PERCENT 8
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_configure_bst_feature_
+{
+    int bstEnable;
+    int sendAsyncReports;
+    int collectionInterval;
+    int statsInPercentage;
+    int statUnitsInCells;
+    int bstMaxTriggers;
+    int sendSnapshotOnTrigger;
+    int triggerTransmitInterval;
+    int sendIncrementalReport;
+    int configMask;
+} BSTJSON_CONFIGURE_BST_FEATURE_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_configure_bst_feature(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_configure_bst_feature_impl(void *cookie, int asicId, int id, BSTJSON_CONFIGURE_BST_FEATURE_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_CONFIGURE_BST_FEATURE_H */ 
+
diff --git a/src/apps/bst/api/configure_bst_thresholds.c b/src/apps/bst/api/configure_bst_thresholds.c
new file mode 100755
index 0000000..5ed21b2
--- /dev/null
+++ b/src/apps/bst/api/configure_bst_thresholds.c
@@ -0,0 +1,346 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "configure_bst_thresholds.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_configure_bst_thresholds (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id, *json_realm, *json_port;
+    cJSON *json_priorityGroup, *json_servicePool, *json_queue;
+    cJSON *json_queueGroup, *json_threshold, *json_umShareThreshold;
+    cJSON *json_umHeadroomThreshold, *json_ucShareThreshold, *json_mcShareThreshold;
+    cJSON *json_mcShareQueueEntriesThreshold, *json_ucThreshold, *json_mcThreshold;
+    cJSON *json_mcQueueEntriesThreshold, *json_cpuThreshold, *json_rqeThreshold;
+    cJSON  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_CONFIGURE_BST_THRESHOLDS_t command;
+
+    memset(&command, 0, sizeof (command));
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "configure-bst-thresholds" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "configure-bst-thresholds");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Parsing and Validating 'realm' from JSON buffer */
+    json_realm = cJSON_GetObjectItem(params, "realm");
+    JSON_VALIDATE_JSON_POINTER(json_realm, "realm", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_realm, "realm", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&command.realm[0], json_realm->valuestring, JSON_MAX_NODE_LENGTH - 1);
+
+
+    /* Parsing and Validating 'port' from JSON buffer */
+    json_port = cJSON_GetObjectItem(params, "port");
+    /* The node 'port' is an optioanl one, ignore if not present in JSON */
+    if (json_port != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_port, "port", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_STRING(json_port, "port", BVIEW_STATUS_INVALID_JSON);
+        /* Copy the 'port' in external notation to our internal representation */
+        JSON_PORT_MAP_FROM_NOTATION(command.port, json_port->valuestring);
+    } /* if optional */
+
+
+    /* Parsing and Validating 'priority-group' from JSON buffer */
+    json_priorityGroup = cJSON_GetObjectItem(params, "priority-group");
+    /* The node 'priority-group' is an optioanl one, ignore if not present in JSON */
+    if (json_priorityGroup != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_priorityGroup, "priority-group", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_priorityGroup, "priority-group");
+        /* Copy the value */
+        command.priorityGroup = json_priorityGroup->valueint;
+        /* Ensure  that the number 'priority-group' is within range of [0,7] */
+        JSON_CHECK_VALUE_AND_CLEANUP (command.priorityGroup, 0, 7);
+    } /* if optional */
+
+
+    /* Parsing and Validating 'service-pool' from JSON buffer */
+    json_servicePool = cJSON_GetObjectItem(params, "service-pool");
+    /* The node 'service-pool' is an optioanl one, ignore if not present in JSON */
+    if (json_servicePool != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_servicePool, "service-pool", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_servicePool, "service-pool");
+        /* Copy the value */
+        command.servicePool = json_servicePool->valueint;
+        /* Ensure  that the number 'service-pool' is within range of [0,3] */
+        JSON_CHECK_VALUE_AND_CLEANUP (command.servicePool, 0, 3);
+    } /* if optional */
+
+
+    /* Parsing and Validating 'queue' from JSON buffer */
+    json_queue = cJSON_GetObjectItem(params, "queue");
+    /* The node 'queue' is an optioanl one, ignore if not present in JSON */
+    if (json_queue != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_queue, "queue", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_queue, "queue");
+        /* Copy the value */
+        command.queue = json_queue->valueint;
+        /* Ensure  that the number 'queue' is within range of [0,4095] */
+        JSON_CHECK_VALUE_AND_CLEANUP (command.queue, 0, 4095);
+    } /* if optional */
+
+
+    /* Parsing and Validating 'queue-group' from JSON buffer */
+    json_queueGroup = cJSON_GetObjectItem(params, "queue-group");
+    /* The node 'queue-group' is an optioanl one, ignore if not present in JSON */
+    if (json_queueGroup != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_queueGroup, "queue-group", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_queueGroup, "queue-group");
+        /* Copy the value */
+        command.queueGroup = json_queueGroup->valueint;
+        /* Ensure  that the number 'queue-group' is within range of [0,7] */
+        JSON_CHECK_VALUE_AND_CLEANUP (command.queueGroup, 0, 127);
+    } /* if optional */
+
+
+    /* Parsing and Validating 'threshold' from JSON buffer */
+    json_threshold = cJSON_GetObjectItem(params, "threshold");
+    /* The node 'threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_threshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_threshold, "threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_threshold, "threshold");
+        /* Copy the value */
+        command.threshold = json_threshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'um-share-threshold' from JSON buffer */
+    json_umShareThreshold = cJSON_GetObjectItem(params, "um-share-threshold");
+    /* The node 'um-share-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_umShareThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_umShareThreshold, "um-share-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_umShareThreshold, "um-share-threshold");
+        /* Copy the value */
+        command.umShareThreshold = json_umShareThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'um-headroom-threshold' from JSON buffer */
+    json_umHeadroomThreshold = cJSON_GetObjectItem(params, "um-headroom-threshold");
+    /* The node 'um-headroom-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_umHeadroomThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_umHeadroomThreshold, "um-headroom-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_umHeadroomThreshold, "um-headroom-threshold");
+        /* Copy the value */
+        command.umHeadroomThreshold = json_umHeadroomThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'uc-share-threshold' from JSON buffer */
+    json_ucShareThreshold = cJSON_GetObjectItem(params, "uc-share-threshold");
+    /* The node 'uc-share-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_ucShareThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_ucShareThreshold, "uc-share-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_ucShareThreshold, "uc-share-threshold");
+        /* Copy the value */
+        command.ucShareThreshold = json_ucShareThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'mc-share-threshold' from JSON buffer */
+    json_mcShareThreshold = cJSON_GetObjectItem(params, "mc-share-threshold");
+    /* The node 'mc-share-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_mcShareThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_mcShareThreshold, "mc-share-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_mcShareThreshold, "mc-share-threshold");
+        /* Copy the value */
+        command.mcShareThreshold = json_mcShareThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'mc-share-queue-entries-threshold' from JSON buffer */
+    json_mcShareQueueEntriesThreshold = cJSON_GetObjectItem(params, "mc-share-queue-entries-threshold");
+    /* The node 'mc-share-queue-entries-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_mcShareQueueEntriesThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_mcShareQueueEntriesThreshold, "mc-share-queue-entries-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_mcShareQueueEntriesThreshold, "mc-share-queue-entries-threshold");
+        /* Copy the value */
+        command.mcShareQueueEntriesThreshold = json_mcShareQueueEntriesThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'uc-threshold' from JSON buffer */
+    json_ucThreshold = cJSON_GetObjectItem(params, "uc-threshold");
+    /* The node 'uc-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_ucThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_ucThreshold, "uc-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_ucThreshold, "uc-threshold");
+        /* Copy the value */
+        command.ucThreshold = json_ucThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'mc-threshold' from JSON buffer */
+    json_mcThreshold = cJSON_GetObjectItem(params, "mc-threshold");
+    /* The node 'mc-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_mcThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_mcThreshold, "mc-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_mcThreshold, "mc-threshold");
+        /* Copy the value */
+        command.mcThreshold = json_mcThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'mc-queue-entries-threshold' from JSON buffer */
+    json_mcQueueEntriesThreshold = cJSON_GetObjectItem(params, "mc-queue-entries-threshold");
+    /* The node 'mc-queue-entries-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_mcQueueEntriesThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_mcQueueEntriesThreshold, "mc-queue-entries-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_mcQueueEntriesThreshold, "mc-queue-entries-threshold");
+        /* Copy the value */
+        command.mcQueueEntriesThreshold = json_mcQueueEntriesThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'cpu-threshold' from JSON buffer */
+    json_cpuThreshold = cJSON_GetObjectItem(params, "cpu-threshold");
+    /* The node 'cpu-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_cpuThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_cpuThreshold, "cpu-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_cpuThreshold, "cpu-threshold");
+        /* Copy the value */
+        command.cpuThreshold = json_cpuThreshold->valueint;
+    } /* if optional */
+
+
+    /* Parsing and Validating 'rqe-threshold' from JSON buffer */
+    json_rqeThreshold = cJSON_GetObjectItem(params, "rqe-threshold");
+    /* The node 'rqe-threshold' is an optioanl one, ignore if not present in JSON */
+    if (json_rqeThreshold != NULL)
+    {
+        JSON_VALIDATE_JSON_POINTER(json_rqeThreshold, "rqe-threshold", BVIEW_STATUS_INVALID_JSON);
+        JSON_VALIDATE_JSON_AS_NUMBER(json_rqeThreshold, "rqe-threshold");
+        /* Copy the value */
+        command.rqeThreshold = json_rqeThreshold->valueint;
+    } /* if optional */
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_configure_bst_thresholds_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/configure_bst_thresholds.h b/src/apps/bst/api/configure_bst_thresholds.h
new file mode 100755
index 0000000..a04744a
--- /dev/null
+++ b/src/apps/bst/api/configure_bst_thresholds.h
@@ -0,0 +1,71 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_CONFIGURE_BST_THRESHOLDS_H 
+#define	INCLUDE_CONFIGURE_BST_THRESHOLDS_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_configure_bst_thresholds_
+{
+    char realm[JSON_MAX_NODE_LENGTH];
+    int port;
+    int priorityGroup;
+    int servicePool;
+    int queue;
+    int queueGroup;
+    int threshold;
+    int umShareThreshold;
+    int umHeadroomThreshold;
+    int ucShareThreshold;
+    int mcShareThreshold;
+    int mcShareQueueEntriesThreshold;
+    int ucThreshold;
+    int mcThreshold;
+    int mcQueueEntriesThreshold;
+    int cpuThreshold;
+    int rqeThreshold;
+} BSTJSON_CONFIGURE_BST_THRESHOLDS_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_configure_bst_thresholds(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_configure_bst_thresholds_impl(void *cookie, int asicId, int id, BSTJSON_CONFIGURE_BST_THRESHOLDS_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_CONFIGURE_BST_THRESHOLDS_H */ 
+
diff --git a/src/apps/bst/api/configure_bst_tracking.c b/src/apps/bst/api/configure_bst_tracking.c
new file mode 100755
index 0000000..d9253cf
--- /dev/null
+++ b/src/apps/bst/api/configure_bst_tracking.c
@@ -0,0 +1,257 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "configure_bst_tracking.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_configure_bst_tracking (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id, *json_trackPeakStats, *json_trackIngressPortPriorityGroup;
+    cJSON *json_trackIngressPortServicePool, *json_trackIngressServicePool, *json_trackEgressPortServicePool;
+    cJSON *json_trackEgressServicePool, *json_trackEgressUcQueue, *json_trackEgressUcQueueGroup;
+    cJSON *json_trackEgressMcQueue, *json_trackEgressCpuQueue, *json_trackEgressRqeQueue;
+    cJSON *json_trackDevice,  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_CONFIGURE_BST_TRACKING_t command;
+
+    memset(&command, 0, sizeof (command));
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "configure-bst-tracking" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "configure-bst-tracking");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Parsing and Validating 'track-peak-stats' from JSON buffer */
+    json_trackPeakStats = cJSON_GetObjectItem(params, "track-peak-stats");
+    JSON_VALIDATE_JSON_POINTER(json_trackPeakStats, "track-peak-stats", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackPeakStats, "track-peak-stats");
+    /* Copy the value */
+    command.trackPeakStats = json_trackPeakStats->valueint;
+    /* Ensure  that the number 'track-peak-stats' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackPeakStats, 0, 1);
+
+
+    /* Parsing and Validating 'track-ingress-port-priority-group' from JSON buffer */
+    json_trackIngressPortPriorityGroup = cJSON_GetObjectItem(params, "track-ingress-port-priority-group");
+    JSON_VALIDATE_JSON_POINTER(json_trackIngressPortPriorityGroup, "track-ingress-port-priority-group", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackIngressPortPriorityGroup, "track-ingress-port-priority-group");
+    /* Copy the value */
+    command.trackIngressPortPriorityGroup = json_trackIngressPortPriorityGroup->valueint;
+    /* Ensure  that the number 'track-ingress-port-priority-group' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackIngressPortPriorityGroup, 0, 1);
+
+
+    /* Parsing and Validating 'track-ingress-port-service-pool' from JSON buffer */
+    json_trackIngressPortServicePool = cJSON_GetObjectItem(params, "track-ingress-port-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_trackIngressPortServicePool, "track-ingress-port-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackIngressPortServicePool, "track-ingress-port-service-pool");
+    /* Copy the value */
+    command.trackIngressPortServicePool = json_trackIngressPortServicePool->valueint;
+    /* Ensure  that the number 'track-ingress-port-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackIngressPortServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'track-ingress-service-pool' from JSON buffer */
+    json_trackIngressServicePool = cJSON_GetObjectItem(params, "track-ingress-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_trackIngressServicePool, "track-ingress-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackIngressServicePool, "track-ingress-service-pool");
+    /* Copy the value */
+    command.trackIngressServicePool = json_trackIngressServicePool->valueint;
+    /* Ensure  that the number 'track-ingress-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackIngressServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'track-egress-port-service-pool' from JSON buffer */
+    json_trackEgressPortServicePool = cJSON_GetObjectItem(params, "track-egress-port-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_trackEgressPortServicePool, "track-egress-port-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackEgressPortServicePool, "track-egress-port-service-pool");
+    /* Copy the value */
+    command.trackEgressPortServicePool = json_trackEgressPortServicePool->valueint;
+    /* Ensure  that the number 'track-egress-port-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackEgressPortServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'track-egress-service-pool' from JSON buffer */
+    json_trackEgressServicePool = cJSON_GetObjectItem(params, "track-egress-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_trackEgressServicePool, "track-egress-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackEgressServicePool, "track-egress-service-pool");
+    /* Copy the value */
+    command.trackEgressServicePool = json_trackEgressServicePool->valueint;
+    /* Ensure  that the number 'track-egress-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackEgressServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'track-egress-uc-queue' from JSON buffer */
+    json_trackEgressUcQueue = cJSON_GetObjectItem(params, "track-egress-uc-queue");
+    JSON_VALIDATE_JSON_POINTER(json_trackEgressUcQueue, "track-egress-uc-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackEgressUcQueue, "track-egress-uc-queue");
+    /* Copy the value */
+    command.trackEgressUcQueue = json_trackEgressUcQueue->valueint;
+    /* Ensure  that the number 'track-egress-uc-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackEgressUcQueue, 0, 1);
+
+
+    /* Parsing and Validating 'track-egress-uc-queue-group' from JSON buffer */
+    json_trackEgressUcQueueGroup = cJSON_GetObjectItem(params, "track-egress-uc-queue-group");
+    JSON_VALIDATE_JSON_POINTER(json_trackEgressUcQueueGroup, "track-egress-uc-queue-group", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackEgressUcQueueGroup, "track-egress-uc-queue-group");
+    /* Copy the value */
+    command.trackEgressUcQueueGroup = json_trackEgressUcQueueGroup->valueint;
+    /* Ensure  that the number 'track-egress-uc-queue-group' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackEgressUcQueueGroup, 0, 1);
+
+
+    /* Parsing and Validating 'track-egress-mc-queue' from JSON buffer */
+    json_trackEgressMcQueue = cJSON_GetObjectItem(params, "track-egress-mc-queue");
+    JSON_VALIDATE_JSON_POINTER(json_trackEgressMcQueue, "track-egress-mc-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackEgressMcQueue, "track-egress-mc-queue");
+    /* Copy the value */
+    command.trackEgressMcQueue = json_trackEgressMcQueue->valueint;
+    /* Ensure  that the number 'track-egress-mc-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackEgressMcQueue, 0, 1);
+
+
+    /* Parsing and Validating 'track-egress-cpu-queue' from JSON buffer */
+    json_trackEgressCpuQueue = cJSON_GetObjectItem(params, "track-egress-cpu-queue");
+    JSON_VALIDATE_JSON_POINTER(json_trackEgressCpuQueue, "track-egress-cpu-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackEgressCpuQueue, "track-egress-cpu-queue");
+    /* Copy the value */
+    command.trackEgressCpuQueue = json_trackEgressCpuQueue->valueint;
+    /* Ensure  that the number 'track-egress-cpu-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackEgressCpuQueue, 0, 1);
+
+
+    /* Parsing and Validating 'track-egress-rqe-queue' from JSON buffer */
+    json_trackEgressRqeQueue = cJSON_GetObjectItem(params, "track-egress-rqe-queue");
+    JSON_VALIDATE_JSON_POINTER(json_trackEgressRqeQueue, "track-egress-rqe-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackEgressRqeQueue, "track-egress-rqe-queue");
+    /* Copy the value */
+    command.trackEgressRqeQueue = json_trackEgressRqeQueue->valueint;
+    /* Ensure  that the number 'track-egress-rqe-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackEgressRqeQueue, 0, 1);
+
+
+    /* Parsing and Validating 'track-device' from JSON buffer */
+    json_trackDevice = cJSON_GetObjectItem(params, "track-device");
+    JSON_VALIDATE_JSON_POINTER(json_trackDevice, "track-device", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_trackDevice, "track-device");
+    /* Copy the value */
+    command.trackDevice = json_trackDevice->valueint;
+    /* Ensure  that the number 'track-device' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.trackDevice, 0, 1);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_configure_bst_tracking_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/configure_bst_tracking.h b/src/apps/bst/api/configure_bst_tracking.h
new file mode 100755
index 0000000..fe64118
--- /dev/null
+++ b/src/apps/bst/api/configure_bst_tracking.h
@@ -0,0 +1,66 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_CONFIGURE_BST_TRACKING_H 
+#define	INCLUDE_CONFIGURE_BST_TRACKING_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_configure_bst_tracking_
+{
+    int trackPeakStats;
+    int trackIngressPortPriorityGroup;
+    int trackIngressPortServicePool;
+    int trackIngressServicePool;
+    int trackEgressPortServicePool;
+    int trackEgressServicePool;
+    int trackEgressUcQueue;
+    int trackEgressUcQueueGroup;
+    int trackEgressMcQueue;
+    int trackEgressCpuQueue;
+    int trackEgressRqeQueue;
+    int trackDevice;
+} BSTJSON_CONFIGURE_BST_TRACKING_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_configure_bst_tracking(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_configure_bst_tracking_impl(void *cookie, int asicId, int id, BSTJSON_CONFIGURE_BST_TRACKING_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_CONFIGURE_BST_TRACKING_H */ 
+
diff --git a/src/apps/bst/api/get_bst_feature.c b/src/apps/bst/api/get_bst_feature.c
new file mode 100755
index 0000000..8db8709
--- /dev/null
+++ b/src/apps/bst/api/get_bst_feature.c
@@ -0,0 +1,133 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "get_bst_feature.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_get_bst_feature (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id,  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_GET_BST_FEATURE_t command;
+
+    /*memset commented since the structure is empty*/
+    /* memset(&command, 0, sizeof (command));*/
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "get-bst-feature" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "get-bst-feature");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_get_bst_feature_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/get_bst_feature.h b/src/apps/bst/api/get_bst_feature.h
new file mode 100755
index 0000000..fd5e2ed
--- /dev/null
+++ b/src/apps/bst/api/get_bst_feature.h
@@ -0,0 +1,54 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_GET_BST_FEATURE_H 
+#define	INCLUDE_GET_BST_FEATURE_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_get_bst_feature_
+{
+} BSTJSON_GET_BST_FEATURE_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_get_bst_feature(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_get_bst_feature_impl(void *cookie, int asicId, int id, BSTJSON_GET_BST_FEATURE_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_GET_BST_FEATURE_H */ 
+
diff --git a/src/apps/bst/api/get_bst_report.c b/src/apps/bst/api/get_bst_report.c
new file mode 100755
index 0000000..4c4fd4c
--- /dev/null
+++ b/src/apps/bst/api/get_bst_report.c
@@ -0,0 +1,247 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "get_bst_report.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_get_bst_report (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id, *json_includeIngressPortPriorityGroup, *json_includeIngressPortServicePool;
+    cJSON *json_includeIngressServicePool, *json_includeEgressPortServicePool, *json_includeEgressServicePool;
+    cJSON *json_includeEgressUcQueue, *json_includeEgressUcQueueGroup, *json_includeEgressMcQueue;
+    cJSON *json_includeEgressCpuQueue, *json_includeEgressRqeQueue, *json_includeDevice;
+    cJSON  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_GET_BST_REPORT_t command;
+
+    memset(&command, 0, sizeof (command));
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "get-bst-report" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "get-bst-report");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Parsing and Validating 'include-ingress-port-priority-group' from JSON buffer */
+    json_includeIngressPortPriorityGroup = cJSON_GetObjectItem(params, "include-ingress-port-priority-group");
+    JSON_VALIDATE_JSON_POINTER(json_includeIngressPortPriorityGroup, "include-ingress-port-priority-group", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeIngressPortPriorityGroup, "include-ingress-port-priority-group");
+    /* Copy the value */
+    command.includeIngressPortPriorityGroup = json_includeIngressPortPriorityGroup->valueint;
+    /* Ensure  that the number 'include-ingress-port-priority-group' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeIngressPortPriorityGroup, 0, 1);
+
+
+    /* Parsing and Validating 'include-ingress-port-service-pool' from JSON buffer */
+    json_includeIngressPortServicePool = cJSON_GetObjectItem(params, "include-ingress-port-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeIngressPortServicePool, "include-ingress-port-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeIngressPortServicePool, "include-ingress-port-service-pool");
+    /* Copy the value */
+    command.includeIngressPortServicePool = json_includeIngressPortServicePool->valueint;
+    /* Ensure  that the number 'include-ingress-port-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeIngressPortServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-ingress-service-pool' from JSON buffer */
+    json_includeIngressServicePool = cJSON_GetObjectItem(params, "include-ingress-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeIngressServicePool, "include-ingress-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeIngressServicePool, "include-ingress-service-pool");
+    /* Copy the value */
+    command.includeIngressServicePool = json_includeIngressServicePool->valueint;
+    /* Ensure  that the number 'include-ingress-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeIngressServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-port-service-pool' from JSON buffer */
+    json_includeEgressPortServicePool = cJSON_GetObjectItem(params, "include-egress-port-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressPortServicePool, "include-egress-port-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressPortServicePool, "include-egress-port-service-pool");
+    /* Copy the value */
+    command.includeEgressPortServicePool = json_includeEgressPortServicePool->valueint;
+    /* Ensure  that the number 'include-egress-port-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressPortServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-service-pool' from JSON buffer */
+    json_includeEgressServicePool = cJSON_GetObjectItem(params, "include-egress-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressServicePool, "include-egress-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressServicePool, "include-egress-service-pool");
+    /* Copy the value */
+    command.includeEgressServicePool = json_includeEgressServicePool->valueint;
+    /* Ensure  that the number 'include-egress-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-uc-queue' from JSON buffer */
+    json_includeEgressUcQueue = cJSON_GetObjectItem(params, "include-egress-uc-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressUcQueue, "include-egress-uc-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressUcQueue, "include-egress-uc-queue");
+    /* Copy the value */
+    command.includeEgressUcQueue = json_includeEgressUcQueue->valueint;
+    /* Ensure  that the number 'include-egress-uc-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressUcQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-uc-queue-group' from JSON buffer */
+    json_includeEgressUcQueueGroup = cJSON_GetObjectItem(params, "include-egress-uc-queue-group");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressUcQueueGroup, "include-egress-uc-queue-group", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressUcQueueGroup, "include-egress-uc-queue-group");
+    /* Copy the value */
+    command.includeEgressUcQueueGroup = json_includeEgressUcQueueGroup->valueint;
+    /* Ensure  that the number 'include-egress-uc-queue-group' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressUcQueueGroup, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-mc-queue' from JSON buffer */
+    json_includeEgressMcQueue = cJSON_GetObjectItem(params, "include-egress-mc-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressMcQueue, "include-egress-mc-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressMcQueue, "include-egress-mc-queue");
+    /* Copy the value */
+    command.includeEgressMcQueue = json_includeEgressMcQueue->valueint;
+    /* Ensure  that the number 'include-egress-mc-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressMcQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-cpu-queue' from JSON buffer */
+    json_includeEgressCpuQueue = cJSON_GetObjectItem(params, "include-egress-cpu-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressCpuQueue, "include-egress-cpu-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressCpuQueue, "include-egress-cpu-queue");
+    /* Copy the value */
+    command.includeEgressCpuQueue = json_includeEgressCpuQueue->valueint;
+    /* Ensure  that the number 'include-egress-cpu-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressCpuQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-rqe-queue' from JSON buffer */
+    json_includeEgressRqeQueue = cJSON_GetObjectItem(params, "include-egress-rqe-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressRqeQueue, "include-egress-rqe-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressRqeQueue, "include-egress-rqe-queue");
+    /* Copy the value */
+    command.includeEgressRqeQueue = json_includeEgressRqeQueue->valueint;
+    /* Ensure  that the number 'include-egress-rqe-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressRqeQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-device' from JSON buffer */
+    json_includeDevice = cJSON_GetObjectItem(params, "include-device");
+    JSON_VALIDATE_JSON_POINTER(json_includeDevice, "include-device", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeDevice, "include-device");
+    /* Copy the value */
+    command.includeDevice = json_includeDevice->valueint;
+    /* Ensure  that the number 'include-device' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeDevice, 0, 1);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_get_bst_report_impl (cookie, asicId, id,&command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/get_bst_report.h b/src/apps/bst/api/get_bst_report.h
new file mode 100755
index 0000000..ca204b5
--- /dev/null
+++ b/src/apps/bst/api/get_bst_report.h
@@ -0,0 +1,65 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_GET_BST_REPORT_H 
+#define	INCLUDE_GET_BST_REPORT_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_get_bst_report_
+{
+    int includeIngressPortPriorityGroup;
+    int includeIngressPortServicePool;
+    int includeIngressServicePool;
+    int includeEgressPortServicePool;
+    int includeEgressServicePool;
+    int includeEgressUcQueue;
+    int includeEgressUcQueueGroup;
+    int includeEgressMcQueue;
+    int includeEgressCpuQueue;
+    int includeEgressRqeQueue;
+    int includeDevice;
+} BSTJSON_GET_BST_REPORT_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_get_bst_report(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_get_bst_report_impl(void *cookie, int asicId, int id, BSTJSON_GET_BST_REPORT_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_GET_BST_REPORT_H */ 
+
diff --git a/src/apps/bst/api/get_bst_thresholds.c b/src/apps/bst/api/get_bst_thresholds.c
new file mode 100755
index 0000000..1403524
--- /dev/null
+++ b/src/apps/bst/api/get_bst_thresholds.c
@@ -0,0 +1,246 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "get_bst_thresholds.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_get_bst_thresholds (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id, *json_includeIngressPortPriorityGroup, *json_includeIngressPortServicePool;
+    cJSON *json_includeIngressServicePool, *json_includeEgressPortServicePool, *json_includeEgressServicePool;
+    cJSON *json_includeEgressUcQueue, *json_includeEgressUcQueueGroup, *json_includeEgressMcQueue;
+    cJSON *json_includeEgressCpuQueue, *json_includeEgressRqeQueue, *json_includeDevice;
+    cJSON  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_GET_BST_THRESHOLDS_t command;
+
+    memset(&command, 0, sizeof (command));
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "get-bst-thresholds" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "get-bst-thresholds");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Parsing and Validating 'include-ingress-port-priority-group' from JSON buffer */
+    json_includeIngressPortPriorityGroup = cJSON_GetObjectItem(params, "include-ingress-port-priority-group");
+    JSON_VALIDATE_JSON_POINTER(json_includeIngressPortPriorityGroup, "include-ingress-port-priority-group", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeIngressPortPriorityGroup, "include-ingress-port-priority-group");
+    /* Copy the value */
+    command.includeIngressPortPriorityGroup = json_includeIngressPortPriorityGroup->valueint;
+    /* Ensure  that the number 'include-ingress-port-priority-group' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeIngressPortPriorityGroup, 0, 1);
+
+
+    /* Parsing and Validating 'include-ingress-port-service-pool' from JSON buffer */
+    json_includeIngressPortServicePool = cJSON_GetObjectItem(params, "include-ingress-port-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeIngressPortServicePool, "include-ingress-port-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeIngressPortServicePool, "include-ingress-port-service-pool");
+    /* Copy the value */
+    command.includeIngressPortServicePool = json_includeIngressPortServicePool->valueint;
+    /* Ensure  that the number 'include-ingress-port-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeIngressPortServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-ingress-service-pool' from JSON buffer */
+    json_includeIngressServicePool = cJSON_GetObjectItem(params, "include-ingress-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeIngressServicePool, "include-ingress-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeIngressServicePool, "include-ingress-service-pool");
+    /* Copy the value */
+    command.includeIngressServicePool = json_includeIngressServicePool->valueint;
+    /* Ensure  that the number 'include-ingress-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeIngressServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-port-service-pool' from JSON buffer */
+    json_includeEgressPortServicePool = cJSON_GetObjectItem(params, "include-egress-port-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressPortServicePool, "include-egress-port-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressPortServicePool, "include-egress-port-service-pool");
+    /* Copy the value */
+    command.includeEgressPortServicePool = json_includeEgressPortServicePool->valueint;
+    /* Ensure  that the number 'include-egress-port-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressPortServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-service-pool' from JSON buffer */
+    json_includeEgressServicePool = cJSON_GetObjectItem(params, "include-egress-service-pool");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressServicePool, "include-egress-service-pool", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressServicePool, "include-egress-service-pool");
+    /* Copy the value */
+    command.includeEgressServicePool = json_includeEgressServicePool->valueint;
+    /* Ensure  that the number 'include-egress-service-pool' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressServicePool, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-uc-queue' from JSON buffer */
+    json_includeEgressUcQueue = cJSON_GetObjectItem(params, "include-egress-uc-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressUcQueue, "include-egress-uc-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressUcQueue, "include-egress-uc-queue");
+    /* Copy the value */
+    command.includeEgressUcQueue = json_includeEgressUcQueue->valueint;
+    /* Ensure  that the number 'include-egress-uc-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressUcQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-uc-queue-group' from JSON buffer */
+    json_includeEgressUcQueueGroup = cJSON_GetObjectItem(params, "include-egress-uc-queue-group");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressUcQueueGroup, "include-egress-uc-queue-group", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressUcQueueGroup, "include-egress-uc-queue-group");
+    /* Copy the value */
+    command.includeEgressUcQueueGroup = json_includeEgressUcQueueGroup->valueint;
+    /* Ensure  that the number 'include-egress-uc-queue-group' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressUcQueueGroup, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-mc-queue' from JSON buffer */
+    json_includeEgressMcQueue = cJSON_GetObjectItem(params, "include-egress-mc-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressMcQueue, "include-egress-mc-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressMcQueue, "include-egress-mc-queue");
+    /* Copy the value */
+    command.includeEgressMcQueue = json_includeEgressMcQueue->valueint;
+    /* Ensure  that the number 'include-egress-mc-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressMcQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-cpu-queue' from JSON buffer */
+    json_includeEgressCpuQueue = cJSON_GetObjectItem(params, "include-egress-cpu-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressCpuQueue, "include-egress-cpu-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressCpuQueue, "include-egress-cpu-queue");
+    /* Copy the value */
+    command.includeEgressCpuQueue = json_includeEgressCpuQueue->valueint;
+    /* Ensure  that the number 'include-egress-cpu-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressCpuQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-egress-rqe-queue' from JSON buffer */
+    json_includeEgressRqeQueue = cJSON_GetObjectItem(params, "include-egress-rqe-queue");
+    JSON_VALIDATE_JSON_POINTER(json_includeEgressRqeQueue, "include-egress-rqe-queue", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeEgressRqeQueue, "include-egress-rqe-queue");
+    /* Copy the value */
+    command.includeEgressRqeQueue = json_includeEgressRqeQueue->valueint;
+    /* Ensure  that the number 'include-egress-rqe-queue' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeEgressRqeQueue, 0, 1);
+
+
+    /* Parsing and Validating 'include-device' from JSON buffer */
+    json_includeDevice = cJSON_GetObjectItem(params, "include-device");
+    JSON_VALIDATE_JSON_POINTER(json_includeDevice, "include-device", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_includeDevice, "include-device");
+    /* Copy the value */
+    command.includeDevice = json_includeDevice->valueint;
+    /* Ensure  that the number 'include-device' is within range of [0,1] */
+    JSON_CHECK_VALUE_AND_CLEANUP (command.includeDevice, 0, 1);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_get_bst_thresholds_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/get_bst_thresholds.h b/src/apps/bst/api/get_bst_thresholds.h
new file mode 100755
index 0000000..3eb9bcc
--- /dev/null
+++ b/src/apps/bst/api/get_bst_thresholds.h
@@ -0,0 +1,65 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_GET_BST_THRESHOLDS_H 
+#define	INCLUDE_GET_BST_THRESHOLDS_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_get_bst_thresholds_
+{
+    int includeIngressPortPriorityGroup;
+    int includeIngressPortServicePool;
+    int includeIngressServicePool;
+    int includeEgressPortServicePool;
+    int includeEgressServicePool;
+    int includeEgressUcQueue;
+    int includeEgressUcQueueGroup;
+    int includeEgressMcQueue;
+    int includeEgressCpuQueue;
+    int includeEgressRqeQueue;
+    int includeDevice;
+} BSTJSON_GET_BST_THRESHOLDS_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_get_bst_thresholds(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_get_bst_thresholds_impl(void *cookie, int asicId, int id, BSTJSON_GET_BST_THRESHOLDS_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_GET_BST_THRESHOLDS_H */ 
+
diff --git a/src/apps/bst/api/get_bst_tracking.c b/src/apps/bst/api/get_bst_tracking.c
new file mode 100755
index 0000000..0c65307
--- /dev/null
+++ b/src/apps/bst/api/get_bst_tracking.c
@@ -0,0 +1,133 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "get_bst_tracking.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_get_bst_tracking (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id,  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_GET_BST_TRACKING_t command;
+
+    /*memset commented since the structure is empty*/
+    /* memset(&command, 0, sizeof (command));*/
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "get-bst-tracking" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "get-bst-tracking");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_get_bst_tracking_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/get_bst_tracking.h b/src/apps/bst/api/get_bst_tracking.h
new file mode 100755
index 0000000..9b713cf
--- /dev/null
+++ b/src/apps/bst/api/get_bst_tracking.h
@@ -0,0 +1,54 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_GET_BST_TRACKING_H 
+#define	INCLUDE_GET_BST_TRACKING_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_get_bst_tracking_
+{
+} BSTJSON_GET_BST_TRACKING_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_get_bst_tracking(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_get_bst_tracking_impl(void *cookie, int asicId, int id, BSTJSON_GET_BST_TRACKING_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_GET_BST_TRACKING_H */ 
+
diff --git a/src/apps/bst/api/get_switch_properties.c b/src/apps/bst/api/get_switch_properties.c
new file mode 100755
index 0000000..1f22372
--- /dev/null
+++ b/src/apps/bst/api/get_switch_properties.c
@@ -0,0 +1,134 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+#include "get_switch_properties.h"
+
+/******************************************************************
+ * @brief  REST API Handler (Generated Code)
+ *
+ * @param[in]    cookie     Context for the API from Web server
+ * @param[in]    jsonBuffer Raw Json Buffer
+ * @param[in]    bufLength  Json Buffer length (bytes)
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  JSON Parsed and parameters passed to BST APP
+ * @retval   BVIEW_STATUS_INVALID_JSON  JSON is malformatted, or doesn't 
+ * 					have necessary data.
+ * @retval   BVIEW_STATUS_INVALID_PARAMETER Invalid input parameter
+ *
+ * @note     See the _impl() function for info passing to BST APP
+ *********************************************************************/
+BVIEW_STATUS bstjson_get_switch_properties (void *cookie, char *jsonBuffer, int bufLength)
+{
+
+    /* Local Variables for JSON Parsing */
+    cJSON *json_jsonrpc, *json_method, *json_asicId;
+    cJSON *json_id,  *root, *params;
+
+    /* Local non-command-parameter JSON variable declarations */
+    char jsonrpc[JSON_MAX_NODE_LENGTH] = {0};
+    char method[JSON_MAX_NODE_LENGTH] = {0};
+    int asicId = 0, id = 0;
+
+    /* Local variable declarations */
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+    BSTJSON_GET_SWITCH_PROPERTIES_t command;
+
+    /*memset commented since the structure is empty*/
+    /* memset(&command, 0, sizeof (command));*/
+
+    /* Validating input parameters */
+
+    /* Validating 'cookie' */
+    JSON_VALIDATE_POINTER(cookie, "cookie", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'jsonBuffer' */
+    JSON_VALIDATE_POINTER(jsonBuffer, "jsonBuffer", BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Validating 'bufLength' */
+    if (bufLength > strlen(jsonBuffer))
+    {
+        _jsonlog("Invalid value for parameter bufLength %d ", bufLength );
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* Parse JSON to a C-JSON root */
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root, "root", BVIEW_STATUS_INVALID_JSON);
+
+    /* Obtain command parameters */
+    params = cJSON_GetObjectItem(root, "params");
+    JSON_VALIDATE_JSON_POINTER(params, "params", BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'jsonrpc' from JSON buffer */
+    json_jsonrpc = cJSON_GetObjectItem(root, "jsonrpc");
+    JSON_VALIDATE_JSON_POINTER(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_jsonrpc, "jsonrpc", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&jsonrpc[0], json_jsonrpc->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'jsonrpc' in the JSON equals "2.0" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("jsonrpc", &jsonrpc[0], "2.0");
+
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root, "method");
+    JSON_VALIDATE_JSON_POINTER(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method, "method", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the string, with a limit on max characters */
+    strncpy (&method[0], json_method->valuestring, JSON_MAX_NODE_LENGTH - 1);
+    /* Ensure that 'method' in the JSON equals "get-switch-properties" */
+    JSON_COMPARE_STRINGS_AND_CLEANUP ("method", &method[0], "get-switch-properties");
+
+
+    /* Parsing and Validating 'asic-id' from JSON buffer */
+    json_asicId = cJSON_GetObjectItem(root, "asic-id");
+    JSON_VALIDATE_JSON_POINTER(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_asicId, "asic-id", BVIEW_STATUS_INVALID_JSON);
+    /* Copy the 'asic-id' in external notation to our internal representation */
+    JSON_ASIC_ID_MAP_FROM_NOTATION(asicId, json_asicId->valuestring);
+
+
+    /* Parsing and Validating 'id' from JSON buffer */
+    json_id = cJSON_GetObjectItem(root, "id");
+    JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+    /* Copy the value */
+    id = json_id->valueint;
+    /* Ensure  that the number 'id' is within range of [1,100000] */
+    JSON_CHECK_VALUE_AND_CLEANUP (id, 1, 100000);
+
+
+    /* Send the 'command' along with 'asicId' and 'cookie' to the Application thread. */
+    status = bstjson_get_switch_properties_impl (cookie, asicId, id, &command);
+
+    /* Free up any allocated resources and return status code */
+    if (root != NULL)
+    {
+        cJSON_Delete(root);
+    }
+
+    return status;
+}
diff --git a/src/apps/bst/api/get_switch_properties.h b/src/apps/bst/api/get_switch_properties.h
new file mode 100755
index 0000000..13f31ac
--- /dev/null
+++ b/src/apps/bst/api/get_switch_properties.h
@@ -0,0 +1,54 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_GET_SWITCH_PROPERTIES_H 
+#define	INCLUDE_GET_SWITCH_PROPERTIES_H  
+
+#ifdef	__cplusplus  
+extern "C"
+{
+#endif  
+
+
+/* Include Header files */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "broadview.h"
+#include "json.h"
+
+#include "cJSON.h"
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _bstjson_get_switch_properties__
+{
+} BSTJSON_GET_SWITCH_PROPERTIES_t;
+
+
+/* Function Prototypes */
+BVIEW_STATUS bstjson_get_switch_properties(void *cookie, char *jsonBuffer, int bufLength);
+BVIEW_STATUS bstjson_get_switch_properties_impl(void *cookie, int asicId, int id, BSTJSON_GET_SWITCH_PROPERTIES_t *pCommand);
+
+
+#ifdef	__cplusplus  
+}
+#endif  
+
+#endif /* INCLUDE_GET_SWITCH_PROPERTIES_H */ 
+
diff --git a/src/apps/bst/bst.c b/src/apps/bst/bst.c
new file mode 100755
index 0000000..9742f8c
--- /dev/null
+++ b/src/apps/bst/bst.c
@@ -0,0 +1,982 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+#include <stdlib.h>
+#include <string.h>
+#include <sys/msg.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include "json.h"
+#include "bst_json_memory.h"
+#include "clear_bst_statistics.h"
+#include "clear_bst_thresholds.h"
+#include "configure_bst_thresholds.h"
+#include "configure_bst_feature.h"
+#include "configure_bst_tracking.h"
+#include "get_switch_properties.h"
+#include "get_bst_tracking.h"
+#include "get_bst_feature.h"
+#include "get_bst_thresholds.h"
+#include "get_bst_report.h"
+#include "bst_json_encoder.h"
+#include "bst.h"
+#include "broadview.h"
+#include "bst_app.h"
+#include "system.h"
+#include "openapps_log_api.h"
+#include "sbplugin_redirect_bst.h"
+#include "sbplugin_redirect_system.h" 
+
+BVIEW_BST_CXT_t bst_info;
+int recvMsgQid;
+
+static BVIEW_REST_API_t bst_cmd_api_list[] = {
+
+  {"configure-bst-tracking", bstjson_configure_bst_tracking},
+  {"configure-bst-feature", bstjson_configure_bst_feature},
+  {"configure-bst-thresholds", bstjson_configure_bst_thresholds},
+  {"get-bst-report", bstjson_get_bst_report},
+  {"get-bst-feature", bstjson_get_bst_feature},
+  {"get-bst-tracking", bstjson_get_bst_tracking},
+  {"get-bst-thresholds", bstjson_get_bst_thresholds},
+  {"clear-bst-thresholds", bstjson_clear_bst_thresholds},
+  {"clear-bst-statistics", bstjson_clear_bst_statistics},
+  {"get-switch-properties", bstjson_get_switch_properties}
+};
+/*********************************************************************
+* @brief : application function to configure the bst features
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : when the asic successfully programmed
+* @retval  : BVIEW_STATUS_FAILURE : when the asic is failed to programme.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+*
+* @note : This function is invoked in the bst context and used to 
+*         configure the parameters like
+*         -- bst enable
+*         -- asyncronous collection of reports
+*         -- configuring the collection interval
+*         -- option to configure the data in bytes or cells.
+*         In case of the underlying  api returns failure, the same error message
+*         is received  and sent to the invoking function.
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_feature_set (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_CONFIG_t bstMode;
+  BVIEW_BST_CONFIG_PARAMS_t *ptr;
+  bool timerUpdateReqd = false;
+  int tmpMask = 0;
+
+  /* check for the null of the input pointer */
+  if (NULL == msg_data)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  /* get the configuration structure pointer  for the desired unit */
+  ptr = BST_CONFIG_FEATURE_PTR_GET (msg_data->unit);
+  if (NULL == ptr)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+ 
+  BST_RWLOCK_WR_LOCK(msg_data->unit);
+  /* collection interval is maintained in seconds in application.
+      while adding the timer, the same should be converted into
+       milli seconds and added as the timer api expects 
+       interval in milli seconds. */ 
+  tmpMask = msg_data->request.config.configMask;
+
+  if (ptr->collectionInterval != msg_data->request.config.collectionInterval)
+  {
+    /* Collection interval has changed.
+       so need to register the modified interval with the timer */
+    ptr->collectionInterval = msg_data->request.config.collectionInterval;
+    timerUpdateReqd = true;
+  }
+
+  if ((tmpMask & (1 << BST_CONFIG_PARAMS_SND_SNAP_TGR)) &&
+      (ptr->sendSnapshotOnTrigger != msg_data->request.config.sendSnapshotOnTrigger))
+  {
+    ptr->sendSnapshotOnTrigger = msg_data->request.config.sendSnapshotOnTrigger;
+  }
+  
+  if ((tmpMask & (1 << BST_CONFIG_PARAMS_TGR_RATE_LIMIT)) &&
+       (ptr->bstMaxTriggers != msg_data->request.config.bstMaxTriggers))
+  {
+    ptr->bstMaxTriggers = msg_data->request.config.bstMaxTriggers;
+  }
+
+  if ((tmpMask & (1 << BST_CONFIG_PARAMS_TGR_RL_INTVL)) &&
+      (ptr->triggerTransmitInterval != msg_data->request.config.triggerTransmitInterval))
+  {
+    ptr->triggerTransmitInterval = msg_data->request.config.triggerTransmitInterval;
+  }
+
+  /* request is always the negation of the variable. Hence checking 
+     for equality. If same then change the variable */
+  if (tmpMask & (1 << BST_CONFIG_PARAMS_ASYNC_FULL_REP)) 
+  {
+    ptr->sendIncrementalReport = (msg_data->request.config.sendIncrementalReport == 0)?1:0;
+  }
+
+
+  if (true == msg_data->request.config.sendAsyncReports)
+  {
+    /* request contains sendAsyncReports = true */
+    if (true != ptr->sendAsyncReports)
+    {
+      /* old config is not enabled for sending async reports.
+        now it is enabled.. so need to register with timer*/
+      ptr->sendAsyncReports = true;
+      timerUpdateReqd = true;
+    }
+    /*
+       Register with the timer for periodic callbacks */
+    if (true == timerUpdateReqd)
+    {
+      bst_periodic_collection_timer_add (msg_data->unit);
+    }
+  }
+  else
+  {
+    ptr->sendAsyncReports = false;
+    /* Periodic report collection is turned off...
+       so no need for  the timer. 
+       delete the timer */
+    bst_periodic_collection_timer_delete (msg_data->unit);
+  }
+
+  if (ptr->statUnitsInCells != msg_data->request.config.statUnitsInCells)
+  {
+    /* Store the data is desired in bytes or cells */
+    ptr->statUnitsInCells = msg_data->request.config.statUnitsInCells;
+  }
+
+
+  if ((tmpMask & (1 << BST_CONFIG_PARAMS_STATS_IN_PERCENT)) &&
+      (ptr->statsInPercentage != msg_data->request.config.statsInPercentage))
+  {
+    /* Store the data is desired in percentage */
+    ptr->statsInPercentage = msg_data->request.config.statsInPercentage;
+  }
+
+
+  BST_RWLOCK_UNLOCK(msg_data->unit);
+  /* till now we have not checked if the same is enabled in h/w.
+      Now check if the bst is enabled in asic.. 
+     want to check from s/w .. but set can happen directly and get 
+     may be through this app.. so checking with asic only..*/
+  memset (&bstMode, 0, sizeof (BVIEW_BST_CONFIG_t));
+  rv = sbapi_bst_config_get (msg_data->unit, &bstMode);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    /* Why the h/w call has failed.. post the error with the error reason. */
+    LOG_POST (BVIEW_LOG_ERROR,
+        "Unable to extract the bst mode from asic. err: %d \r\n", rv);
+    return rv;
+  }
+ 
+   /* now check if the h/w is set to the same state as requested.
+      if not, then only program the asic.. else not required */
+
+  if (bstMode.enableStatsMonitoring == msg_data->request.config.bstEnable)
+  {
+    /* every thing is fine. both are in sync.. just return */
+    return rv;
+  }
+
+ /* Set the asic with the desired config to control bst */  
+  bstMode.enableStatsMonitoring = msg_data->request.config.bstEnable;
+  bstMode.enablePeriodicCollection = ptr->sendAsyncReports;
+  bstMode.collectionPeriod = ptr->collectionInterval;
+  rv = sbapi_bst_config_set (msg_data->unit, &bstMode);
+  if (BVIEW_STATUS_SUCCESS == rv)
+  {
+    /* asic is successfully programmed.. now update the config.. */
+    BST_RWLOCK_WR_LOCK(msg_data->unit);
+    ptr->bstEnable = msg_data->request.config.bstEnable;
+    BST_RWLOCK_UNLOCK(msg_data->unit);
+    LOG_POST (BVIEW_LOG_INFO,
+              "bst application: setting bst feature is successful for unit %d.\r\n", msg_data->unit);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : application function to get the bst features
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_SUCCESS : when the bst feature params is 
+*                                   retrieved successfully.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_feature_get (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_BST_CONFIG_PARAMS_t *ptr;
+
+
+  if (NULL == msg_data)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  ptr = BST_CONFIG_FEATURE_PTR_GET (msg_data->unit);
+  if (NULL == ptr)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+  return  BVIEW_STATUS_SUCCESS;
+}
+
+/* Track set and get apis */
+/*********************************************************************
+* @brief : application function to configure the bst tracking 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE : unable to set the bst tracking params
+* @retval  : BVIEW_STATUS_SUCCESS : successfully configured bst params.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_track_set (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_CONFIG_t bstMode;
+  BVIEW_BST_TRACK_PARAMS_t *ptr;
+  BVIEW_BST_CONFIG_PARAMS_t *config_ptr;
+  bool config_changed = false;
+  bool trackIngress = true;
+  bool trackEgress = true;
+  bool trackDevice = true;
+  int trackPeakStats = BVIEW_BST_MODE_CURRENT;
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+
+  ptr = BST_CONFIG_TRACK_PTR_GET (msg_data->unit);
+  config_ptr = BST_CONFIG_FEATURE_PTR_GET (msg_data->unit);
+
+   if ((NULL == ptr) || (NULL == config_ptr))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+   /* tracking for current or peak mode is changed.. mark the same */
+  if (ptr->trackPeakStats != msg_data->request.track.trackPeakStats)
+  {
+    config_changed = true;
+  }
+
+  if (ptr->trackIngressPortPriorityGroup != msg_data->request.track.trackIngressPortPriorityGroup)
+  {
+   /* tracking for ingress port pri grp has  changed.. mark the same */
+    config_changed = true;
+  }
+
+  if (ptr->trackIngressPortServicePool != msg_data->request.track.trackIngressPortServicePool)
+  {
+   /* tracking for ingress port service pool has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackIngressServicePool != msg_data->request.track.trackIngressServicePool)
+  {
+   /* tracking for ingress service pool has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackEgressPortServicePool != msg_data->request.track.trackEgressPortServicePool)
+  {
+   /* tracking for egress port service pool has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackEgressServicePool != msg_data->request.track.trackEgressServicePool)
+  {
+   /* tracking for egress service pool has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackEgressUcQueue != msg_data->request.track.trackEgressUcQueue)
+  {
+   /* tracking for egress unicat queue has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackEgressUcQueueGroup != msg_data->request.track.trackEgressUcQueueGroup)
+  {
+   /* tracking for egress unicast queuei grp has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackEgressMcQueue != msg_data->request.track.trackEgressMcQueue)
+  {
+   /* tracking for egress multicast queue has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackEgressCpuQueue != msg_data->request.track.trackEgressCpuQueue)
+  {
+   /* tracking for egress cpu queue has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackEgressRqeQueue != msg_data->request.track.trackEgressRqeQueue)
+  {
+   /* tracking for egress rqe queue has  changed */
+    config_changed = true;
+  }
+
+  if (ptr->trackDevice != msg_data->request.track.trackDevice)
+  {
+   /* tracking for global data  changed */
+    config_changed = true;
+  }
+
+  if (false == config_changed)
+  {
+    /*no config change. so just return. 
+      what ever is desired.. is already in place .. */
+    return rv;
+  }
+ /* request has additonal than what is currently there.
+    program the asic */
+  memset (&bstMode, 0, sizeof (BVIEW_BST_CONFIG_t));
+ 
+ if (true == msg_data->request.track.trackPeakStats)
+ {
+   trackPeakStats = BVIEW_BST_MODE_PEAK;
+ }
+ else
+ {
+   trackPeakStats = BVIEW_BST_MODE_CURRENT;
+ }
+  bstMode.enableStatsMonitoring = config_ptr->bstEnable;
+  bstMode.enableDeviceStatsMonitoring = trackDevice;
+  bstMode.enableIngressStatsMonitoring = trackIngress;
+  bstMode.enableEgressStatsMonitoring = trackEgress;
+  bstMode.mode = trackPeakStats;
+/* program the asic. */
+  rv = sbapi_bst_config_set (msg_data->unit, &bstMode);
+  if (BVIEW_STATUS_SUCCESS == rv)
+  {
+      /*successfully programed the asic. store the config */
+    *ptr = msg_data->request.track;
+    LOG_POST (BVIEW_LOG_INFO,
+              "bst application: setting bst tracking is successful"
+               " for unit %d.\r\n", msg_data->unit);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : application function to get the bst tracking 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_SUCCESS  : successfully retrieved the tracking params.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_track_get (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_TRACK_PARAMS_t *ptr;
+
+  if (NULL == msg_data)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  /* get the tracking config */
+  ptr = BST_CONFIG_TRACK_PTR_GET (msg_data->unit);
+
+  if (NULL == ptr)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief : application function to get switch properties
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid.
+* @retval  : BVIEW_STATUS_SUCCESS  : successfully retrieved the switch 
+*                                    properties.
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS system_switch_properties_get (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  if (NULL == msg_data)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief : application function to get the bst report and thresholds 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- report is successfully sent 
+* @retval  : BVIEW_STATUS_SUCCESS -- failed to get the report
+*
+* @note : based on the message type the report is retrieved.
+*
+*********************************************************************/
+BVIEW_STATUS bst_get_report (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_BST_REPORT_SNAPSHOT_t *ss;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_UNIT_CXT_t *ptr;
+  BVIEW_BST_TRACK_PARAMS_t *track_ptr;
+  BVIEW_BST_CONFIG_PARAMS_t *config_ptr;
+ 
+  if (NULL == msg_data)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  track_ptr = BST_CONFIG_TRACK_PTR_GET (msg_data->unit);
+  config_ptr = BST_CONFIG_FEATURE_PTR_GET (msg_data->unit);
+  ptr = BST_UNIT_PTR_GET (msg_data->unit);
+
+  if ((NULL == ptr) || (NULL == track_ptr) || (NULL == config_ptr))
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* request is to get the report.
+   */
+
+  if (((BVIEW_BST_STATS_PERIODIC == msg_data->report_type) ||
+        (BVIEW_BST_STATS_TRIGGER == msg_data->report_type)) &&
+      (NULL != track_ptr))
+  {
+    BVIEW_BST_STAT_COLLECT_CONFIG_t *pCollect = &msg_data->request.collect;
+
+    /* copy the track params to the collection request */
+    BST_COPY_TRACK_TO_COLLECT (track_ptr, 
+        pCollect);
+  }
+
+
+  if ((BVIEW_BST_CMD_API_GET_REPORT == msg_data->msg_type) ||
+      (BVIEW_BST_CMD_API_TRIGGER_REPORT == msg_data->msg_type))
+  {
+    /* collect data.. since the data is huge.. give the current record 
+       memory pointer directly so that we can avoid, copy */
+    BST_LOCK_TAKE (msg_data->unit);
+    ss = ptr->stats_current_record_ptr;
+    /* before we collect data..ensure there is no garbage.. 
+     */
+    memset (ss, 0,
+        sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+    rv = sbapi_bst_snapshot_get (msg_data->unit, &ss->snapshot_data, &ss->tv);
+    BST_LOCK_GIVE (msg_data->unit);
+
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      /* call failed..  log the reason code ..*/
+      LOG_POST (BVIEW_LOG_ERROR, "Failed to get bst stats, err %d \r\n", rv);
+      /* Since stats collection has failed.. no need to do the rest.
+         report the error to the calling function */
+    }
+
+    if (BVIEW_BST_CMD_API_TRIGGER_REPORT == msg_data->msg_type)
+    {
+    rv = bst_enable_on_trigger(msg_data, true);
+    }
+  }
+
+  /* request is to get the thresholds..
+   */
+  if (BVIEW_BST_CMD_API_GET_THRESHOLD == msg_data->msg_type)
+  {
+    /* here we need to take the lock, since we maintain only one record for
+       thresholds. assumption is that threshold get is called very sparingly,
+       where as report is quite often.. so one record is enough.. 
+       since we have single record, don't want a read while collecting the  information.
+       so protect the same */
+    BST_LOCK_TAKE (msg_data->unit);
+    /* make sure no garbage.. */
+    memset (&ptr->threshold_record_ptr->snapshot_data, 0, sizeof(BVIEW_BST_ASIC_SNAPSHOT_DATA_t));
+  
+    rv = sbapi_bst_threshold_get (msg_data->unit, &ptr->threshold_record_ptr->snapshot_data, 
+                                  &ptr->threshold_record_ptr->tv);
+    /* Release  the lock . */
+    BST_LOCK_GIVE (msg_data->unit);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      /* call failed..  log the reason code ..*/
+      LOG_POST (BVIEW_LOG_ERROR, "Failed to get bst stats, err %d \r\n", rv);
+      /* Since threshold get has failed.. no need to do the rest.
+         report the error to the calling function */
+    }
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : function to add timer for the periodic stats collection 
+*
+* @param[in] unit : unit for which the periodic stats need to be collected.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- failed to add the timer 
+* @retval  : BVIEW_STATUS_SUCCESS -- timer is successfully added 
+*
+* @note : this api adds the timer to the linux timer thread, so when the timer 
+*         expires, we receive the callback and post message to the bst application
+*         to collect the stats.. this is a periodic timer , whose interval
+*         is equal to the collection interval. Note that collection is per
+*         unit and hence we need per timer per unit.
+*
+*********************************************************************/
+BVIEW_STATUS bst_periodic_collection_timer_add (unsigned int  unit)
+{
+  BVIEW_BST_CONFIG_PARAMS_t *ptr;
+  BVIEW_BST_DATA_t *bst_data_ptr;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  bst_data_ptr = BST_UNIT_DATA_PTR_GET (unit);
+  ptr = BST_CONFIG_FEATURE_PTR_GET (unit);
+
+  if ((NULL == bst_data_ptr) || (NULL == ptr)) 
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* check if the timer node is already in use.
+  */
+  if (true == bst_data_ptr->bst_collection_timer.in_use)
+  {
+    /* the timer is in use. The requester has asked
+       to add the timer again.. Remove the old entru
+       and add it again.. Reasosn could be that config
+       interval would have been changed, In such case,
+       delete the one with previous collection timer 
+       interval and add the new one */
+    rv =  bst_periodic_collection_timer_delete(unit);
+    if (BVIEW_STATUS_SUCCESS != rv)
+  {
+      /* timer node add has failed. log the same */
+      LOG_POST (BVIEW_LOG_ERROR, 
+          "%s Failed to delete periodic collection time for unit %d, err %d \r\n", __func__, unit, rv);
+    }
+  }
+
+  /* The timer add function expects the time in milli seconds..
+     so convert the time into milli seconds. , before adding
+     the timer node */
+    rv =  system_timer_add (bst_periodic_collection_cb,
+                  &bst_data_ptr->bst_collection_timer.bstTimer,
+                  ptr->collectionInterval*BVIEW_BST_TIME_CONVERSION_FACTOR,
+                  PERIODIC_MODE, &bst_data_ptr->bst_collection_timer.unit);
+
+    if (BVIEW_STATUS_SUCCESS == rv)
+    {
+      bst_data_ptr->bst_collection_timer.in_use = true;
+       LOG_POST (BVIEW_LOG_INFO,
+              "bst application: timer is successfully started for unit %d.\r\n", unit);
+    }
+    else
+    {
+      /* timer node add has failed. log the same */
+      LOG_POST (BVIEW_LOG_ERROR, 
+         "Failed to add periodic collection time for unit %d, err %d \r\n", unit, rv);
+    }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : Deletes the timer node for the given unit
+*
+* @param[in] unit : unit id for which  the timer needs to be deleted.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- timer is successfully deleted 
+* @retval  : BVIEW_STATUS_SUCCESS -- failed to delete the timer 
+*
+* @note  : The periodic timer is deleted when send asyncronous reporting
+*          is turned off. This timer is per unit.
+*
+*********************************************************************/
+BVIEW_STATUS bst_periodic_collection_timer_delete (int unit)
+{
+  BVIEW_BST_DATA_t *bst_data_ptr;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  bst_data_ptr = BST_UNIT_DATA_PTR_GET (unit);
+
+  if (NULL == bst_data_ptr)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  if (true == bst_data_ptr->bst_collection_timer.in_use)
+  {
+    rv = system_timer_delete (bst_data_ptr->bst_collection_timer.bstTimer);
+    if (BVIEW_STATUS_SUCCESS == rv)
+    {
+      bst_data_ptr->bst_collection_timer.in_use = false;
+        LOG_POST (BVIEW_LOG_INFO,
+              "bst application: successfully deleted timer for unit %d , timer id %d.\r\n", unit, bst_data_ptr->bst_collection_timer.bstTimer);
+    }
+    else
+    {
+      /* timer node add has failed. log the same */
+      LOG_POST (BVIEW_LOG_ERROR, 
+           "Failed to delete periodic collection time for unit %d, err %d \r\n", unit, rv);
+    }
+  }
+  
+  return rv;
+}
+
+/*********************************************************************
+* @brief : set the threshold for the given realm.
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS - threshold is set successfully
+* @retval  : BVIEW_STATUS_FAILURE - failed to apply the inputted threshold
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : In case of any threshold set fail, the error is logged
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_threshold_set (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  switch (msg_data->threshold_type)
+  {
+    /* configure global threshold */
+    case BVIEW_BST_DEVICE_THRESHOLD:
+      rv =
+        sbapi_bst_device_threshold_set (msg_data->unit,
+            &msg_data->request.device_threshold);
+      break;
+
+    case BVIEW_BST_INGRESS_PORT_PG_THRESHOLD:
+         /* configure ingress port pg threshold */
+      rv = sbapi_bst_ippg_threshold_set (msg_data->unit,
+          msg_data->threshold.port,
+          msg_data->threshold.priorityGroup,
+          &msg_data->request.
+          i_p_pg_threshold);
+      break;
+
+    case BVIEW_BST_INGRESS_PORT_SP_THRESHOLD:
+         /* configure ingress port + sp threshold */
+      rv = sbapi_bst_ipsp_threshold_set (msg_data->unit,
+          msg_data->threshold.port,
+          msg_data->threshold.servicePool,
+          &msg_data->request.
+          i_p_sp_threshold);
+      break;
+
+    case BVIEW_BST_INGRESS_SP_THRESHOLD:
+         /* configure ingress  sp threshold */
+      rv = sbapi_bst_isp_threshold_set (msg_data->unit,
+          msg_data->threshold.servicePool,
+          &msg_data->request.
+          i_sp_threshold);
+      break;
+
+    case BVIEW_BST_EGRESS_PORT_SP_THRESHOLD:
+         /* configure egress port+ sp threshold */
+      rv = sbapi_bst_epsp_threshold_set (msg_data->unit,
+          msg_data->threshold.port,
+          msg_data->threshold.servicePool,
+          &msg_data->request.
+          ep_sp_threshold);
+      break;
+
+    case BVIEW_BST_EGRESS_SP_THRESHOLD:
+         /* configure egress sp threshold */
+      rv = sbapi_bst_esp_threshold_set (msg_data->unit,
+          msg_data->threshold.servicePool,
+          &msg_data->request.
+          e_sp_threshold);
+      break;
+
+    case BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD:
+         /* configure egress unicast queue threshold */
+      rv = sbapi_bst_eucq_threshold_set (msg_data->unit,
+          msg_data->threshold.queue,
+          &msg_data->request.
+          e_ucq_threshold);
+      break;
+
+    case BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD:
+         /* configure egress unicast queuegrp threshold */
+      rv = sbapi_bst_eucqg_threshold_set (msg_data->unit,
+          msg_data->threshold.queueGroup,
+          &msg_data->request.
+          e_ucqg_threshold);
+      break;
+
+    case BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD:
+         /* configure egress mcast queue threshold */
+      rv = sbapi_bst_emcq_threshold_set (msg_data->unit,
+          msg_data->threshold.queue,
+          &msg_data->request.
+          e_mcq_threshold);
+      break;
+
+    case BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD:
+         /* configure egress cpu queue threshold */
+      rv = sbapi_bst_cpuq_threshold_set (msg_data->unit,
+          msg_data->threshold.queue,
+          &msg_data->request.
+          cpu_q_threshold);
+      break;
+
+    case BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD:
+         /* configure egress rqe queue threshold */
+      rv = sbapi_bst_rqeq_threshold_set (msg_data->unit,
+          msg_data->threshold.queue,
+          &msg_data->request.
+          rqe_q_threshold);
+      break;
+
+    default:
+      break;
+  }
+
+ /* check if the threshold set is successful */ 
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      _BST_LOG(_BST_DEBUG_ERROR,"threshold set failed for the threshold type. %d, err %d \r\n",msg_data->threshold_type, rv); 
+      LOG_POST (BVIEW_LOG_ERROR, 
+         "threshold set failed for the threshold type. %d, err %d \r\n", 
+          msg_data->threshold_type, rv);
+    }
+    else
+    {
+     _BST_LOG(_BST_DEBUG_TRACE,   
+         "threshold set successful for the threshold type. %d\r\n", 
+          msg_data->threshold_type);
+      LOG_POST (BVIEW_LOG_INFO, 
+         "threshold set successful for the threshold type. %d\r\n", 
+          msg_data->threshold_type);
+    }
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief : function to clear the threshold set
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the threshold values
+* @retval  : BVIEW_STATUS_FAILURE : The clearing of thresholds has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note : 
+*
+*********************************************************************/
+BVIEW_STATUS bst_clear_threshold_set (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_UNIT_CXT_t *ptr;
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  ptr = BST_UNIT_PTR_GET (msg_data->unit);
+
+  rv = sbapi_bst_clear_thresholds (msg_data->unit);
+  if (BVIEW_STATUS_SUCCESS == rv)
+  {
+    BST_LOCK_TAKE (msg_data->unit);
+    /* threshold clear is successful.. clear the record as well */
+    memset (ptr->threshold_record_ptr, 0, 
+        sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+    BST_LOCK_GIVE (msg_data->unit);
+
+      LOG_POST (BVIEW_LOG_INFO, 
+           "threshold clear successful for the unit. %d \r\n", 
+            msg_data->unit);
+  }
+  else
+  {
+    /* log why the clear failed ..*/
+      LOG_POST (BVIEW_LOG_ERROR, 
+           "threshold clear failed for the unit. %d, err %d \r\n", 
+            msg_data->unit, rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : clear the stats
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the stats values
+* @retval  : BVIEW_STATUS_FAILURE : The clearing of stats has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_clear_stats_set (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_UNIT_CXT_t *ptr;
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  ptr = BST_UNIT_PTR_GET (msg_data->unit);
+  /* take the lock */
+  BST_LOCK_TAKE (msg_data->unit);
+  /* stats clear  */
+  memset (ptr->stats_backup_record_ptr, 0,
+      sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+  memset (ptr->stats_active_record_ptr, 0,
+      sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+  memset (ptr->stats_current_record_ptr, 0,
+      sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+  /* release the lock */
+  BST_LOCK_GIVE (msg_data->unit);
+
+  /* clear in asic as well*/
+
+  rv = sbapi_bst_clear_stats (msg_data->unit);
+  if (BVIEW_STATUS_SUCCESS != rv)
+    /* log why the stats clear failed ..*/
+    LOG_POST (BVIEW_LOG_ERROR, 
+        "stats clear failed for the unit. %d, err %d \r\n", msg_data->unit, rv);
+  return rv;
+}
+
+/*********************************************************************
+* @brief : copies the h/w retrevied to the current record.
+*
+* @param[in] type : Type of the record , i.e. stats or threshold
+* @param[in] unit : unit number for which the data is collected.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully updates the records
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note : Once the collection of the stats is completeed, the existing active
+*        record becomes back up. The newly collected record become the new active
+*        record. Make sure to take the lock while updating..
+*
+*********************************************************************/
+BVIEW_STATUS bst_update_data (BVIEW_BST_REPORT_TYPE_t type, unsigned int unit)
+{
+  BVIEW_BST_UNIT_CXT_t *ptr;
+  BVIEW_BST_REPORT_SNAPSHOT_t *temp;
+
+  ptr = BST_UNIT_PTR_GET (unit);
+
+  switch (type)
+  {
+  case BVIEW_BST_STATS:
+    BST_LOCK_TAKE (unit);
+    /* take the lock */
+    /* copy the backup pointer in a temporary variable */
+    temp = ptr->stats_backup_record_ptr;
+    /* make the active  as backup */
+    ptr->stats_backup_record_ptr = ptr->stats_active_record_ptr;
+
+    /* make the current as active */
+    ptr->stats_active_record_ptr = ptr->stats_current_record_ptr;
+    /* now make the old backup as current */
+    ptr->stats_current_record_ptr = temp;
+    /* release the lock */
+    BST_LOCK_GIVE (unit);
+    break;
+
+  default:
+    break;
+  }
+
+  /* log an information that the records are updated */
+      LOG_POST (BVIEW_LOG_INFO, 
+           "stat records are updated \r\n"); 
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief :  function to register with module mgr
+*
+* @param[in] : none 
+* 
+* @retval  : BVIEW_STATUS_SUCCESS : registration of BST with module manager is successful.
+* @retval  : BVIEW_STATUS_FAILURE : BST failed to register with module manager.
+*
+* @note : BST need to register with module manager for the below purpose.
+*         When the REST API is invoked, rest queries the module manager for
+*         the suitable function api  for the corresponding request. Once the
+*         api is retieved , posts the request using the retrieved api.
+*         for this bst need to register with module mgr.
+*
+* @end
+*********************************************************************/
+BVIEW_STATUS bst_module_register ()
+{
+  BVIEW_MODULE_FETAURE_INFO_t bstInfo;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  memset (&bstInfo, 0, sizeof (BVIEW_MODULE_FETAURE_INFO_t));
+
+  bstInfo.featureId = BVIEW_FEATURE_BST;
+  memcpy (bstInfo.restApiList, bst_cmd_api_list,
+          sizeof(bst_cmd_api_list));
+
+  /* Register with module manager. */
+  rv = modulemgr_register (&bstInfo);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+              "bst application failed to register with module mgr\r\n");
+  }
+  else
+  {
+      LOG_POST (BVIEW_LOG_INFO, 
+           "module mgr registration for bst successful \r\n"); 
+  }
+  return rv;
+}
+
+
+
diff --git a/src/apps/bst/bst_app.h b/src/apps/bst/bst_app.h
new file mode 100755
index 0000000..c28058d
--- /dev/null
+++ b/src/apps/bst/bst_app.h
@@ -0,0 +1,1019 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_BST_APP_H
+#define INCLUDE_BST_APP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdbool.h>
+#include <time.h>
+#include <signal.h>
+#include "modulemgr.h"
+
+
+#define MSG_QUEUE_ID_TO_BST  0x100
+#define MSG_QUEUE_ID_TO_BST_TRIGGER  0x108
+
+
+#define _BST_DEBUG
+#define _BST_DEBUG_LEVEL        0x00 
+
+#define _BST_DEBUG_TRACE        (0x1)
+#define _BST_DEBUG_INFO         (0x01 << 1)
+#define _BST_DEBUG_ERROR        (0x01 << 2)
+#define _BST_DEBUG_ALL          (0xFF)
+
+#ifdef _BST_DEBUG
+#define _BST_LOG(level, format,args...)   do { \
+              if ((level) & _BST_DEBUG_LEVEL) { \
+                                printf(format, ##args); \
+                            } \
+          }while(0)
+#else
+#define _BST_LOG(level, format,args...)
+#endif
+
+
+/* Default values for BST configurations */
+  /* bst enable */
+#define BVIEW_BST_DEFAULT_ENABLE    false  
+
+#define BVIEW_BST_PERIODIC_REPORT_DEFAULT false
+  /* default bst collection interval.
+     */
+#define BVIEW_BST_DEFAULT_INTERVAL  60
+#define BVIEW_BST_DEFAULT_STATS_UNITS  true
+#define BVIEW_BST_DEFAULT_STATS_PERCENTAGE false 
+#define BVIEW_BST_DEFAULT_TRACK_INGRESS   true
+#define BVIEW_BST_DEFAULT_TRACK_EGRESS    true
+#define BVIEW_BST_DEFAULT_TRACK_DEVICE    true
+
+#define BVIEW_BST_DEFAULT_TRACK_IN_P_PG      true
+#define BVIEW_BST_DEFAULT_TRACK_IN_P_SP      true
+#define BVIEW_BST_DEFAULT_TRACK_IN_SP        true
+#define BVIEW_BST_DEFAULT_TRACK_E_P_SP       true
+#define BVIEW_BST_DEFAULT_TRACK_E_SP         true
+#define BVIEW_BST_DEFAULT_TRACK_E_UC_Q       true
+#define BVIEW_BST_DEFAULT_TRACK_E_UC_QG      true
+#define BVIEW_BST_DEFAULT_TRACK_E_MC_Q       true
+#define BVIEW_BST_DEFAULT_TRACK_E_CPU_Q      true
+#define BVIEW_BST_DEFAULT_TRACK_E_RQE_Q      true
+#define BVIEW_BST_DEFAULT_TRACK_MODE         BVIEW_BST_MODE_CURRENT
+
+#define BVIEW_BST_DEFAULT_MAX_TRIGGERS 1
+#define BVIEW_BST_DEFAULT_SNAPSHOT_TRIGGER true 
+#define BVIEW_BST_DEFAULT_TRIGGER_INTERVAL 1 
+#define BVIEW_BST_DEFAULT_SEND_INCR_REPORT  1 
+#define BVIEW_BST_MAX_UNITS 8
+#define BVIEW_BST_TIME_CONVERSION_FACTOR 1000
+
+/* Maximum number of failed Receive messages */
+#define BVIEW_BST_MAX_QUEUE_SEND_FAILS      10
+
+typedef BSTJSON_CONFIGURE_BST_TRACKING_t  BVIEW_BST_TRACK_PARAMS_t;
+typedef BSTJSON_CONFIGURE_BST_FEATURE_t   BVIEW_BST_CONFIG_PARAMS_t;
+typedef BSTJSON_REPORT_OPTIONS_t          BVIEW_BST_REPORT_OPTIONS_t;
+typedef BSTJSON_GET_BST_REPORT_t          BVIEW_BST_STAT_COLLECT_CONFIG_t;
+typedef BSTJSON_CONFIGURE_BST_THRESHOLDS_t BVIEW_BST_THRESHOLD_CONFIG_t;
+
+
+typedef enum _bst_report_type_ {
+  BVIEW_BST_STATS = 1,
+  BVIEW_BST_THRESHOLD,
+  BVIEW_BST_STATS_PERIODIC,
+  BVIEW_BST_STATS_TRIGGER
+}BVIEW_BST_REPORT_TYPE_t;
+
+/* threshold types */
+typedef enum _bst_threshold_realm_ {
+  BVIEW_BST_DEVICE_THRESHOLD = 1,
+  BVIEW_BST_EGRESS_PORT_SP_THRESHOLD,
+  BVIEW_BST_EGRESS_SP_THRESHOLD,
+  BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD,
+  BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD,
+  BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD,
+  BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD,
+  BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD,
+  BVIEW_BST_INGRESS_PORT_PG_THRESHOLD,
+  BVIEW_BST_INGRESS_PORT_SP_THRESHOLD,
+  BVIEW_BST_INGRESS_SP_THRESHOLD
+}BVIEW_BST_THRESHOLD_TYPE_t;
+
+
+typedef enum _bst_trigger_index_ {
+  BST_ID_DEVICE = 0,
+  BST_ID_ING_POOL,
+  BST_ID_PORT_POOL,
+  BST_ID_PRI_GROUP_SHARED, 
+  BST_ID_PRI_GROUP_HEADROOM,
+  BST_ID_EGR_POOL,
+  BST_ID_EGR_MCAST_POOL, 
+  BST_ID_UCAST, 
+  BST_ID_MCAST,
+  BST_ID_EGR_UCAST_PORT_SHARED,
+  BST_ID_EGR_PORT_SHARED, 
+  BST_ID_RQE_QUEUE, 
+  BST_ID_UCAST_GROUP, 
+  BST_ID_MAX
+}BST_TRIGGER_INDEX_t;
+
+
+#define BVIEW_BST_MAX_THRESHOLD_TYPE_MIN BVIEW_BST_DEVICE_THRESHOLD
+#define BVIEW_BST_MAX_THRESHOLD_TYPE_MAX BVIEW_BST_INGRESS_SP_THRESHOLD
+
+/* structure to map realm to threshold type */
+typedef struct _bst_realm_to_threshold_ {
+  /* realm string */
+  char *realm;
+  /* threshold  type*/
+  BVIEW_BST_THRESHOLD_TYPE_t threshold;
+}BVIEW_BST_REALM_THRESHOLD_t;
+
+
+/* structure to map the trigger index to realm and counter */
+typedef struct _bst_trigger_realm_map_ {
+    BST_TRIGGER_INDEX_t index;
+    char *realm;
+    char *counter;
+}BST_REALM_COUNTER_INDEX_t;
+/* BST command enums */
+typedef enum _bst_cmd_ {
+  /* Set group */
+  BVIEW_BST_CMD_API_SET_TRACK = 1,
+  BVIEW_BST_CMD_API_SET_FEATURE,
+  BVIEW_BST_CMD_API_SET_THRESHOLD,
+  BVIEW_BST_CMD_API_CLEAR_THRESHOLD,
+  BVIEW_BST_CMD_API_CLEAR_STATS,
+  /* get group */
+  BVIEW_BST_CMD_API_GET_REPORT,
+  BVIEW_BST_CMD_API_GET_FEATURE,
+  BVIEW_BST_CMD_API_GET_TRACK,
+  BVIEW_BST_CMD_API_GET_THRESHOLD,
+  BVIEW_BST_CMD_API_TRIGGER_REPORT,
+  BVIEW_BST_CMD_API_CLEAR_TRIGGER_COUNT,
+  BVIEW_BST_CMD_API_ENABLE_BST_ON_TRIGGER,
+  BVIEW_BST_CMD_API_TRIGGER_COLLECT,
+   /*  Switch Properties */
+  BVIEW_BST_CMD_API_GET_SWITCH_PROPERTIES,
+  BVIEW_BST_CMD_API_MAX
+}BVIEW_FEATURE_BST_CMD_API_t;
+
+#define BST_MAX_REST_API  BVIEW_BST_CMD_API_GET_SWITCH_PROPERTIES
+
+ /* structures to hold the bst related params */
+  typedef struct bst_config {
+    BVIEW_BST_TRACK_PARAMS_t  track;
+    BVIEW_BST_CONFIG_PARAMS_t config;
+  } BVIEW_BST_CFG_PARAMS_t;
+
+  typedef struct _bst_report_snapshot_data_ {
+    BVIEW_TIME_t tv;
+    BVIEW_BST_ASIC_SNAPSHOT_DATA_t snapshot_data;
+  }BVIEW_BST_REPORT_SNAPSHOT_t;
+
+  typedef struct _bst_report_respose_ {
+    BVIEW_BST_REPORT_SNAPSHOT_t *active;
+    BVIEW_BST_REPORT_SNAPSHOT_t *backup;
+  }BVIEW_BST_REPORT_RESP_t;
+
+  typedef struct _bst_request_msg_ {
+    long msg_type; /* message type */
+    int unit; /* variable to hold the asic type */
+    void *cookie;
+    int id; /* id passed from the request */
+    int version; /* json version */
+    BVIEW_BST_REPORT_TYPE_t report_type; 
+    char realm[JSON_MAX_NODE_LENGTH];
+    unsigned int threshold_type;
+    BVIEW_BST_THRESHOLD_CONFIG_t threshold;
+     /* trigger info */
+     BVIEW_BST_TRIGGER_INFO_t triggerInfo;
+    union
+    {
+      /* feature params */
+      BVIEW_BST_CONFIG_PARAMS_t config;
+      /* params configured to track */
+      BVIEW_BST_TRACK_PARAMS_t  track;
+      /* params requsted to collect in report */
+      BVIEW_BST_STAT_COLLECT_CONFIG_t   collect;
+      /* params to config threshold */
+      BVIEW_BST_DEVICE_THRESHOLD_t                       device_threshold;
+      BVIEW_BST_INGRESS_PORT_PG_THRESHOLD_t              i_p_pg_threshold;
+      BVIEW_BST_INGRESS_PORT_SP_THRESHOLD_t              i_p_sp_threshold;
+      BVIEW_BST_INGRESS_SP_THRESHOLD_t                   i_sp_threshold;
+      BVIEW_BST_EGRESS_PORT_SP_THRESHOLD_t               ep_sp_threshold;
+      BVIEW_BST_EGRESS_SP_THRESHOLD_t                    e_sp_threshold;
+      BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD_t              e_ucq_threshold;
+      BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD_t        e_ucqg_threshold;
+      BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD_t              e_mcq_threshold;
+      BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD_t             cpu_q_threshold;
+      BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_t             rqe_q_threshold;
+
+
+    }request;
+  }BVIEW_BST_REQUEST_MSG_t;
+
+
+  typedef struct _bst_response_msg_ {
+    long msg_type;
+    int unit;
+    void *cookie;
+    int id;
+    BVIEW_BST_REPORT_TYPE_t report_type; 
+    BVIEW_ASIC_CAPABILITIES_t  *asic_capabilities;
+    BVIEW_BST_REPORT_OPTIONS_t options;
+    BVIEW_SWITCH_PROPERTIES_t  *switchProperties;
+    BVIEW_STATUS rv; /* return value for set request */
+    union
+    {
+      BVIEW_BST_CONFIG_PARAMS_t *config;
+      BVIEW_BST_TRACK_PARAMS_t  *track;
+      BVIEW_BST_REPORT_RESP_t   report;
+    }response;
+  }BVIEW_BST_RESPONSE_MSG_t;
+
+  typedef struct _bst_timer_s_ {
+    unsigned int unit;
+    bool in_use;
+    timer_t bstTimer;
+  }BVIEW_BST_TIMER_t;
+
+  typedef struct _bst_data_ {
+    BVIEW_BST_TIMER_t bst_collection_timer;
+    BVIEW_BST_TIMER_t bst_trigger_timer;
+    BVIEW_BST_CFG_PARAMS_t bst_config;
+    BVIEW_BST_STAT_COLLECT_CONFIG_t  bst_stats_config;
+  } BVIEW_BST_DATA_t;
+
+
+typedef struct _bst_context_unit_info__
+{
+  /* stats records */
+  BVIEW_BST_REPORT_SNAPSHOT_t *stats_active_record_ptr;
+  BVIEW_BST_REPORT_SNAPSHOT_t *stats_backup_record_ptr;
+  BVIEW_BST_REPORT_SNAPSHOT_t *stats_current_record_ptr;
+  /* threshold records */
+  BVIEW_BST_REPORT_SNAPSHOT_t *threshold_record_ptr;
+
+  /* place holder to store the default bst buffer settings */
+  BVIEW_BST_ASIC_SNAPSHOT_DATA_t bst_defaults;
+
+  /* config data */
+  BVIEW_BST_DATA_t *bst_data;
+  /* lock for this unit */
+  pthread_mutex_t bst_mutex;
+
+  /* Read-Write lock for config local data */
+  pthread_rwlock_t bst_configRWLock;
+
+
+  /* asic capabilities */
+  BVIEW_ASIC_CAPABILITIES_t asic_capabilities;
+
+  /* trigger callback cookie */
+  int cb_cookie;
+  unsigned int bst_trigger_count[BST_ID_MAX];
+
+} BVIEW_BST_UNIT_CXT_t;
+
+
+typedef struct _bst_context_info__
+{
+  BVIEW_BST_UNIT_CXT_t unit[BVIEW_BST_MAX_UNITS];
+  /* Switch Properties*/
+  BVIEW_SWITCH_PROPERTIES_t  *switchProperties;
+  
+  /* BST Key to Queue Message*/
+  key_t key1;
+  key_t trigger_key;
+  /* message queue id for bst */
+  int recvMsgQid;
+  int recvTriggerMsgQid;
+    /* pthread ID*/
+  pthread_t bst_thread;
+  pthread_t bst_trigger_thread;
+} BVIEW_BST_CXT_t;
+
+
+typedef BVIEW_STATUS(*BVIEW_BST_API_HANDLER_t) (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+
+/** Definition of an BST API */
+typedef struct _feature_bst_api_
+{
+  /** bst command */
+  int bst_command;
+  /** Handler associated with the corresponding bst command */
+  BVIEW_BST_API_HANDLER_t    handler;
+}BVIEW_BST_API_t;
+
+
+
+
+
+
+#define BST_CONFIG_PTR_GET(id)  &bst_info.unit[id].bst_data->bst_config
+#define BST_CONFIG_FEATURE_PTR_GET(id)  &bst_info.unit[id].bst_data->bst_config.config
+#define BST_CONFIG_TRACK_PTR_GET(id)  &bst_info.unit[id].bst_data->bst_config.track
+#define BST_UNIT_DATA_PTR_GET(id)    bst_info.unit[id].bst_data
+#define BST_UNIT_PTR_GET(id)    &bst_info.unit[id]
+
+
+
+/* Macro to acquire lock */
+#define BST_LOCK_TAKE(_unit)                                                        \
+        {                                                                           \
+           BVIEW_BST_UNIT_CXT_t *_ptr;                                              \
+           _ptr = BST_UNIT_PTR_GET (_unit);                                         \
+           if (0 != pthread_mutex_lock (&_ptr->bst_mutex))                          \
+           {                                                                        \
+              LOG_POST (BVIEW_LOG_ERROR,                                            \
+                  "Failed to take the lock for unit %d.\r\n",_unit);                \
+              return BVIEW_STATUS_FAILURE;                                          \
+           }                                                                        \
+         }
+/*  to release lock*/
+#define BST_LOCK_GIVE(_unit)                                                        \
+         {                                                                          \
+           BVIEW_BST_UNIT_CXT_t *_ptr;                                              \
+           _ptr = BST_UNIT_PTR_GET (_unit);                                         \
+           if (0 != pthread_mutex_unlock(&_ptr->bst_mutex))                         \
+           {                                                                        \
+              LOG_POST (BVIEW_LOG_ERROR,                                            \
+              "Failed to Release the lock for unit %d.\r\n",_unit);                 \
+               return BVIEW_STATUS_FAILURE;                                         \
+            }                                                                       \
+          }
+
+
+
+/* Macro to acquire read lock */
+#define BST_RWLOCK_RD_LOCK(_unit)                             \
+{                                                                          \
+  BVIEW_BST_UNIT_CXT_t *_ptr;                                              \
+_ptr = BST_UNIT_PTR_GET (_unit);                                         \
+  if (pthread_rwlock_rdlock(&_ptr->bst_configRWLock) != 0)                    \
+  {                                                         \
+    LOG_POST (BVIEW_LOG_ERROR,                                            \
+        "Failed to take the rw lock for unit %d.\r\n",_unit);                 \
+    return BVIEW_STATUS_FAILURE;                                         \
+  }                                                                       \
+}
+
+
+/* Macro to acquire write lock */
+#define BST_RWLOCK_WR_LOCK(_unit)                             \
+{                                                                          \
+  BVIEW_BST_UNIT_CXT_t *_ptr;                                              \
+  _ptr = BST_UNIT_PTR_GET (_unit);                                         \
+  if (pthread_rwlock_wrlock(&_ptr->bst_configRWLock) != 0)                    \
+  {                                                         \
+    LOG_POST (BVIEW_LOG_ERROR,                                            \
+        "Failed to take the write lock for unit %d.\r\n",_unit);                 \
+    return BVIEW_STATUS_FAILURE;                          \
+  }                                                                       \
+}
+
+/* Macro to release RW lock */
+#define BST_RWLOCK_UNLOCK(_unit)                              \
+{                                                                          \
+  BVIEW_BST_UNIT_CXT_t *_ptr;                                              \
+  _ptr = BST_UNIT_PTR_GET (_unit);                                         \
+  if (pthread_rwlock_unlock(&_ptr->bst_configRWLock) != 0)                    \
+  {                                                         \
+    LOG_POST (BVIEW_LOG_ERROR,                                            \
+        "Failed to release the write lock for unit %d.\r\n",_unit);                 \
+    return BVIEW_STATUS_FAILURE;                          \
+  }                                                                       \
+}
+
+
+
+/* Macro to copy track structures to collction structure */
+#define BST_COPY_TRACK_TO_COLLECT(_track_ptr, _collect_ptr)                          \
+            {                                                                        \
+              if ((NULL == (_track_ptr)) || (NULL == (_collect_ptr)))                      \
+              {                                                                      \
+                return BVIEW_STATUS_FAILURE;                                         \
+              }                                                                      \
+              (_collect_ptr)->includeDevice = (_track_ptr)->trackDevice;                   \
+              (_collect_ptr)->includeIngressPortPriorityGroup =                         \
+              (_track_ptr)->trackIngressPortPriorityGroup;                              \
+              (_collect_ptr)->includeIngressPortServicePool =                           \
+              (_track_ptr)->trackIngressPortServicePool;                                \
+              (_collect_ptr)->includeIngressServicePool =                               \
+              (_track_ptr)->trackIngressServicePool;                                    \
+              (_collect_ptr)->includeEgressPortServicePool =                            \
+              (_track_ptr)->trackEgressPortServicePool;                                 \
+              (_collect_ptr)->includeEgressServicePool =                                \
+              (_track_ptr)->trackEgressServicePool;                                     \
+              (_collect_ptr)->includeEgressUcQueue =                                    \
+              (_track_ptr)->trackEgressUcQueue;                                         \
+              (_collect_ptr)->includeEgressUcQueueGroup =                               \
+              (_track_ptr)->trackEgressUcQueueGroup;                                    \
+              (_collect_ptr)->includeEgressMcQueue =                                    \
+              (_track_ptr)->trackEgressMcQueue;                                         \
+              (_collect_ptr)->includeEgressCpuQueue =                                   \
+              (_track_ptr)->trackEgressCpuQueue;                                        \
+              (_collect_ptr)->includeEgressRqeQueue =                                   \
+              (_track_ptr)->trackEgressRqeQueue;                                        \
+            }
+
+/* Macro to copy collect structures to response options structure */
+
+#define  BST_COPY_COLLECT_TO_RESP(_collect_ptr, _resp_ptr)                                 \
+            {                                                                              \
+              if ((NULL == (_resp_ptr)) || (NULL == (_collect_ptr)))                     \
+              {                                                                            \
+                 LOG_POST (BVIEW_LOG_ERROR, "Failed to copy c-json encoding options to response\r\n");\
+                 return BVIEW_STATUS_FAILURE;                                              \
+              }                                                                            \
+              (_resp_ptr)->includeDevice = (_collect_ptr)->includeDevice;                \
+              (_resp_ptr)->includeIngressPortPriorityGroup =                          \
+              (_collect_ptr)->includeIngressPortPriorityGroup;                                \
+              (_resp_ptr)->includeIngressPortServicePool =                            \
+              (_collect_ptr)->includeIngressPortServicePool;                                  \
+              (_resp_ptr)->includeIngressServicePool =                                \
+              (_collect_ptr)->includeIngressServicePool;                                      \
+              (_resp_ptr)->includeEgressPortServicePool =                             \
+              (_collect_ptr)->includeEgressPortServicePool;                                   \
+              (_resp_ptr)->includeEgressServicePool =                                 \
+              (_collect_ptr)->includeEgressServicePool;                                       \
+              (_resp_ptr)->includeEgressUcQueue =                                     \
+              (_collect_ptr)->includeEgressUcQueue;                                           \
+              (_resp_ptr)->includeEgressUcQueueGroup =                                \
+              (_collect_ptr)->includeEgressUcQueueGroup;                                      \
+              (_resp_ptr)->includeEgressMcQueue =                                     \
+              (_collect_ptr)->includeEgressMcQueue;                                           \
+              (_resp_ptr)->includeEgressCpuQueue =                                    \
+              (_collect_ptr)->includeEgressCpuQueue;                                          \
+              (_resp_ptr)->includeEgressRqeQueue =                                    \
+              (_collect_ptr)->includeEgressRqeQueue;                                          \
+           }
+
+/* Macro to copy response options structure with given value*/
+
+#define  BST_COPY_TO_RESP(_resp_ptr, _val_)                                 \
+            {                                                                              \
+              if (NULL == (_resp_ptr))                                                  \
+              {                                                                            \
+                 LOG_POST (BVIEW_LOG_ERROR, "Failed to copy c-json encoding options to response\r\n");\
+                 return BVIEW_STATUS_FAILURE;                                              \
+              }                                                                            \
+              (_resp_ptr)->includeDevice = _val_;                \
+              (_resp_ptr)->includeIngressPortPriorityGroup = _val_;                         \
+              (_resp_ptr)->includeIngressPortServicePool =  _val_;                          \
+              (_resp_ptr)->includeIngressServicePool =  _val_;                              \
+              (_resp_ptr)->includeEgressPortServicePool =    _val_;                         \
+              (_resp_ptr)->includeEgressServicePool =       _val_;                          \
+              (_resp_ptr)->includeEgressUcQueue =   _val_;                                  \
+              (_resp_ptr)->includeEgressUcQueueGroup =   _val_;                             \
+              (_resp_ptr)->includeEgressMcQueue =   _val_;                                  \
+              (_resp_ptr)->includeEgressCpuQueue =  _val_;                                  \
+              (_resp_ptr)->includeEgressRqeQueue =  _val_;                                  \
+           }
+
+
+
+#define _BST_INPUT_PARAMS_CHECK(_type, _capabilities, _p) do { \
+      if (BVIEW_BST_INGRESS_PORT_PG_THRESHOLD == _type) { \
+         if ((0 > _p->priorityGroup) || \
+            (_p->priorityGroup >= _capabilities.numPriorityGroups)) { \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+         if ((BVIEW_BST_INGRESS_PORT_SP_THRESHOLD == _type) || \
+            (BVIEW_BST_EGRESS_PORT_SP_THRESHOLD == _type)) { \
+         if ((0 > _p->servicePool) || \
+            (_p->servicePool >= _capabilities.numServicePools) ||  \
+            (_p->port > _capabilities.numPorts))  { \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+         if ((BVIEW_BST_INGRESS_SP_THRESHOLD == _type) ||  \
+            (BVIEW_BST_EGRESS_SP_THRESHOLD == _type)) { \
+         if ((0 > _p->servicePool) || \
+            (_p->servicePool >= _capabilities.numServicePools)) {  \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+      if (BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD == _type) { \
+         if ((0 > _p->queue) || \
+            (_p->queue >= _capabilities.numUnicastQueues)) { \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+      if (BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD == _type) { \
+         if ((0 > _p->queueGroup) || \
+            (_p->queueGroup >= _capabilities.numUnicastQueueGroups)) { \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+      if (BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD == _type) { \
+         if ((0 > _p->queue) || \
+            (_p->queue >= _capabilities.numMulticastQueues)) { \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+      if (BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD == _type) { \
+         if ((0 > _p->queue) || \
+            (_p->queue >= _capabilities.numCpuQueues)) { \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+      if (BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD == _type) { \
+         if ((0 > _p->queue) || \
+            (_p->queue >= _capabilities.numRqeQueues)) { \
+                 return BVIEW_STATUS_INVALID_PARAMETER;                                              \
+              }                                                                            \
+            } \
+} while(0)
+
+
+
+
+/* functions */
+/*********************************************************************
+* @brief : application function to configure the bst features
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : when the asic successfully programmed
+* @retval  : BVIEW_STATUS_FAILURE : when the asic is failed to programme.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+*
+* @note : This function is invoked in the bst context and used to 
+*         configure the parameters like
+*         -- bst enable
+*         -- asyncronous collection of reports
+*         -- configuring the collection interval
+*         -- option to configure the data in bytes or cells.
+*         In case of the underlying  api returns failure, the same error message
+*         is received  and sent to the invoking function.
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_feature_set (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+/*********************************************************************
+* @brief : application function to get the bst features
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_SUCCESS : when the requested data is retrieved successfully.
+* @retval  : BVIEW_STATUS_FAILURE : When the application is unable to retrieve the
+*                                   requested data.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_feature_get(BVIEW_BST_REQUEST_MSG_t *msg_data);
+/*********************************************************************
+* @brief : application function to configure the bst tracking 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_FAILURE : when the requested data fails to get programmed in asic. 
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_SUCCESS : when the requested data is successfully programmed.
+*
+* @note : This function is invokded in the bst context to configure the bst 
+*         tracking parameters. BST can enable tracking for below.
+*          -- trackPeakStats
+*          -- trackIngressPortPriorityGroup
+*          -- trackIngressPortServicePool
+*          -- trackIngressServicePool
+*          -- trackEgressPortServicePool
+*          -- trackEgressServicePool
+*          -- trackEgressUcQueue
+*          -- trackEgressUcQueueGroup
+*          -- trackEgressMcQueue
+*          -- trackEgressCpuQueue
+*          -- trackEgressRqeQueue
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_track_set (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+/*********************************************************************
+* @brief : application function to get the bst tracking 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE  : unable to retrieve the requested tracking params.
+* @retval  : BVIEW_STATUS_SUCCESS  : successfully retrieved the tracking params.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_track_get(BVIEW_BST_REQUEST_MSG_t *msg_data);
+
+/*********************************************************************
+* @brief : application function to get switch properties
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid.
+* @retval  : BVIEW_STATUS_SUCCESS  : successfully retrieved the switch
+*                                    properties.
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS system_switch_properties_get (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+/*********************************************************************
+* @brief : application function to get the bst report and thresholds 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE  : Failed to retrieve the report from the asic.
+* @retval  : BVIEW_STATUS_SUCCESS  : Successfully retrieved the stats report.
+*
+* @note : based on the message type the report is retrieved.
+*          if the type is periodic , then the differential data between
+*          the active and backup records is sent in the report.
+*          If the report is get-bst-report,then the reporte is
+*          complete, i.e. the data is not differential.
+*          when the report type is trigger report, then report is triggered 
+*          using a callback mechanism from the asic.
+*
+*********************************************************************/
+BVIEW_STATUS bst_get_report(BVIEW_BST_REQUEST_MSG_t *msg_data);
+
+/*********************************************************************
+* @brief : function to add timer for the periodic stats collection 
+*
+* @param[in] unit : unit for which the periodic stats need to be collected.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- failed to add the timer 
+* @retval  : BVIEW_STATUS_SUCCESS -- timer is successfully added 
+*
+* @note : this api adds the timer to the linux timer thread, so when the timer 
+*         expires, we receive the callback and post message to the bst application
+*         to collect the stats.. this is a periodic timer , whose interval
+*         is equal to the collection interval. Note that collection is per
+*         unit and hence we need per timer per unit.
+*
+*********************************************************************/
+BVIEW_STATUS bst_periodic_collection_timer_add (unsigned int  unit);
+
+/*********************************************************************
+* @brief : Deletes the timer node for the given unit
+*
+* @param[in] unit : unit id for which  the timer needs to be deleted.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- timer is successfully deleted 
+* @retval  : BVIEW_STATUS_SUCCESS -- failed to delete the timer 
+*
+* @note  : The periodic timer is deleted when send asyncronous reporting
+*          is turned off. This timer is per unit.
+*
+*********************************************************************/
+BVIEW_STATUS bst_periodic_collection_timer_delete (int unit);
+
+/*********************************************************************
+* @brief : function to send reponse for encoding to cjson and sending 
+*          using rest API 
+*
+* @param[in] reply_data : pointer to the response message
+*
+* @retval  : BVIEW_STATUS_SUCCESS : message is successfully using rest API. 
+* @retval  : BVIEW_STATUS_FAILURE : message is unable to deliver using rest API.
+* @retval  : BVIEW_STATUS_OUTOFMEMORY : Unable to allocate json buffer.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter to function.
+*
+* @note   : This function is invoked by the bst to send the report and 
+*           requested get configure params. This function internally
+*           calls the encoding api to encode the data, and the memory
+*           for the data is allocated. In case of both successful and 
+*           unsuccessful send of the data, the memory must be freed.
+*           
+*********************************************************************/
+BVIEW_STATUS bst_send_response (BVIEW_BST_RESPONSE_MSG_t * reply_data);
+
+/*********************************************************************
+* @brief : function to prepare the response to the request message  
+*
+* @param[in] msg_data : pointer to the request message
+* @param[out] reply_data : pointer to the response message
+*
+* @retval  : BVIEW_STATUS_FAILURE : if the copy to response message fails 
+* @retval  : BVIEW_STATUS_SUCCESS :  response message is successfully prepred. 
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note  : This api copies the required information from input request 
+*          message to response message. In case of report, it copies the 
+*          pointers into the structure The data need to be protected till 
+*          the memory is allocated for the report to be copied.
+*          If the report is periodic, then we need the references of both
+*          active and back up records. If the report is non periodic, i.e 
+*          trigger or get report, then only the active record is required. 
+*          incse of periodic report, the report contains 
+*          incremental/differential changes.. Wher as for get report 
+*          the report is complete. Ensure that the lock is taken at this function
+*          is released when the buffer for the data is allocated.
+*
+*********************************************************************/
+BVIEW_STATUS bst_copy_reply_params (BVIEW_BST_REQUEST_MSG_t * msg_data,
+                            BVIEW_BST_RESPONSE_MSG_t * reply_data);
+
+/*********************************************************************
+* @brief :  function to register with module mgr
+*
+* @param[in] : none 
+* 
+* @retval  : BVIEW_STATUS_SUCCESS : registration of BST with module manager is successful.
+* @retval  : BVIEW_STATUS_FAILURE : BST failed to register with module manager.
+*
+* @note : BST need to register with module manager for the below purpose.
+*         When the REST API is invoked, rest queries the module manager for
+*         the suitable function api  for the corresponding request. Once the
+*         api is retieved , posts the request using the retrieved api.
+*         for this bst need to register with module mgr.
+*
+* @end
+*********************************************************************/
+BVIEW_STATUS bst_module_register ();
+
+/*********************************************************************
+* @brief   :  function to post message to the bst application  
+*
+* @param[in]  msg_data : pointer to the message request
+*
+* @retval  : BVIEW_STATUS_SUCCESS : if the message is successfully posted to BST queue.
+* @retval  : BVIEW_STATUS_FAILURE : if the message is failed to send to bst
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*            
+* @note  : all the apis and call back functions should use this api
+*          to post the message to bst application.
+*
+*********************************************************************/
+BVIEW_STATUS bst_send_request(BVIEW_BST_REQUEST_MSG_t *msg_data);
+
+/*********************************************************************
+*  @brief:  callback function to send periodic reports  
+*
+* @param[in]   sigval : Data passed with notification after timer expires
+*
+* @retval  : BVIEW_STATUS_SUCCESS : message is successfully posted to bst.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note : when the periodic collection timer expires, this api is invoked in
+*         the timer context. We just post the request for the report, while 
+*        posting we mark the report type as periodic. The parameter returned 
+*       from the callback is the reference to unit id. If the callback is failed
+*        to post to bst application , the error will be logged.
+*
+*********************************************************************/
+BVIEW_STATUS bst_periodic_collection_cb (union sigval sigval);
+
+/*********************************************************************
+* @brief : set the threshold for the given realm.
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS - threshold is set successfully
+* @retval  : BVIEW_STATUS_FAILURE - failed to apply the inputted threshold
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note    : In case of any threshold set fail, the error is logged
+*
+*********************************************************************/
+BVIEW_STATUS bst_config_threshold_set (BVIEW_BST_REQUEST_MSG_t * msg_data);
+/*********************************************************************
+* @brief : function to clear the threshold set
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the threshold values
+* @retval  : BVIEW_STATUS_FAILURE : The clearing of thresholds has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note    : when clear threshold is successful, along with the threshold information,
+*            the software information will also be cleared.
+*
+*********************************************************************/
+BVIEW_STATUS bst_clear_threshold_set (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+/*********************************************************************
+* @brief : clear the stats
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the stats values
+* @retval  : BVIEW_STATUS_FAILURE : The clearing of stats has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note : When clear stats is successful, along with the stats in the asic
+*         the cache will also be cleared.
+*
+*********************************************************************/
+BVIEW_STATUS bst_clear_stats_set (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+/*********************************************************************
+* @brief : copies the h/w retrevied to the current record.
+*
+* @param[in] type : Type of the record , i.e. stats or threshold
+* @param[in] unit : unit number for which the data is collected.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully updates the records
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note : Once the collection of the stats is completeed, the existing active
+*        record becomes back up. The newly collected record become the new active
+*        record. Make sure to take the lock while updating..
+*
+*********************************************************************/
+BVIEW_STATUS bst_update_data(BVIEW_BST_REPORT_TYPE_t type,unsigned int unit);
+
+/*************************************************************
+*@brief:  Callback function to send the trigger to bst application
+*         to send periodic collection
+*
+* @param[in] unit : unit for which the trigger is generated 
+* @param[in] cookie : cookie
+* @param[in] type : trigger type
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully posted message to bst
+* @retval  : BVIEW_STATUS_FAILURE : message posting to bst queue failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note  : callback function from ASIC to bst application 
+*          to send the triggers. This function is invoked 
+*          in the asic context, when the congigured thresholds 
+*          exceeds the values. In such case, 
+*          the trigger is generated by the asic and bst 
+*          application take a trigger report and sends the same to collector.
+*
+*************************************************************/
+BVIEW_STATUS bst_trigger_cb(int unit,void *cookie, BVIEW_BST_TRIGGER_INFO_t *triggerInfo);
+/*********************************************************************
+ * @brief : function to return the api handler for the bst command type
+ *
+ * @param[in] int : request type
+ * @param[out] int : pointer to the handler 
+ *
+ * @retval  : BVIEW_STATUS_SUCCESS : if the function pointer to the message type is found.
+ * @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+ *
+ * @note :
+ *
+ *********************************************************************/
+BVIEW_STATUS bst_type_api_get (int type, BVIEW_BST_API_HANDLER_t *handler);
+
+
+/*********************************************************************
+* @brief : Deletes the trigger timer node for the given unit
+*
+* @param[in] unit : unit id for which  the timer needs to be deleted.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- timer is successfully deleted 
+* @retval  : BVIEW_STATUS_SUCCESS -- failed to delete the timer 
+*
+* @note  :
+*         
+*
+*********************************************************************/
+BVIEW_STATUS bst_trigger_timer_delete (int unit);
+
+
+/*********************************************************************
+* @brief : function to timer for the trigger report rate limit. 
+*
+* @param[in] unit : unit for which the trigger interval timer need to run.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- failed to add the timer 
+* @retval  : BVIEW_STATUS_SUCCESS -- timer is successfully added 
+*
+* @note : this api adds the timer to the linux timer thread, so when the timer 
+*         expires, we receive the callback and post message to the bst application.
+*         Upon receiving the event, bst application clears the trigger reports 
+*         counter which it maintains per realm - counter.
+*
+*********************************************************************/
+BVIEW_STATUS bst_trigger_timer_add (unsigned int  unit);
+/*********************************************************************
+* @brief : clear the trigger counters 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the trigger report count 
+* @retval  : BVIEW_STATUS_FAILURE : The clearing of count has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_clear_trigger_count (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+/*********************************************************************
+*  @brief:  callback function to clear the trigger count  
+*
+* @param[in]   sigval : Data passed with notification after timer expires
+*
+* @retval  : BVIEW_STATUS_SUCCESS : message is successfully posted to bst.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note : when the trigger timer expires, this api is invoked in
+*         the timer context.
+*
+*********************************************************************/
+BVIEW_STATUS bst_trigger_timer_cb (union sigval sigval);
+
+/*********************************************************************
+*  @brief:  function to set the given realm in the include trigger report.  
+*
+* @param[in]   *realm : pointer to realm 
+* @param[in]   *realm : pointer to json encode options 
+*
+* @retval  : none : 
+*
+* @note :
+*
+*********************************************************************/
+void bst_set_realm_to_collect(char *realm, BVIEW_BST_REPORT_OPTIONS_t *options);
+
+/*********************************************************************
+* @brief : application function to process trigger messages 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : when the request is successfully processed 
+* @retval  : BVIEW_STATUS_FAILURE : when the processing of the request failed. 
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+*
+* @note : This function is invoked in the bst thread context and used to 
+*         -- bst enable
+*         -- send the message to bst thread if the sending of trigger report is allowed. 
+*
+*********************************************************************/
+
+BVIEW_STATUS bst_process_trigger(BVIEW_BST_REQUEST_MSG_t *msg_data);
+
+/*********************************************************************
+* @brief : bst trigger main application function which does processing of 
+*          trigger messages
+*
+* @param[in] : none
+*
+* @retval  : BVIEW_STATUS_SUCCESS: 
+* @retval  : BVIEW_STATUS_FAILURE: Fails to process the trigger messages 
+*
+* @note  : This api is the processing thread of the bst trigger application. 
+*          All the incoming requests are processed. 
+*          Currently the assumption is made that if the 
+*          thread fails to read continously 10 or more messages,
+*          then there is some error and the thread exits.
+*
+*********************************************************************/
+
+BVIEW_STATUS bst_trigger_main(void);
+
+BVIEW_STATUS bst_enable_on_trigger(BVIEW_BST_REQUEST_MSG_t *msg_data, int bstEnable);
+
+
+/*********************************************************************
+* @brief :  re-enable bst on trigger timer expiry 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the trigger report count 
+* @retval  : BVIEW_STATUS_FAILURE : The re-enable has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_enable_on_trigger_timer_expiry (BVIEW_BST_REQUEST_MSG_t * msg_data);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INCLUDE_BST_APP_H */
+
diff --git a/src/apps/bst/bst_main.c b/src/apps/bst/bst_main.c
new file mode 100755
index 0000000..b7444c5
--- /dev/null
+++ b/src/apps/bst/bst_main.c
@@ -0,0 +1,1349 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/msg.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include <mqueue.h>
+#include <errno.h>
+#include "bst_json_memory.h"
+#include "clear_bst_statistics.h"
+#include "clear_bst_thresholds.h"
+#include "configure_bst_thresholds.h"
+#include "configure_bst_feature.h"
+#include "configure_bst_tracking.h"
+#include "get_bst_tracking.h"
+#include "get_bst_feature.h"
+#include "get_bst_thresholds.h"
+#include "get_bst_report.h"
+#include "bst_json_encoder.h"
+#include "bst.h"
+#include "broadview.h"
+#include "bst_app.h"
+#include "system.h"
+#include "rest_api.h"
+#include "openapps_log_api.h"
+#include "sbplugin_redirect_bst.h"
+#include "sbplugin_redirect_system.h"
+
+/* BST Context Info*/
+extern BVIEW_BST_CXT_t bst_info;
+/* BST Mutex*/
+pthread_mutex_t *bst_mutex;
+//pthread_rwlock_t *bst_configRWLock;
+
+/*********************************************************************
+ * @brief : function to return the api handler for the bst command type 
+ *
+ * @param[in] int : request type 
+ *
+ * @retval    : function pointer to the corresponding api 
+ *
+ * @note : 
+ *
+ *********************************************************************/
+BVIEW_STATUS bst_type_api_get (int type, BVIEW_BST_API_HANDLER_t *handler)
+{
+  unsigned int i = 0;
+
+  static const BVIEW_BST_API_t bst_api_list[] = {
+    {BVIEW_BST_CMD_API_GET_FEATURE, bst_config_feature_get},
+    {BVIEW_BST_CMD_API_GET_TRACK, bst_config_track_get},
+    {BVIEW_BST_CMD_API_GET_REPORT, bst_get_report},
+    {BVIEW_BST_CMD_API_GET_THRESHOLD, bst_get_report},
+    {BVIEW_BST_CMD_API_TRIGGER_REPORT, bst_get_report},
+    {BVIEW_BST_CMD_API_TRIGGER_COLLECT, bst_process_trigger},
+    {BVIEW_BST_CMD_API_SET_FEATURE, bst_config_feature_set},
+    {BVIEW_BST_CMD_API_SET_TRACK, bst_config_track_set},
+    {BVIEW_BST_CMD_API_SET_THRESHOLD, bst_config_threshold_set},
+    {BVIEW_BST_CMD_API_CLEAR_THRESHOLD, bst_clear_threshold_set},
+    {BVIEW_BST_CMD_API_CLEAR_STATS, bst_clear_stats_set},
+    {BVIEW_BST_CMD_API_CLEAR_TRIGGER_COUNT, bst_clear_trigger_count},
+    {BVIEW_BST_CMD_API_ENABLE_BST_ON_TRIGGER, bst_enable_on_trigger_timer_expiry},
+    {BVIEW_BST_CMD_API_GET_SWITCH_PROPERTIES, system_switch_properties_get}
+  };
+
+  for (i = 0; i < BVIEW_BST_CMD_API_MAX-1; i++)
+  {
+    if (type == bst_api_list[i].bst_command)
+    {
+      *handler = bst_api_list[i].handler;
+      return BVIEW_STATUS_SUCCESS;
+    }
+  }
+  return BVIEW_STATUS_INVALID_PARAMETER;
+}
+
+
+/*********************************************************************
+* @brief : clear the trigger counters 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the trigger report count 
+* @retval  : BVIEW_STATUS_FAILURE : The clearing of count has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_clear_trigger_count (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_UNIT_CXT_t *ptr;
+  bool clearTimer = true;
+  unsigned int i;
+  BVIEW_BST_REQUEST_MSG_t bst_msg = {0};
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  ptr = BST_UNIT_PTR_GET (msg_data->unit);
+
+  if (NULL == ptr)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* before clearing, check if there is still a need to 
+     run this timer . If no triggers are there, 
+     the timer can be cleared and restarted as and when 
+     required */
+
+  BST_RWLOCK_WR_LOCK (msg_data->unit);
+  for (i = 0; i < BST_ID_MAX; i++)
+  {
+    if (0 != ptr->bst_trigger_count[i])
+    {
+      clearTimer = false;
+      break;
+    }
+  }
+
+  memset (ptr->bst_trigger_count, 0, sizeof(ptr->bst_trigger_count)); 
+  BST_RWLOCK_UNLOCK (msg_data->unit);
+
+  if (true == clearTimer)
+  {
+    rv = bst_trigger_timer_delete (msg_data->unit);
+  }
+
+  /* post message to bst queue */
+  bst_msg.unit = msg_data->unit;
+  bst_msg.msg_type = BVIEW_BST_CMD_API_ENABLE_BST_ON_TRIGGER;
+
+  /* Send the message to the bst application */
+  rv = bst_send_request (&bst_msg);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "Failed to send trigger collection message to bst application. err = %d\r\n", rv);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief :  re-enable bst on trigger timer expiry 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully cleared the trigger report count 
+* @retval  : BVIEW_STATUS_FAILURE : The re-enable has failed.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_enable_on_trigger_timer_expiry (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_CONFIG_PARAMS_t *ptr;
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  ptr = BST_CONFIG_FEATURE_PTR_GET (msg_data->unit);
+
+  if (NULL == ptr)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Take lock */
+  BST_RWLOCK_RD_LOCK (msg_data->unit);
+
+  if (true == ptr->bstEnable)
+  {
+    rv = bst_enable_on_trigger(msg_data, true);
+  }
+
+  /* release lock */
+  BST_RWLOCK_UNLOCK (msg_data->unit);
+  return rv;
+}
+
+/*********************************************************************
+* @brief : bst main application function which does processing of messages
+*
+* @param[in] : none
+*
+* @retval  : BVIEW_STATUS_SUCCESS: Fails to register with module manager 
+*             or some error happened due to which the bst application is
+*             unable to process incoming messages.
+* @retval  : BVIEW_STATUS_FAILURE: Fails to register with module manager 
+*
+* @note  : This api is the processing thread of the bst application. 
+*          All the incoming requests are processed and the responses 
+*          are sent in the bst context. Currently the assumption
+*          is made that if the thread fails to read continously 10 or 
+*          more messages, then there is some error and the thread exits.
+*
+*********************************************************************/
+BVIEW_STATUS bst_app_main (void)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_BST_RESPONSE_MSG_t reply_data;
+  BVIEW_STATUS rv = BVIEW_STATUS_FAILURE;
+  unsigned int rcvd_err = 0;
+  unsigned int id = 0, num_units = 0;
+  BVIEW_BST_API_HANDLER_t handler;
+  BVIEW_SWITCH_PROPERTIES_t  *pswitchProp = bst_info.switchProperties;
+
+  if (BVIEW_STATUS_SUCCESS != bst_module_register ())
+  {
+    /* registration with module mgr has failed.
+       return failure. so that the caller can clean the resources */
+    LOG_POST (BVIEW_LOG_EMERGENCY,
+              "Registration with module mgr failed \r\n");
+
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  if (BVIEW_STATUS_SUCCESS != sbapi_system_num_units_get ((int *) &num_units))
+  {
+    LOG_POST (BVIEW_LOG_ERROR, "Failed to get num of units\r\n");
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* NULLPTR check*/
+  if (pswitchProp == NULL)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  pswitchProp->numAsics = num_units;
+  /* Get Supported feature mask*/
+  if (BVIEW_STATUS_SUCCESS !=
+      sbapi_system_feature_mask_get (&pswitchProp->featureMask))
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* get the network OS or Plugin*/
+  if (BVIEW_STATUS_SUCCESS !=
+      sbapi_system_network_os_get (&pswitchProp->networkOs[0], 
+                                   BVIEW_NETWORK_OS_LEN_MAX))
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  for (id = 0; id < num_units; id++)
+  {
+    /* register the trigger callback for every unit */
+    /* register for triggers from asic */
+    rv = sbapi_bst_register_trigger (id, (bst_trigger_cb), &bst_info.unit[id].cb_cookie);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Failed to register with asic for callbacks for  unit %d\r\n", id);
+      return BVIEW_STATUS_FAILURE;
+    }
+
+     /* Get asic notation*/
+    if (BVIEW_STATUS_SUCCESS != 
+        sbapi_system_asic_translate_to_notation (id,
+                              pswitchProp->asicInfo[id].asic_notation))
+    {
+       return BVIEW_STATUS_FAILURE;
+    }
+      
+    /* Get ASIC type*/
+    if (BVIEW_STATUS_SUCCESS != 
+        sbapi_system_unit_to_asic_type_get (id,
+                             &pswitchProp->asicInfo[id].asicType))
+    {
+       return BVIEW_STATUS_FAILURE;
+    }
+
+     /* get the bst buffer default values */
+    if (BVIEW_STATUS_SUCCESS != sbapi_bst_default_snapshot_get(id, 
+                                          &bst_info.unit[id].bst_defaults))
+    {
+        /* unable to get the default values 
+           log error and return */
+       LOG_POST (BVIEW_LOG_ERROR, 
+               "Failed to Get Asic capabilities for unit %d. \r\n", id);
+       return BVIEW_STATUS_FAILURE;
+    }
+    
+     /* get the asic capabilities of the system 
+      * save the same so that the same can be reused 
+      */
+    if (BVIEW_STATUS_SUCCESS != sbapi_system_asic_capabilities_get(id, 
+                                          &bst_info.unit[id].asic_capabilities))
+    {
+        /* unable to get the asic capabilities
+           log error and return */
+       LOG_POST (BVIEW_LOG_ERROR, 
+               "Failed to Get Asic capabilities for unit %d. \r\n", id);
+       return BVIEW_STATUS_FAILURE;
+    }
+    else
+    {
+             
+      _BST_LOG(_BST_DEBUG_INFO, "supported capabilities are\n"
+          "num ports = %d, numUnicastQueues = %d\n" 
+          "numUnicastQueueGroups = %d, numMulticastQueues = %d\n" 
+          "numServicePools = %d, numCommonPools = %d\n" 
+          "numCpuQueues = %d, numRqeQueues = %d\n" 
+          "numRqeQueuePools = %d, numPriorityGroups = %d\n",
+           bst_info.unit[id].asic_capabilities.numPorts, 
+           bst_info.unit[id].asic_capabilities.numUnicastQueues, 
+           bst_info.unit[id].asic_capabilities.numUnicastQueueGroups, 
+           bst_info.unit[id].asic_capabilities.numMulticastQueues, 
+           bst_info.unit[id].asic_capabilities.numServicePools, 
+           bst_info.unit[id].asic_capabilities.numCommonPools, 
+           bst_info.unit[id].asic_capabilities.numCpuQueues, 
+           bst_info.unit[id].asic_capabilities.numRqeQueues, 
+           bst_info.unit[id].asic_capabilities.numRqeQueuePools, 
+           bst_info.unit[id].asic_capabilities.numPriorityGroups 
+          ); 
+    }
+    pswitchProp->asicInfo[id].numPorts = 
+           bst_info.unit[id].asic_capabilities.numPorts;
+  }
+
+
+  while (1)
+  {
+    if (-1 != (msgrcv (bst_info.recvMsgQid, &msg_data, sizeof (msg_data), 0, 0))) 
+    {
+      _BST_LOG(_BST_DEBUG_INFO, "msg_data info\n"
+          "msg_data.msg_type = %ld\n"
+          "msg_data.unit = %d\n"
+          "msg_data.cookie = %d\n",
+          msg_data.msg_type, msg_data.unit, (NULL == msg_data.cookie)? true: false); 
+
+      if (msg_data.unit >= num_units)
+      {
+        /* requested id is greater than the number of units.
+           send failure message and continue */
+        memset (&reply_data, 0, sizeof (BVIEW_BST_RESPONSE_MSG_t));
+        reply_data.rv = BVIEW_STATUS_INVALID_PARAMETER;
+
+        /* copy the request type */
+        reply_data.msg_type = msg_data.msg_type;
+        /* copy the unit */
+        reply_data.unit = msg_data.unit;
+        /* copy the asic type */
+        reply_data.id = msg_data.id;
+        /* copy the cookie ..  */
+        reply_data.cookie = msg_data.cookie;
+
+        rv = bst_send_response(&reply_data);
+        if (BVIEW_STATUS_SUCCESS != rv)
+        {
+          LOG_POST (BVIEW_LOG_ERROR,
+              "failed to send response for command %ld , err = %d. \r\n", msg_data.msg_type, rv);
+        }
+        continue;
+      }
+      /* Counter to check for read errors.. 
+         successfully read the message. clear this to 0*/
+      rcvd_err = 0;
+      /* Memset the response message */
+      memset (&reply_data, 0, sizeof (BVIEW_BST_RESPONSE_MSG_t));
+
+      /* get the api function for the method type */
+      if (BVIEW_STATUS_SUCCESS != bst_type_api_get (msg_data.msg_type, &handler))
+      {
+        continue;
+      }
+
+      rv = handler(&msg_data);
+
+      reply_data.rv = rv;
+
+      rv = bst_copy_reply_params (&msg_data, &reply_data);
+      if (BVIEW_STATUS_SUCCESS != rv)
+      {
+        _BST_LOG(_BST_DEBUG_ERROR, 
+                "bst_main.c failed to send response for command %ld , err = %d. \r\n", msg_data.msg_type, rv);
+        LOG_POST (BVIEW_LOG_ERROR,
+            "failed to send response for command %ld , err = %d. \r\n", msg_data.msg_type, rv);
+      }
+    }
+    else
+    {
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Failed to read message from the bst application queue. err = %d\r\n", errno);
+      /* increment the error counter. 
+         If this counter increments continously exit and return failure
+         so that corrective action can be taken */
+       rcvd_err++;
+
+        /* wait till 10 consective messages */
+       if(BVIEW_BST_MAX_QUEUE_SEND_FAILS < rcvd_err)
+       {
+         break;
+       }
+       continue;
+    }
+  }                             /* while (1) */
+  LOG_POST (BVIEW_LOG_EMERGENCY,
+            "exiting from bst pthread ... \r\n");
+  pthread_exit(&bst_info.bst_thread);
+  return BVIEW_STATUS_FAILURE;
+}
+
+
+/*********************************************************************
+* @brief : function to initializes bst structures to default values 
+*
+* @param[in] : number of units on the agent
+*
+* @retval  : BVIEW_STATUS_SUCCESS : configuration is successfully initialized.
+* @retval  : BVIEW_STATUS_FAILURE : Fail to initialize the BST appliation to default.
+*
+* @note  : Initialization functon to make sure both software and asic 
+*          are configured with same default values. We are not setting 
+*          the default values for threshold, but we are using 
+*          the same as that of asic.
+*
+*********************************************************************/
+BVIEW_STATUS bst_app_config_init (unsigned int num_units)
+{
+  BVIEW_BST_CFG_PARAMS_t *ptr;
+  BVIEW_BST_DATA_t *bst_data_ptr;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  BVIEW_BST_CONFIG_t bstMode;
+  int unit_id = 0;
+
+  if (0 == num_units)
+  {
+    /* get the number of units on this device */
+    LOG_POST (BVIEW_LOG_ERROR, "Failed to Init BST:Number of units are zero\r\n");
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  for (unit_id = 0; unit_id < num_units; unit_id++)
+  {
+    /* all the bst info we maintain is per unit. so get each unit 
+       and configure the same.. */
+    ptr = BST_CONFIG_PTR_GET (unit_id);
+
+    if (NULL == ptr)
+    {
+      /* fatal error. cannot access the bst info.. */
+      LOG_POST (BVIEW_LOG_ERROR, "Error!! bst info is not accessible !!\r\n");
+      return BVIEW_STATUS_FAILURE;
+    }
+
+    bst_data_ptr = BST_UNIT_DATA_PTR_GET (unit_id);
+    if (NULL == ptr)
+    {
+      LOG_POST (BVIEW_LOG_ERROR, "Error!! bst memory is not accessible !!\r\n");
+      return BVIEW_STATUS_FAILURE;
+    }
+    bstjson_memory_init();
+
+    /* bst enable */
+    ptr->config.bstEnable = BVIEW_BST_DEFAULT_ENABLE;
+    /* send async reports  */
+    ptr->config.sendAsyncReports = BVIEW_BST_PERIODIC_REPORT_DEFAULT;
+    /* collection interval  */
+    ptr->config.collectionInterval = BVIEW_BST_DEFAULT_INTERVAL;
+    /* stats in cells or bytes.  */
+    ptr->config.statUnitsInCells = BVIEW_BST_DEFAULT_STATS_UNITS;
+    ptr->config.statsInPercentage = BVIEW_BST_DEFAULT_STATS_PERCENTAGE;
+    ptr->config.bstMaxTriggers = BVIEW_BST_DEFAULT_MAX_TRIGGERS;
+    ptr->config.sendSnapshotOnTrigger = BVIEW_BST_DEFAULT_SNAPSHOT_TRIGGER;
+    ptr->config.triggerTransmitInterval = BVIEW_BST_DEFAULT_TRIGGER_INTERVAL;
+    ptr->config.sendIncrementalReport = BVIEW_BST_DEFAULT_SEND_INCR_REPORT;
+
+
+    /* enable device tracking   */
+    ptr->track.trackDevice = BVIEW_BST_DEFAULT_TRACK_DEVICE;
+    /* enable ingress tracking p + pg   */
+    ptr->track.trackIngressPortPriorityGroup = BVIEW_BST_DEFAULT_TRACK_IN_P_PG;
+    /* enable ingress tracking p + sp  */
+    ptr->track.trackIngressPortServicePool = BVIEW_BST_DEFAULT_TRACK_IN_P_SP;
+    /* enable ingress tracking  sp  */
+    ptr->track.trackIngressServicePool = BVIEW_BST_DEFAULT_TRACK_IN_SP;
+    /* enable egress tracking P+ sp  */
+    ptr->track.trackEgressPortServicePool = BVIEW_BST_DEFAULT_TRACK_E_P_SP;
+    /* enable egress tracking sp  */
+    ptr->track.trackEgressServicePool = BVIEW_BST_DEFAULT_TRACK_E_SP;
+    /* enable egress tracking uc queues  */
+    ptr->track.trackEgressUcQueue = BVIEW_BST_DEFAULT_TRACK_E_UC_Q;
+    /* enable egress tracking uc queue grp */
+    ptr->track.trackEgressUcQueueGroup = BVIEW_BST_DEFAULT_TRACK_E_UC_QG;
+    /* enable egress tracking mc queue grp */
+    ptr->track.trackEgressMcQueue = BVIEW_BST_DEFAULT_TRACK_E_MC_Q;
+    /* enable egress tracking cpu queue grp */
+    ptr->track.trackEgressCpuQueue = BVIEW_BST_DEFAULT_TRACK_E_CPU_Q;
+    /* enable egress tracking rqe queue grp */
+    ptr->track.trackEgressRqeQueue = BVIEW_BST_DEFAULT_TRACK_MODE;
+    /* enable  tracking mode to current */
+
+    ptr->track.trackPeakStats = false;
+
+    /* Initialize the bst timer array */
+    bst_data_ptr->bst_collection_timer.unit = unit_id;
+    bst_data_ptr->bst_collection_timer.in_use = false;
+    bst_data_ptr->bst_trigger_timer.in_use = false;
+    bst_data_ptr->bst_trigger_timer.unit = unit_id;
+
+    /* push default values to asic */
+
+    rv =  sbapi_bst_clear_thresholds(unit_id);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      LOG_POST (BVIEW_LOG_ERROR, 
+          "threshold clear not successful for the unit. %d \r\n", 
+          unit_id);
+    }
+    memset (&bstMode, 0, sizeof (BVIEW_BST_CONFIG_t));
+    bstMode.enableStatsMonitoring = BVIEW_BST_DEFAULT_ENABLE;
+    bstMode.enableDeviceStatsMonitoring = BVIEW_BST_DEFAULT_TRACK_DEVICE;
+    bstMode.enableIngressStatsMonitoring = BVIEW_BST_DEFAULT_TRACK_INGRESS;
+    bstMode.enableEgressStatsMonitoring = BVIEW_BST_DEFAULT_TRACK_EGRESS;
+    bstMode.mode = BVIEW_BST_MODE_CURRENT;
+  
+    if (BVIEW_STATUS_SUCCESS != sbapi_bst_config_set (unit_id, &bstMode))
+    {
+      LOG_POST (BVIEW_LOG_ERROR,
+                "Failed to set bst config params for unit %d\r\n", unit_id);
+      return BVIEW_STATUS_FAILURE;
+    }
+
+    if ((false != ptr->config.sendAsyncReports) && (ptr->config.bstEnable != false))
+    {
+      /* register for timer callback only if reports need
+         to be sent asyncronously */
+      rv = bst_periodic_collection_timer_add (unit_id);
+      if (BVIEW_STATUS_SUCCESS != rv)
+      {
+        LOG_POST (BVIEW_LOG_ERROR,
+            "Failed to register with timer  for callbacks for  unit %d\r\n", unit_id);
+        return BVIEW_STATUS_FAILURE;
+      }
+    }
+  }
+
+  LOG_POST (BVIEW_LOG_INFO, 
+      "bst default initialization successful\r\n"); 
+  return rv;
+}
+
+
+/*********************************************************************
+* @brief : function to send reponse for encoding to cjson and sending 
+*          using rest API 
+*
+* @param[in] reply_data : pointer to the response message
+*
+* @retval  : BVIEW_STATUS_SUCCESS : message is successfully using rest API. 
+* @retval  : BVIEW_STATUS_FAILURE : message is unable to deliver using rest API.
+* @retval  : BVIEW_STATUS_OUTOFMEMORY : Unable to allocate json buffer.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter to function.
+*
+* @note   : This function is invoked by the bst to send the report and 
+*           requested get configure params. This function internally
+*           calls the encoding api to encode the data, and the memory
+*           for the data is allocated. In case of both successful and 
+*           unsuccessful send of the data, the memory must be freed.
+*           
+*********************************************************************/
+BVIEW_STATUS bst_send_response (BVIEW_BST_RESPONSE_MSG_t * reply_data)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  uint8_t *pJsonBuffer = NULL;
+
+  if (NULL == reply_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+        _BST_LOG(_BST_DEBUG_INFO, "Reply_data\n"
+            "reply_data->msg_type = %ld\n"
+            "reply_data->rv = %d\n"
+            "reply_data->unit = %d\n"
+            "reply_data->cookie = %d\n",
+            reply_data->msg_type,reply_data->rv, reply_data->unit, (NULL == reply_data->cookie)? true : false); 
+
+  if (reply_data->rv != BVIEW_STATUS_SUCCESS)
+  {
+    rest_response_send_error(reply_data->cookie, reply_data->rv, reply_data->id);
+    return BVIEW_STATUS_SUCCESS;
+  }
+  else 
+  {
+    if ((BVIEW_BST_CMD_API_SET_TRACK == reply_data->msg_type) ||
+        (BVIEW_BST_CMD_API_SET_FEATURE == reply_data->msg_type) ||
+        (BVIEW_BST_CMD_API_SET_THRESHOLD == reply_data->msg_type) ||
+        (BVIEW_BST_CMD_API_CLEAR_STATS == reply_data->msg_type) ||
+        (BVIEW_BST_CMD_API_CLEAR_THRESHOLD == reply_data->msg_type))
+    {
+      rest_response_send_ok (reply_data->cookie);
+      return BVIEW_STATUS_SUCCESS;
+    }
+
+  } 
+
+  /* Take lock*/
+  BST_LOCK_TAKE (reply_data->unit);
+  switch (reply_data->msg_type)
+  {
+    case BVIEW_BST_CMD_API_GET_TRACK:
+
+      /* call json encoder api for tracking  */
+      rv = bstjson_encode_get_bst_tracking (reply_data->unit, reply_data->id,
+          reply_data->response.track,
+          &pJsonBuffer);
+      break;
+
+    case BVIEW_BST_CMD_API_GET_FEATURE:
+      /* call json encoder api for feature  */
+
+      rv = bstjson_encode_get_bst_feature (reply_data->unit, reply_data->id,
+          reply_data->response.config,
+          &pJsonBuffer);
+      break;
+    case  BVIEW_BST_CMD_API_GET_SWITCH_PROPERTIES:
+      /* call json encoder api for featute*/
+       rv = bstjson_encode_get_switch_properties (reply_data->unit, reply_data->id,
+                                                  reply_data->switchProperties,
+                                                  &pJsonBuffer);
+       break;
+   
+     case BVIEW_BST_CMD_API_GET_REPORT:
+     case BVIEW_BST_CMD_API_TRIGGER_REPORT:
+     case BVIEW_BST_CMD_API_GET_THRESHOLD:
+      /*  call json encoder api for report  */
+
+      /* if this is a periodic report, the back up pointer is
+         a non null poiner, other wise , the backup 
+         pointer would be NULL pointer. so call 
+         the encoder function accordingly */
+
+      if (NULL == reply_data->response.report.backup)
+      {
+      rv = bstjson_encode_get_bst_report (reply_data->unit, reply_data->msg_type,
+                                          NULL, 
+                                          &reply_data->response.report.active->snapshot_data,
+                                          &reply_data->options,
+                                          reply_data->asic_capabilities,
+                                          &reply_data->response.report.active->tv,
+                                          &pJsonBuffer); 
+      }
+      else
+      {
+      rv = bstjson_encode_get_bst_report (reply_data->unit, reply_data->msg_type,
+                                          &reply_data->response.report.backup->snapshot_data, 
+                                          &reply_data->response.report.active->snapshot_data,
+                                          &reply_data->options,
+                                          reply_data->asic_capabilities,
+                                          &reply_data->response.report.active->tv,
+                                          &pJsonBuffer); 
+      }
+
+        break;
+    default:
+      break;
+  }
+
+  if (NULL != pJsonBuffer && BVIEW_STATUS_SUCCESS == rv)
+  {
+    rv = rest_response_send(reply_data->cookie, (char *)pJsonBuffer, strlen((char *)pJsonBuffer));
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      _BST_LOG(_BST_DEBUG_ERROR, "sending response failed due to error = %d\r\n",rv);
+      LOG_POST (BVIEW_LOG_ERROR,
+          " sending response failed due to error = %d\r\n",rv);
+    }
+    else
+    {
+      _BST_LOG(_BST_DEBUG_TRACE,"sent response to rest, pJsonBuffer = %s, len = %d\r\n", pJsonBuffer, (int)strlen((char *)pJsonBuffer)); 
+    }
+    /* free the json buffer */
+    if (NULL != pJsonBuffer)
+    {
+      bstjson_memory_free(pJsonBuffer);
+    }
+  }
+  else
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "encoding of bst response failed due to error = %d\r\n", rv);
+    /* Can happen that memory is allocated,
+      but the encoding failed.. in that case also 
+      free the json buffer.
+       */
+    if (NULL != pJsonBuffer)
+    {
+      bstjson_memory_free(pJsonBuffer);
+    }
+  }
+  /* release the lock for success and failed cases */
+  BST_LOCK_GIVE(reply_data->unit);
+  return rv;
+}
+
+/*********************************************************************
+* @brief : function to prepare the response to the request message  
+*
+* @param[in] msg_data : pointer to the request message
+* @param[out] reply_data : pointer to the response message
+*
+* @retval  : BVIEW_STATUS_FAILURE : if the copy to response message fails 
+* @retval  : BVIEW_STATUS_SUCCESS :  response message is successfully prepred. 
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*                                           or null pointers to function
+*
+* @note  : This api copies the required information from input request 
+*          message to response message. In case of report, it copies the 
+*          pointers into the structure The data need to be protected till 
+*          the memory is allocated for the report to be copied.
+*          If the report is periodic, then we need the references of both
+*          active and back up records. If the report is non periodic, i.e 
+*          trigger or get report, then only the active record is required. 
+*          incse of periodic report, the report contains 
+*          incremental/differential changes.. Wher as for get report 
+*          the report is complete. Ensure that the lock is taken at this function
+*          is released when the buffer for the data is allocated.
+*
+*********************************************************************/
+BVIEW_STATUS bst_copy_reply_params (BVIEW_BST_REQUEST_MSG_t * msg_data,
+                            BVIEW_BST_RESPONSE_MSG_t * reply_data)
+{
+  BVIEW_BST_UNIT_CXT_t *ptr;
+  BVIEW_BST_STAT_COLLECT_CONFIG_t *pCollect = &msg_data->request.collect;
+  BVIEW_BST_REPORT_OPTIONS_t  *pResp; 
+
+  if ((NULL == msg_data) || (NULL == reply_data))
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  ptr = BST_UNIT_PTR_GET (msg_data->unit);
+
+  pCollect = &msg_data->request.collect;
+  pResp = &reply_data->options;
+
+  /* copy the request type */
+  reply_data->msg_type = msg_data->msg_type;
+  /* copy the unit */
+  reply_data->unit = msg_data->unit;
+  /* copy the asic type */
+  reply_data->id = msg_data->id;
+  /* copy the cookie ..  */
+  reply_data->cookie = msg_data->cookie;
+        /* copy the asic capabilities into the response */
+
+  reply_data->asic_capabilities = &ptr->asic_capabilities;
+
+  reply_data->options.statUnitsInCells = 
+  ptr->bst_data->bst_config.config.statUnitsInCells;
+
+  reply_data->options.statsInPercentage = false;
+
+  /* copy the address pointer of the default values */
+  reply_data->options.bst_defaults_ptr = &ptr->bst_defaults;
+        /* copy the collect params into options fields of the request */
+  BST_COPY_COLLECT_TO_RESP (pCollect, pResp);
+
+
+  switch (msg_data->msg_type)
+  {
+    case BVIEW_BST_CMD_API_GET_REPORT:
+    case BVIEW_BST_CMD_API_TRIGGER_REPORT:
+      {
+        /* copy stats_units and trigger into  options */
+        if (BVIEW_BST_STATS_TRIGGER == msg_data->report_type)
+        {
+          /* this report is of type trigger */
+          reply_data->options.reportTrigger = true;
+          reply_data->options.reportThreshold = false;
+          reply_data->cookie = NULL;
+          reply_data->options.triggerInfo = msg_data->triggerInfo;
+          reply_data->options.sendSnapShotOnTrigger = ptr->bst_data->bst_config.config.sendSnapshotOnTrigger;
+          if(false == reply_data->options.sendSnapShotOnTrigger)
+          {
+            BST_COPY_TO_RESP(pResp, false);
+            /* Set the only the desired realm to true */
+            bst_set_realm_to_collect(msg_data->triggerInfo.realm, pResp);
+          }
+        }
+
+        /* update the data, i.e make the active record as new backup
+           and current record as new active */
+        bst_update_data (BVIEW_BST_STATS, msg_data->unit);
+
+        /* assign the active records */
+        reply_data->response.report.active = ptr->stats_active_record_ptr;
+
+        /* copy the backup record ptr if and only if the report is periodic */
+
+        if (BVIEW_BST_STATS_PERIODIC == msg_data->report_type)
+        {
+            reply_data->options.sendIncrementalReport = 
+                 ptr->bst_data->bst_config.config.sendIncrementalReport;
+
+          /* check if complete report is configured */
+          if (false == ptr->bst_data->bst_config.config.sendIncrementalReport)
+          {
+            reply_data->response.report.backup = NULL;
+          }
+          else
+          {
+            reply_data->response.report.backup = ptr->stats_backup_record_ptr;
+          }
+          reply_data->cookie = NULL;
+        }
+        else
+        {
+          /* copy null as the encoder function expects the null for non-periodic cases */
+          reply_data->response.report.backup = NULL;
+
+          /* no need to send huge data when get-bst-report is requested.
+             Send only the counters which contain non zero values */
+            reply_data->options.sendIncrementalReport = 
+                 true;
+        }
+
+
+        reply_data->options.statsInPercentage = 
+          ptr->bst_data->bst_config.config.statsInPercentage;
+      }
+      break;
+
+    case BVIEW_BST_CMD_API_GET_THRESHOLD:
+      {
+        reply_data->options.reportThreshold = true;
+        reply_data->response.report.active = ptr->threshold_record_ptr;
+        /* copy null as the encoder function expects the null  */
+        reply_data->response.report.backup = NULL;
+         reply_data->options.sendIncrementalReport = 
+                 false;
+      }
+      break;
+
+    case BVIEW_BST_CMD_API_GET_FEATURE:
+      reply_data->response.config = &ptr->bst_data->bst_config.config;
+      break;
+
+    case BVIEW_BST_CMD_API_GET_TRACK:
+      reply_data->response.track = &ptr->bst_data->bst_config.track;
+      break;
+    case BVIEW_BST_CMD_API_GET_SWITCH_PROPERTIES:
+      reply_data->switchProperties = bst_info.switchProperties;
+     break; 
+    default:
+      break;
+  }
+  /* release the lock for success and failed cases */
+
+  return bst_send_response(reply_data);
+}
+
+/*********************************************************************
+* @brief   :  function to post message to the bst application  
+*
+* @param[in]  msg_data : pointer to the message request
+*
+* @retval  : BVIEW_STATUS_SUCCESS : if the message is successfully posted to BST queue.
+* @retval  : BVIEW_STATUS_FAILURE : if the message is failed to send to bst
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*            
+* @note  : all the apis and call back functions should use this api
+*          to post the message to bst application.
+*
+*********************************************************************/
+BVIEW_STATUS bst_send_request (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  int rv = BVIEW_STATUS_SUCCESS;
+  struct mq_attr obuf; /* output attr struct for getattr */
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  if (-1 == msgsnd (bst_info.recvMsgQid, msg_data, sizeof (BVIEW_BST_REQUEST_MSG_t), IPC_NOWAIT))
+  {
+    if ( ! mq_getattr(bst_info.recvMsgQid,&obuf) )
+    {
+      _BST_LOG(_BST_DEBUG_TRACE, "flags: %ld  maxmsg: %ld  msgsize: %ld  curmsgs: %ld\n",
+          obuf.mq_flags, obuf.mq_maxmsg, obuf.mq_msgsize, obuf.mq_curmsgs);
+    }
+
+    LOG_POST (BVIEW_LOG_ERROR,
+              "Failed to send message to bst application,  msg_type  %ld, err = %d\r\n",
+              msg_data->msg_type, errno);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+
+  return rv;
+}
+
+/*********************************************************************
+*  @brief:  callback function to send periodic reports  
+*
+* @param[in]   sigval : Data passed with notification after timer expires
+*
+* @retval  : BVIEW_STATUS_SUCCESS : message is successfully posted to bst.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note : when the periodic collection timer expires, this api is invoked in
+*         the timer context. We just post the request for the report, while 
+*        posting we mark the report type as periodic. The parameter returned 
+*       from the callback is the reference to unit id. 
+*
+*********************************************************************/
+BVIEW_STATUS bst_periodic_collection_cb (union sigval sigval)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv; 
+
+  msg_data.report_type = BVIEW_BST_STATS_PERIODIC;
+  msg_data.msg_type = BVIEW_BST_CMD_API_GET_REPORT;
+  msg_data.unit = (*(int *)sigval.sival_ptr);
+  /* Send the message to the bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "Failed to send periodic collection message to bst application. err = %d\r\n", rv);
+       return BVIEW_STATUS_FAILURE;
+  }  
+    LOG_POST (BVIEW_LOG_INFO,
+        "timer call back received for unit = %d\r\n", *(int *)sigval.sival_ptr);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+*  @brief:  function to clean up  bst application  
+*
+* @param[in]  none 
+*
+* @retval  : none
+*
+* @note  When in case of any error event, this api cleans up all the resources.
+*         i.e it deletes the timer notes, if any are present.
+*         destroy the mutexes. clears the memory and destroys the message queue.
+*
+*********************************************************************/
+void bst_app_uninit ()
+{
+  int id = 0, num_units;
+  pthread_mutex_t *bst_mutex;
+  pthread_rwlock_t *bst_configRWLock;
+
+  bst_info.key1 = MSG_QUEUE_ID_TO_BST;
+  bst_info.trigger_key = MSG_QUEUE_ID_TO_BST_TRIGGER;
+
+  if (BVIEW_STATUS_SUCCESS != sbapi_system_num_units_get (&num_units))
+  {
+    LOG_POST (BVIEW_LOG_ERROR, "Failed to get num of units\r\n");
+  }
+  if (NULL != bst_info.switchProperties)
+  {
+     free (bst_info.switchProperties);
+  }
+  for (id = 0; id < num_units; id++)
+  {
+    /* if periodic collection is enabled
+       delete the timer.
+       loop through all the units and close
+     */
+    bst_periodic_collection_timer_delete (id);
+    /* Destroy mutex */
+    bst_mutex = &bst_info.unit[id].bst_mutex;
+    pthread_mutex_destroy (bst_mutex);
+
+    bst_configRWLock = &bst_info.unit[id].bst_configRWLock;
+    pthread_rwlock_destroy (bst_configRWLock);
+
+    /* free all memeory */
+    if (NULL != bst_info.unit[id].bst_data)
+    {
+      free (bst_info.unit[id].bst_data);
+    }
+
+    if (NULL != bst_info.unit[id].stats_active_record_ptr)
+    {
+      free (bst_info.unit[id].stats_active_record_ptr);
+    }
+
+    if (NULL != bst_info.unit[id].stats_backup_record_ptr)
+    {
+      free (bst_info.unit[id].stats_backup_record_ptr);
+    }
+
+    if (NULL != bst_info.unit[id].stats_current_record_ptr)
+    {
+      free (bst_info.unit[id].stats_current_record_ptr);
+    }
+
+    if (NULL != bst_info.unit[id].threshold_record_ptr)
+    {
+      free (bst_info.unit[id].threshold_record_ptr);
+    }
+  }
+  
+  /* check if the message queue already exists.
+     If yes, we should delete the same */
+  if (-1 == (bst_info.recvMsgQid = msgget(bst_info.key1, IPC_EXCL | IPC_CREAT | 0777)))
+  {
+    if (EEXIST == errno)
+    {
+      /* delete the message queue  */
+      if (msgctl(bst_info.recvMsgQid, IPC_RMID, NULL) == -1) 
+      {
+        LOG_POST (BVIEW_LOG_ERROR,
+            "Failed to destroy bst msgQ id, err = %d\n", errno);
+      }
+    }
+  }
+}
+
+/*********************************************************************
+* @brief : function to create the bst application thread.
+*
+* @param[in]  none 
+*
+* @retval  : BVIEW_STATUS_RESOURCE_NOT_AVAILABLE : Returns when memory is not available
+* @retval  : BVIEW_STATUS_FAILURE : failed to create the message queue or thread. 
+* @retval  : BVIEW_STATUS_SUCCESS : successful completion of task creation. 
+* @retval  : BVIEW_STATUS_INIT_FAILED : BST initialization failed. 
+*
+* @note : Main function to invoke the bst thread. This function allocates 
+*         the required memory for bst application. 
+*         Creates the mutexes for the bst data. Creates the message queue
+*         It assumes that the system is initialized before the bst 
+* @retval  : none
+*         thread is invoked. This api depends on the system variables 
+*         such as number of units per device. Incase of no such 
+*         need, the number of units can be #defined.
+*
+*********************************************************************/
+BVIEW_STATUS bst_main ()
+{
+  unsigned int id = 0, num_units = 0;
+  int rv = BVIEW_STATUS_SUCCESS;
+  int recvMsgQid;
+  pthread_rwlock_t *bst_configRWLock;
+
+
+  bst_info.key1 = MSG_QUEUE_ID_TO_BST;
+  bst_info.trigger_key = MSG_QUEUE_ID_TO_BST_TRIGGER;
+
+
+  /* create mutex for all units */
+  for (id = 0; id < BVIEW_BST_MAX_UNITS; id++)
+  {
+    bst_mutex = &bst_info.unit[id].bst_mutex;
+    pthread_mutex_init (bst_mutex, NULL);
+
+    bst_configRWLock = &bst_info.unit[id].bst_configRWLock;
+    /* Initialize Read Write lock with default attributes */
+    pthread_rwlock_init (bst_configRWLock, NULL);
+  }
+
+  /* get the number of units */
+  if (BVIEW_STATUS_SUCCESS != sbapi_system_num_units_get ((int *) &num_units))
+  {
+    /* Free the resources allocated so far */
+    bst_app_uninit ();
+
+    LOG_POST (BVIEW_LOG_EMERGENCY,
+              "Failed to number of units, Unable to start bst application\r\n");
+    return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE;
+  }
+  /* allocate memory for switch properties*/
+  bst_info.switchProperties = 
+          (BVIEW_SWITCH_PROPERTIES_t *) malloc (sizeof (BVIEW_SWITCH_PROPERTIES_t));
+  if (bst_info.switchProperties == NULL)
+  {
+    LOG_POST (BVIEW_LOG_EMERGENCY,
+                "Failed to allocate memory for bst application\r\n");
+    return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE;
+  }
+
+  memset (bst_info.switchProperties, 0x00, 
+                    sizeof (BVIEW_SWITCH_PROPERTIES_t));
+
+  /* allocate memory for all units */
+  for (id = 0; id < num_units; id++)
+  {
+    /* config variables */
+    bst_info.unit[id].bst_data =
+      (BVIEW_BST_DATA_t *) malloc (sizeof (BVIEW_BST_DATA_t));
+
+    /* stats records */
+    bst_info.unit[id].stats_active_record_ptr =
+      (BVIEW_BST_REPORT_SNAPSHOT_t *)
+      malloc (sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+    bst_info.unit[id].stats_backup_record_ptr =
+      (BVIEW_BST_REPORT_SNAPSHOT_t *)
+      malloc (sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+    bst_info.unit[id].stats_current_record_ptr =
+      (BVIEW_BST_REPORT_SNAPSHOT_t *)
+      malloc (sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+
+    /* threshold records */
+    bst_info.unit[id].threshold_record_ptr =
+      (BVIEW_BST_REPORT_SNAPSHOT_t *)
+      malloc (sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+
+    if ((NULL == bst_info.unit[id].bst_data) ||
+        (NULL == bst_info.unit[id].stats_active_record_ptr) ||
+        (NULL == bst_info.unit[id].stats_backup_record_ptr) ||
+        (NULL == bst_info.unit[id].stats_current_record_ptr) ||
+        (NULL == bst_info.unit[id].threshold_record_ptr))
+    {
+      /* Free the resources allocated so far */
+      bst_app_uninit ();
+
+      LOG_POST (BVIEW_LOG_EMERGENCY,
+                "Failed to allocate memory for bst application\r\n");
+      return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE;
+    }
+  }
+
+  for (id = 0; id < num_units; id++)
+  {
+    memset (bst_info.unit[id].bst_data, 0, sizeof (BVIEW_BST_DATA_t));
+
+    memset (bst_info.unit[id].stats_active_record_ptr, 0,
+            sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+    memset (bst_info.unit[id].stats_backup_record_ptr, 0,
+            sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+    memset (bst_info.unit[id].stats_current_record_ptr, 0,
+            sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+
+    memset (bst_info.unit[id].threshold_record_ptr, 0,
+            sizeof (BVIEW_BST_REPORT_SNAPSHOT_t));
+  }
+
+  LOG_POST (BVIEW_LOG_INFO,
+              "bst application: bst memory allocated successfully\r\n");
+
+  if (BVIEW_STATUS_SUCCESS != bst_app_config_init (num_units))
+  {
+    /* Free the resources allocated so far */
+     /*bst_app_uninit (); */
+    return BVIEW_STATUS_INIT_FAILED;
+  }
+
+
+
+
+   /* Check if message queue is already exitsing */
+  if (0 > (recvMsgQid = msgget(bst_info.key1, IPC_EXCL | IPC_CREAT | 0777)))
+  {
+    if (EEXIST == errno)
+    {
+
+     /* get the already existing  message queue id for bst */
+      if ((recvMsgQid = msgget (bst_info.key1, IPC_CREAT | 0777)) < 0)
+      {
+        /* Free the resources allocated so far */
+        //bst_app_uninit ();
+
+        LOG_POST (BVIEW_LOG_EMERGENCY,
+            "Failed to create  msgQ for bst application. err = %d\n", errno);
+        return  BVIEW_STATUS_FAILURE;
+      }
+
+      /* message queue exits.. Delete the message queue */
+      if  (msgctl(recvMsgQid, IPC_RMID, (struct msqid_ds *)NULL) <0) 
+      {
+        LOG_POST (BVIEW_LOG_EMERGENCY,
+            "Failed to destroy bst msgQ id, err = %d\n", errno);
+      }
+
+
+      /* create the message queue for bst */
+      if ((recvMsgQid = msgget (bst_info.key1, IPC_CREAT | 0777)) < 0)
+      {
+        /* Free the resources allocated so far */
+        bst_app_uninit ();
+
+        LOG_POST (BVIEW_LOG_EMERGENCY,
+              "Failed to create  msgQ for bst application. err = %d\n", errno);
+        return  BVIEW_STATUS_FAILURE;
+      }
+    }
+  }
+  bst_info.recvMsgQid = recvMsgQid;
+
+   /* create pthread for bst application */
+  if (0 != pthread_create (&bst_info.bst_thread, NULL, (void *) &bst_app_main, NULL))
+  {
+    LOG_POST (BVIEW_LOG_EMERGENCY, "BST  thread creation failed %d\r\n", errno);
+    return  BVIEW_STATUS_FAILURE;
+  }
+    LOG_POST (BVIEW_LOG_INFO,
+              "bst application: bst pthread created\r\n");
+
+
+   /* Check if message queue is already exitsing */
+  if (0 > (recvMsgQid = msgget(bst_info.trigger_key, IPC_EXCL | IPC_CREAT | 0777)))
+  {
+    if (EEXIST == errno)
+    {
+
+     /* get the already existing  message queue id for bst */
+      if ((recvMsgQid = msgget (bst_info.trigger_key, IPC_CREAT | 0777)) < 0)
+      {
+        /* Free the resources allocated so far */
+        //bst_app_uninit ();
+
+        LOG_POST (BVIEW_LOG_EMERGENCY,
+            "Failed to create  msgQ for bst trigger. err = %d\n", errno);
+        return  BVIEW_STATUS_FAILURE;
+      }
+
+      /* message queue exits..
+         Delete the message queue */
+      if  (msgctl(recvMsgQid, IPC_RMID, (struct msqid_ds *)NULL) <0) 
+      {
+        LOG_POST (BVIEW_LOG_EMERGENCY,
+            "Failed to destroy bst msgQ id, err = %d\n", errno);
+      }
+
+
+  /* create the message queue for bst */
+      if ((recvMsgQid = msgget (bst_info.trigger_key, IPC_CREAT | 0777)) < 0)
+  {
+    /* Free the resources allocated so far */
+    bst_app_uninit ();
+
+    LOG_POST (BVIEW_LOG_EMERGENCY,
+              "Failed to create  msgQ for bst application. err = %d\n", errno);
+    return  BVIEW_STATUS_FAILURE;
+  }
+
+    }
+  }
+  bst_info.recvTriggerMsgQid = recvMsgQid;
+
+   /* create pthread for bst application */
+  if (0 != pthread_create (&bst_info.bst_trigger_thread, NULL, (void *) &bst_trigger_main, NULL))
+  {
+    LOG_POST (BVIEW_LOG_EMERGENCY, "BST  trigger processing thread creation failed %d\r\n", errno);
+    return  BVIEW_STATUS_FAILURE;
+  }
+    LOG_POST (BVIEW_LOG_INFO,
+              "bst application: bst trigger process pthread created\r\n");
+
+
+
+  return rv;
+}
+
+
+/*********************************************************************
+*  @brief:  function to set the given realm in the include trigger report.  
+*
+* @param[in]   *realm : pointer to realm 
+* @param[in]   *realm : pointer to json encode options 
+*
+* @retval  : none : 
+*
+* @note :
+*
+*********************************************************************/
+
+void bst_set_realm_to_collect(char *realm, BVIEW_BST_REPORT_OPTIONS_t *options)
+{
+  if (0 == strcmp("device", realm))
+  {
+    options->includeDevice = true;
+    return;
+  }
+  
+  if (0 == strcmp("ingress-service-pool", realm))
+  {
+    options->includeIngressServicePool = true;
+    return;
+  }
+
+  if (0 == strcmp("ingress-port-service-pool", realm))
+  {
+    options->includeIngressPortServicePool = true;
+    return;
+  }
+  
+  if (0 == strcmp("ingress-port-priority-group", realm))
+  {
+    options->includeIngressPortPriorityGroup = true;
+    return;
+  }
+
+  if (0 == strcmp("egress-port-service-pool", realm))
+  {
+    options->includeEgressPortServicePool = true;
+    return;
+  }
+
+  if (0 == strcmp("egress-service-pool", realm))
+  {
+    options->includeEgressServicePool = true;
+    return;
+  }
+
+  if (0 == strcmp("egress-uc-queue", realm))
+  {
+    options->includeEgressUcQueue = true;
+    return;
+  }
+
+  if (0 == strcmp("egress-uc-queue-group", realm))
+  {
+    options->includeEgressUcQueueGroup = true;
+    return;
+  }
+
+  if (0 == strcmp("egress-mc-queue", realm))
+  {
+    options->includeEgressMcQueue = true;
+    return;
+  }
+
+  if (0 == strcmp("egress-cpu-queue", realm))
+  {
+    options->includeEgressCpuQueue = true;
+    return;
+  }
+
+  if (0 == strcmp("egress-rqe-queue", realm))
+  {
+    options->includeEgressRqeQueue = true;
+    return;
+  }
+
+  return;
+}
+
diff --git a/src/apps/bst/bst_nb_api.c b/src/apps/bst/bst_nb_api.c
new file mode 100755
index 0000000..882b547
--- /dev/null
+++ b/src/apps/bst/bst_nb_api.c
@@ -0,0 +1,735 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include "json.h"
+#include "bst_json_memory.h"
+#include "clear_bst_statistics.h"
+#include "clear_bst_thresholds.h"
+#include "configure_bst_thresholds.h"
+#include "configure_bst_feature.h"
+#include "configure_bst_tracking.h"
+#include "get_bst_tracking.h"
+#include "get_bst_feature.h"
+#include "get_bst_thresholds.h"
+#include "get_bst_report.h"
+#include "get_switch_properties.h"
+#include "bst_json_encoder.h"
+#include "system.h"
+#include "bst.h"
+#include "broadview.h"
+#include "openapps_log_api.h"
+#include "bst_app.h"
+#include "common/platform_spec.h"
+
+/*********************************************************************
+  * @brief : function to return the threshold type for the given realm
+  *
+  * @param[in] str : realm passed in the input request
+  *
+  * @retval    : the threshold type value
+  *
+  * @note : The minumum value of enum type is starts from 1.
+  *         if 0 is returned then the given realm didn't match
+  *         with any of the supported realm types 
+  *
+  *********************************************************************/
+static unsigned int bst_realm_type_get (char *str)
+{
+  unsigned int i = 0;
+
+  const BVIEW_BST_REALM_THRESHOLD_t realm_threshold_map[] = {
+    {"device", BVIEW_BST_DEVICE_THRESHOLD},
+    {"ingress-port-priority-group", BVIEW_BST_INGRESS_PORT_PG_THRESHOLD},
+    {"ingress-port-service-pool", BVIEW_BST_INGRESS_PORT_SP_THRESHOLD},
+    {"ingress-service-pool", BVIEW_BST_INGRESS_SP_THRESHOLD},
+    {"egress-port-service-pool", BVIEW_BST_EGRESS_PORT_SP_THRESHOLD},
+    {"egress-service-pool", BVIEW_BST_EGRESS_SP_THRESHOLD},
+    {"egress-uc-queue", BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD},
+    {"egress-uc-queue-group", BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD},
+    {"egress-mc-queue", BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD},
+    {"egress-cpu-queue", BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD},
+    {"egress-rqe-queue", BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD}
+  };
+  for (i = BVIEW_BST_MAX_THRESHOLD_TYPE_MIN; i <= BVIEW_BST_MAX_THRESHOLD_TYPE_MAX; i++)
+  {
+    if (0 == strcmp (str, realm_threshold_map[i-1].realm))
+    {
+       _BST_LOG(_BST_DEBUG_TRACE, "requested realm %s found match for the realm type %d\n", str, realm_threshold_map[i-1].threshold);
+      return realm_threshold_map[i-1].threshold;
+    }
+  }
+
+  _BST_LOG(_BST_DEBUG_ERROR, "requested realm %s not found match for the realm type \n ", str);
+  return 0;
+}
+
+/*********************************************************************
+* @brief : REST API handler to clear the bst stats
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note : This api posts the request to bst application to clear stats. 
+*
+*********************************************************************/
+BVIEW_STATUS bstjson_clear_bst_statistics_impl (void *cookie, int asicId,
+                                                int id,
+                                                BSTJSON_CLEAR_BST_STATISTICS_t *
+                                                pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  /* copy the params from the request */
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.id = id;
+  msg_data.msg_type = BVIEW_BST_CMD_API_CLEAR_STATS;
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+   _BST_LOG(_BST_DEBUG_ERROR, "bstjson_clear_bst_statistics_impl: failed to post clear bst stats request to bst queue. err = %d.\r\n",rv);
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post clear bst stats request to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+/*********************************************************************
+* @brief : REST API handler to clear the bst thresholds
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to clear stats.
+*
+*********************************************************************/
+BVIEW_STATUS bstjson_clear_bst_thresholds_impl (void *cookie, int asicId,
+                                                int id,
+                                                BSTJSON_CLEAR_BST_THRESHOLDS_t *
+                                                pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  /* copy the params from the decoded request */
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_CLEAR_THRESHOLD;
+  msg_data.id = id;
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+   _BST_LOG(_BST_DEBUG_ERROR, "bstjson_clear_bst_thresholds_impl: failed to post clear bst thresholds request to bst queue. err = %d.\r\n",rv);
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post clear bst thresholds request to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to configure the bst feature params
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to configures bst feature params.
+*
+* @end
+*********************************************************************/
+BVIEW_STATUS bstjson_configure_bst_feature_impl (void *cookie, int asicId,
+                                                 int id,
+                                                 BSTJSON_CONFIGURE_BST_FEATURE_t
+                                                 * pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  if (NULL == pCommand)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_SET_FEATURE;
+  msg_data.id = id;
+  msg_data.request.config = *pCommand;
+
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+   _BST_LOG(_BST_DEBUG_ERROR, "bstjson_configure_bst_feature_impl: failed to post confiigure bst feature to bst queue. err = %d.\r\n",rv);
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post confiigure bst feature to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to configure the bst thresholds 
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to configures bst thresholds.
+*            The validation for the input params for thresholds is done in this api.
+*            If the input is invalid, then error is returned
+*
+* @end
+*********************************************************************/
+BVIEW_STATUS bstjson_configure_bst_thresholds_impl (void *cookie, int asicId,
+                                                    int id,
+                                                    BSTJSON_CONFIGURE_BST_THRESHOLDS_t
+                                                    * pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  unsigned int threshold_type;
+  BVIEW_ASIC_CAPABILITIES_t capabilities;
+
+  if (NULL == pCommand)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_SET_THRESHOLD;
+  msg_data.id = id;
+
+  memcpy (msg_data.realm, pCommand->realm, JSON_MAX_NODE_LENGTH);
+
+  threshold_type = bst_realm_type_get (pCommand->realm);
+
+  if (0 == threshold_type)
+  {
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Invalid threshold type in request. \r\n");
+   _BST_LOG(_BST_DEBUG_ERROR, "bstjson_configure_bst_thresholds_impl: Invalid threshold type in request. \r\n");
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  msg_data.threshold_type = threshold_type;
+
+  memset(&capabilities, 0, sizeof(BVIEW_ASIC_CAPABILITIES_t));
+
+
+  if (BVIEW_STATUS_SUCCESS != sbapi_system_asic_capabilities_get(asicId,
+        &capabilities))
+  {
+    /* unable to get the asic capabilities
+       log error and return */
+    LOG_POST (BVIEW_LOG_ERROR,
+        "Failed to Get Asic capabilities for unit %d. \r\n", asicId);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  _BST_INPUT_PARAMS_CHECK(threshold_type, capabilities, pCommand);
+
+  switch (threshold_type)
+  {
+  case BVIEW_BST_DEVICE_THRESHOLD:
+    
+    if(BVIEW_BST_DEVICE_THRESHOLD_CHECK (pCommand))
+    {
+      rv = BVIEW_STATUS_INVALID_PARAMETER;
+    }
+    else
+    {
+      msg_data.request.device_threshold.threshold = pCommand->threshold;
+    }
+    break;
+
+  case BVIEW_BST_INGRESS_PORT_PG_THRESHOLD:
+    {
+      if ((0 == pCommand->port) ||
+          (BVIEW_BST_IPPG_SHRD_THRESHOLD_CHECK (pCommand)) ||
+          (BVIEW_BST_IPPG_HDRM_THRESHOLD_CHECK (pCommand)))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.port = pCommand->port;
+        msg_data.threshold.priorityGroup = pCommand->priorityGroup;
+        msg_data.request.i_p_pg_threshold.umShareThreshold =
+          pCommand->umShareThreshold;
+        msg_data.request.i_p_pg_threshold.umHeadroomThreshold =
+          pCommand->umHeadroomThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_INGRESS_PORT_SP_THRESHOLD:
+    {
+      if ((0 == pCommand->port) || (BVIEW_BST_IPSP_THRESHOLD_CHECK (pCommand)))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.port = pCommand->port;
+        msg_data.threshold.servicePool = pCommand->servicePool;
+        msg_data.request.i_p_sp_threshold.umShareThreshold =
+          pCommand->umShareThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_INGRESS_SP_THRESHOLD:
+    {
+      if ((BVIEW_BST_ISP_THRESHOLD_CHECK (pCommand)))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.servicePool = pCommand->servicePool;
+        msg_data.request.i_sp_threshold.umShareThreshold =
+          pCommand->umShareThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_EGRESS_PORT_SP_THRESHOLD:
+    {
+      if ((0 == pCommand->port) || 
+          (BVIEW_BST_EPSP_UC_THRESHOLD_CHECK (pCommand))||
+          (BVIEW_BST_EPSP_UM_THRESHOLD_CHECK (pCommand))||
+          BVIEW_BST_EPSP_MC_THRESHOLD_CHECK (pCommand) ||
+          BVIEW_BST_EPSP_MC_SQ_THRESHOLD_CHECK (pCommand))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.port = pCommand->port;
+        msg_data.threshold.servicePool = pCommand->servicePool;
+        msg_data.request.ep_sp_threshold.ucShareThreshold =
+          pCommand->ucShareThreshold;
+        msg_data.request.ep_sp_threshold.umShareThreshold =
+          pCommand->umShareThreshold;
+        msg_data.request.ep_sp_threshold.mcShareThreshold =
+          pCommand->mcShareThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_EGRESS_SP_THRESHOLD:
+    {
+      if ((BVIEW_BST_E_SP_UM_THRESHOLD_CHECK (pCommand)) ||
+          (BVIEW_BST_E_SP_MC_THRESHOLD_CHECK (pCommand)) ||
+          (BVIEW_BST_E_SP_MC_SQ_THRESHOLD_CHECK (pCommand)))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.servicePool = pCommand->servicePool;
+        msg_data.request.e_sp_threshold.umShareThreshold =
+          pCommand->umShareThreshold;
+        msg_data.request.e_sp_threshold.umShareThreshold =
+          pCommand->umShareThreshold;
+        msg_data.request.e_sp_threshold.mcShareThreshold =
+          pCommand->mcShareThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD:
+    {
+      if (BVIEW_BST_EGRESS_UC_THRESHOLD_CHECK (pCommand))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.queue = pCommand->queue;
+        msg_data.request.e_ucq_threshold.ucBufferThreshold =
+          pCommand->ucThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD:
+    {
+      if (pCommand->queue || pCommand->servicePool ||
+          pCommand->threshold || pCommand->umShareThreshold || pCommand->umHeadroomThreshold ||
+          pCommand->ucShareThreshold || pCommand->mcShareThreshold ||
+          pCommand->mcShareQueueEntriesThreshold || pCommand->mcThreshold ||
+          pCommand->mcQueueEntriesThreshold || pCommand->cpuThreshold ||
+          pCommand->rqeThreshold)
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+  
+      if (BVIEW_BST_EGRESS_UC_THRESHOLD_CHECK (pCommand))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.queueGroup = pCommand->queueGroup;
+        msg_data.request.e_ucqg_threshold.ucBufferThreshold =
+          pCommand->ucThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD:
+    {
+      if ((BVIEW_BST_E_MC_QG_THRESHOLD_CHECK (pCommand)) ||
+          (BVIEW_BST_E_MC_SQG_THRESHOLD_CHECK (pCommand)))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.queue = pCommand->queue;
+        msg_data.request.e_mcq_threshold.mcBufferThreshold =
+          pCommand->mcThreshold;
+        msg_data.request.e_mcq_threshold.mcQueueThreshold =
+          pCommand->mcQueueEntriesThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD:
+    {
+      if (BVIEW_BST_EGRESS_CPU_THRESHOLD_CHECK (pCommand))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.queue = pCommand->queue;
+        msg_data.request.cpu_q_threshold.cpuBufferThreshold =
+          pCommand->cpuThreshold;
+      }
+    }
+    break;
+
+  case BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD:
+    {
+      if (BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_CHECK (pCommand))
+      {
+        rv = BVIEW_STATUS_INVALID_PARAMETER;
+      }
+      else
+      {
+        msg_data.threshold.queue = pCommand->queue;
+        msg_data.request.rqe_q_threshold.rqeBufferThreshold =
+          pCommand->rqeThreshold;
+      }
+    }
+    break;
+
+  default:
+    break;
+  }
+
+  if (BVIEW_STATUS_SUCCESS == rv)
+  {
+  /* send message to bst application */
+    rv = bst_send_request (&msg_data);
+  }
+  else
+  {
+   _BST_LOG(_BST_DEBUG_ERROR, "validation for  bst threshold config has failed for threshold type %s, err = %d. \r\n",pCommand->realm, rv);
+    LOG_POST (BVIEW_LOG_ERROR,
+        "validation for  bst threshold config has failed for threshold type %s, err = %d. \r\n",pCommand->realm, rv);
+  }
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to configure the bst track params 
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to set the track params.
+*
+* @end
+*********************************************************************/
+BVIEW_STATUS bstjson_configure_bst_tracking_impl (void *cookie, int asicId,
+                                                  int id,
+                                                  BSTJSON_CONFIGURE_BST_TRACKING_t
+                                                  * pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  if (NULL == pCommand)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_SET_TRACK;
+  msg_data.id = id;
+ msg_data.request.track = *pCommand;
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post configure bst tracking to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to get the bst feature params 
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to get the bst feature params.
+*
+*********************************************************************/
+BVIEW_STATUS bstjson_get_bst_feature_impl (void *cookie, int asicId, int id, 
+                                           BSTJSON_GET_BST_FEATURE_t * pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_GET_FEATURE;
+  msg_data.id = id;
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post get bst feature to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to get switch properties params
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted 
+*            to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to get 
+*            switch properties params.
+*
+*********************************************************************/
+BVIEW_STATUS bstjson_get_switch_properties_impl (void *cookie, int asicId, 
+                                                 int id,
+                                                 BSTJSON_GET_SWITCH_PROPERTIES_t *pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_GET_SWITCH_PROPERTIES;
+  msg_data.id = id;
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post get switch properties to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to get the bst report params 
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to get the bst report.
+*             As a response to this request the report is sent.
+*
+*********************************************************************/
+BVIEW_STATUS bstjson_get_bst_report_impl (void *cookie, int asicId, int id,
+                                          BSTJSON_GET_BST_REPORT_t * pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  if (NULL == pCommand)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_GET_REPORT;
+  msg_data.id = id;
+  msg_data.request.collect = *pCommand;
+
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post get bst report to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to get the bst threshold 
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to get the bst thresholds.
+*
+*********************************************************************/
+BVIEW_STATUS bstjson_get_bst_thresholds_impl (void *cookie, int asicId, int id,
+                                              BSTJSON_GET_BST_THRESHOLDS_t *
+                                              pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  if (NULL == pCommand)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_GET_THRESHOLD;
+  msg_data.id = id;
+
+  memcpy (&msg_data.request.collect, pCommand, sizeof(BSTJSON_GET_BST_THRESHOLDS_t));
+
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post get bst thresholds to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief : REST API handler to get the bst tracking params
+*
+* @param[in] cookie : pointer to the cookie
+* @param[in] asicId : asic id 
+* @param[in] id     : unit id
+* @param[in] pCommand : pointer to the input command structure
+*
+* @retval  : BVIEW_STATUS_SUCCESS : the message is successfully posted to bst queue.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post the message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note    : This api posts the request to bst application to get the bst thresholds.
+*
+*********************************************************************/
+BVIEW_STATUS bstjson_get_bst_tracking_impl (void *cookie, int asicId, int id,
+                                            BSTJSON_GET_BST_TRACKING_t *
+                                            pCommand)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv;
+
+  if (NULL == pCommand)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  memset (&msg_data, 0, sizeof (BVIEW_BST_REQUEST_MSG_t));
+  msg_data.unit = asicId;
+  msg_data.cookie = cookie;
+  msg_data.msg_type = BVIEW_BST_CMD_API_GET_TRACK;
+  msg_data.id = id;
+  /* send message to bst application */
+  rv = bst_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "failed to post get bst tracking to bst queue. err = %d.\r\n",rv);
+  }
+  return rv;
+}
+
+
diff --git a/src/apps/bst/bst_trigger.c b/src/apps/bst/bst_trigger.c
new file mode 100755
index 0000000..6dad937
--- /dev/null
+++ b/src/apps/bst/bst_trigger.c
@@ -0,0 +1,519 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/msg.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include <errno.h>
+#include "configure_bst_thresholds.h"
+#include "configure_bst_feature.h"
+#include "configure_bst_tracking.h"
+#include "get_bst_tracking.h"
+#include "get_bst_feature.h"
+#include "get_bst_thresholds.h"
+#include "get_bst_report.h"
+#include "bst_json_encoder.h"
+#include "bst.h"
+#include "broadview.h"
+#include "bst_app.h"
+#include "system.h"
+#include "openapps_log_api.h"
+#include "sbplugin_redirect_bst.h"
+#include "sbplugin_redirect_system.h"
+
+
+/* BST Context Info*/
+extern BVIEW_BST_CXT_t bst_info;
+/* BST rwlock for config data*/
+
+bool bst_trigger_index_get(char *realm, char *counter, unsigned int *val)
+{
+  static BST_REALM_COUNTER_INDEX_t bst_realm_index_map [] = {
+    {BST_ID_DEVICE, "device" ,"data"},
+    {BST_ID_ING_POOL, "ingress-service-pool", "um-share-buffer-count"},
+    {BST_ID_PORT_POOL, "ingress-port-service-pool", "um-share-buffer-count" },
+    {BST_ID_PRI_GROUP_SHARED, "ingress-port-priority-group", "um-share-buffer-count"},
+    {BST_ID_PRI_GROUP_HEADROOM, "ingress-port-priority-group", "um-headroom-buffer-count"},
+    {BST_ID_EGR_POOL, "egress-port-service-pool", "um-share-buffer-count"},
+    {BST_ID_EGR_MCAST_POOL, "egress-port-service-pool", "mc-share-buffer-count"},
+    {BST_ID_UCAST, "egress-uc-queue", "uc-buffer-count"},
+    {BST_ID_MCAST, "egress-mc-queue", "mc-buffer-count"},
+    {BST_ID_EGR_UCAST_PORT_SHARED, "egress-port-service-pool", "uc-share-buffer-count"},
+    {BST_ID_EGR_PORT_SHARED, "egress-port-service-pool", "um-share-buffer-count"},
+    {BST_ID_RQE_QUEUE, "egress-rqe-queue", "rqe-buffer-count"},
+    {BST_ID_UCAST_GROUP, "egress-uc-queue-group", "uc-buffer-count"}
+  };
+
+  unsigned int i;
+
+  if ((NULL == realm) ||
+      (NULL == counter) || 
+      (NULL == val))
+  {
+    return false;
+  }
+
+  for (i = 0; i <BST_ID_MAX; i++)
+  {
+    if ((0 == strcmp(realm, bst_realm_index_map[i].realm)) && 
+        (0 == strcmp (counter, bst_realm_index_map[i].counter)))
+    {
+      *val = bst_realm_index_map[i].index;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/*********************************************************************
+* @brief : enable bst on trigger 
+*
+* @param[in] msg_data : pointer to the bst message request.
+* @param[in] bstEnable : bst enable or disable.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : successfully re-enabled bst 
+* @retval  : BVIEW_STATUS_FAILURE : failed to re-enable bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameter.
+*
+* @note
+*
+*********************************************************************/
+BVIEW_STATUS bst_enable_on_trigger(BVIEW_BST_REQUEST_MSG_t *msg_data, int bstEnable)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_CONFIG_t bstMode;
+
+  if ((BVIEW_BST_CMD_API_TRIGGER_REPORT != msg_data->msg_type) &&
+      (BVIEW_BST_CMD_API_ENABLE_BST_ON_TRIGGER != msg_data->msg_type))
+  {
+    /* ignore */
+    return BVIEW_STATUS_SUCCESS;
+  }
+
+  memset (&bstMode, 0, sizeof (BVIEW_BST_CONFIG_t));
+  bstMode.enableDeviceStatsMonitoring = BVIEW_BST_DEFAULT_TRACK_DEVICE;
+  bstMode.enableIngressStatsMonitoring = BVIEW_BST_DEFAULT_TRACK_INGRESS;
+  bstMode.enableEgressStatsMonitoring = BVIEW_BST_DEFAULT_TRACK_EGRESS;
+  bstMode.mode = BVIEW_BST_MODE_CURRENT;
+  bstMode.enableStatsMonitoring = true;
+  /* Set the asic with the desired config to control bst */
+  rv = sbapi_bst_config_set (msg_data->unit, &bstMode);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    _BST_LOG(_BST_DEBUG_TRACE,"Failed to enable the bst on unit %d\r\n", msg_data->unit);
+  }
+
+  return rv;
+
+}
+
+
+
+/*********************************************************************
+* @brief : bst trigger main application function which does processing of 
+*          trigger messages
+*
+* @param[in] : none
+*
+* @retval  : BVIEW_STATUS_SUCCESS: 
+* @retval  : BVIEW_STATUS_FAILURE: Fails to process the trigger messages 
+*
+* @note  : This api is the processing thread of the bst trigger application. 
+*          All the incoming requests are processed. 
+*          Currently the assumption is made that if the 
+*          thread fails to read continously 10 or more messages,
+*          then there is some error and the thread exits.
+*
+*********************************************************************/
+
+BVIEW_STATUS bst_trigger_main(void)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv = BVIEW_STATUS_FAILURE;
+  unsigned int rcvd_err = 0;
+  unsigned int num_units = 0;
+  BVIEW_BST_API_HANDLER_t handler;
+
+  while (1)
+  {
+    if (-1 != (msgrcv (bst_info.recvTriggerMsgQid, &msg_data, sizeof (msg_data), 0, 0))) 
+    {
+      /* get num units */
+       num_units = 0;
+      if (BVIEW_STATUS_SUCCESS != sbapi_system_num_units_get ((int *) &num_units))
+      {
+        LOG_POST (BVIEW_LOG_ERROR, "Failed to get num of units\r\n");
+      }
+
+      _BST_LOG(_BST_DEBUG_INFO, "trigger : msg_data info\n"
+            "msg_data.msg_type = %ld\n"
+            "msg_data.unit = %d\n"
+            "msg_data.cookie = %d\n"
+            "num_units = %d\n",
+            msg_data.msg_type, msg_data.unit, (NULL == msg_data.cookie)? true: false, num_units); 
+
+      if (msg_data.unit >= num_units)
+      {
+        /* requested id is greater than the number of units.
+           send failure message and continue */
+          LOG_POST (BVIEW_LOG_ERROR,
+              "failed to send response for command %ld , err = %d. \r\n", msg_data.msg_type, rv);
+        continue;
+      }
+      /* Counter to check for read errors.. 
+        successfully read the message. clear this to 0*/
+      rcvd_err = 0;
+      /* get the api function for the method type */
+      if (BVIEW_STATUS_SUCCESS != bst_type_api_get(msg_data.msg_type, &handler))
+      {
+        continue;
+      }
+
+      handler(&msg_data);
+    }
+    else
+    {
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Failed to read message from the bst trigger application queue. err = %d\r\n", errno);
+      /* increment the error counter. 
+         If this counter increments continously exit and return failure
+         so that corrective action can be taken */
+         rcvd_err++;
+
+         /* wait till 10 consective messages */
+         if(BVIEW_BST_MAX_QUEUE_SEND_FAILS < rcvd_err)
+         {
+           break;
+         }
+        continue;
+    }
+  }                             /* while (1) */
+             LOG_POST (BVIEW_LOG_EMERGENCY,
+                 "exiting from bst trigger pthread ... \r\n");
+  pthread_exit(&bst_info.bst_trigger_thread);
+  return BVIEW_STATUS_FAILURE;
+}
+
+/*********************************************************************
+* @brief : application function to process trigger messages 
+*
+* @param[in] msg_data : pointer to the bst message request.
+*
+* @retval  : BVIEW_STATUS_SUCCESS : when the request is successfully processed 
+* @retval  : BVIEW_STATUS_FAILURE : when the processing of the request failed. 
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : Inpput paramerts are invalid. 
+*
+* @note : This function is invoked in the bst thread context and used to 
+*         -- bst enable
+*         -- send the message to bst thread if the sending of trigger report is allowed. 
+*
+*********************************************************************/
+
+BVIEW_STATUS bst_process_trigger(BVIEW_BST_REQUEST_MSG_t *msg_data)
+{
+  bool send_trigger = true;
+  int bstMaxTriggers = 0;
+  BVIEW_BST_REQUEST_MSG_t bst_msg = {0};
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_BST_CONFIG_PARAMS_t *ptr = NULL;
+  unsigned int index = 0;
+
+  /* check if the trigger report needs to be collected */
+  send_trigger = bst_trigger_index_get(msg_data->triggerInfo.realm, 
+                                       msg_data->triggerInfo.counter,
+                                       &index);
+  if (true == send_trigger)
+  {
+    /* get the configuration structure pointer  for the desired unit */
+    ptr = BST_CONFIG_FEATURE_PTR_GET (msg_data->unit);
+    if (NULL == ptr)
+    {
+      return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+    /* take lock */
+    BST_RWLOCK_RD_LOCK (msg_data->unit);
+    bstMaxTriggers = ptr->bstMaxTriggers;
+    /* release lock */
+
+    if ((bst_info.unit[msg_data->unit].bst_trigger_count[index] >= bstMaxTriggers) && (0 != bstMaxTriggers))
+    {
+      send_trigger = false;
+    }
+    BST_RWLOCK_UNLOCK (msg_data->unit);
+  }
+
+  if (true == send_trigger)
+  {
+    /* post the trigger request to the bst thread */
+    bst_msg.unit = msg_data->unit;
+    bst_msg.msg_type = BVIEW_BST_CMD_API_TRIGGER_REPORT;
+    bst_msg.report_type = BVIEW_BST_STATS_TRIGGER;
+    memcpy(&bst_msg.triggerInfo, &msg_data->triggerInfo, sizeof(BVIEW_BST_TRIGGER_INFO_t));
+
+    /* Send the message to the bst application */
+    rv = bst_send_request (&bst_msg);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Failed to send trigger collection message to bst application. err = %d\r\n", rv);
+      return BVIEW_STATUS_FAILURE;
+    }
+    LOG_POST (BVIEW_LOG_INFO,
+        "trigger collet request sent to bst application successfully for unit %d\r\n", msg_data->unit);
+
+
+    if ((0 == bst_info.unit[msg_data->unit].bst_trigger_count[index]) && (0 != bstMaxTriggers))
+    {
+      /* start the timer */
+      bst_trigger_timer_add(msg_data->unit);
+    }
+  }
+    BST_RWLOCK_WR_LOCK (msg_data->unit);
+    bst_info.unit[msg_data->unit].bst_trigger_count[index]++;
+    BST_RWLOCK_UNLOCK (msg_data->unit);
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief   :  function to post message to the bst application  
+*
+* @param[in]  msg_data : pointer to the message request
+*
+* @retval  : BVIEW_STATUS_SUCCESS : if the message is successfully posted to BST queue.
+* @retval  : BVIEW_STATUS_FAILURE : if the message is failed to send to bst
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*            
+* @note  : all the apis and call back functions should use this api
+*          to post the message to bst application.
+*
+*********************************************************************/
+BVIEW_STATUS bst_trigger_send_request (BVIEW_BST_REQUEST_MSG_t * msg_data)
+{
+  int rv = BVIEW_STATUS_SUCCESS;
+
+  if (NULL == msg_data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  if (-1 == msgsnd (bst_info.recvTriggerMsgQid, msg_data, sizeof (BVIEW_BST_REQUEST_MSG_t), IPC_NOWAIT))
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+              "Failed to send message to bst application,  %ld, errno  %d\r\n",
+              msg_data->msg_type, errno);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+
+  return rv;
+}
+
+
+/*************************************************************
+*@brief:  Callback function to send the trigger to bst application
+*         to send periodic collection
+*
+* @param[in] unit : unit for which the trigger is generated 
+* @param[in] cookie : cookie
+* @param[in] type : trigger type
+*
+* @retval  : BVIEW_STATUS_SUCCESS
+* @retval  : BVIEW_STATUS_FAILURE
+*
+* @note  : callback function from ASIC to bst application 
+*          to send the triggers. This function is invoked 
+*          in the asic context, when the congigured thresholds 
+*          exceeds the values. In such case, 
+*          the trigger is generated by the asic and bst 
+*          application take a trigger report and sends the same to collector.
+*
+*************************************************************/
+BVIEW_STATUS bst_trigger_cb (int unit, void *cookie,
+                             BVIEW_BST_TRIGGER_INFO_t *triggerInfo)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data = {0};
+  BVIEW_STATUS rv;
+
+  msg_data.unit = unit;
+  msg_data.msg_type = BVIEW_BST_CMD_API_TRIGGER_COLLECT;
+  memcpy(&msg_data.triggerInfo, triggerInfo, sizeof(BVIEW_BST_TRIGGER_INFO_t));
+
+  /* Send the message to the bst application */
+  rv = bst_trigger_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+      "Failed to send trigger collection message to application. err = %d\r\n", rv);
+       return BVIEW_STATUS_FAILURE;
+  }
+    LOG_POST (BVIEW_LOG_INFO,
+      "trigger call back sent to application successfully for unit %d\r\n", unit);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+*  @brief:  callback function to clear the trigger count  
+*
+* @param[in]   sigval : Data passed with notification after timer expires
+*
+* @retval  : BVIEW_STATUS_SUCCESS : message is successfully posted to bst.
+* @retval  : BVIEW_STATUS_FAILURE : failed to post message to bst.
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER : invalid parameters to function.
+*
+* @note : when the trigger timer expires, this api is invoked in
+*         the timer context.
+*
+*********************************************************************/
+BVIEW_STATUS bst_trigger_timer_cb (union sigval sigval)
+{
+  BVIEW_BST_REQUEST_MSG_t msg_data;
+  BVIEW_STATUS rv; 
+
+  msg_data.msg_type = BVIEW_BST_CMD_API_CLEAR_TRIGGER_COUNT;
+  msg_data.unit = (*(int *)sigval.sival_ptr);
+  /* Send the message to the bst application */
+  rv = bst_trigger_send_request (&msg_data);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    LOG_POST (BVIEW_LOG_ERROR,
+        "Failed to send trigger count clear message to application. err = %d\r\n", rv);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+    LOG_POST (BVIEW_LOG_INFO,
+        "timer call back received for unit = %d\r\n", *(int *)sigval.sival_ptr);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief : function to add timer for the periodic stats collection 
+*
+* @param[in] unit : unit for which the periodic stats need to be collected.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- failed to add the timer 
+* @retval  : BVIEW_STATUS_SUCCESS -- timer is successfully added 
+*
+* @note : this api adds the timer to the linux timer thread, so when the timer 
+*         expires, we receive the callback and post message to the bst application
+*         to collect the stats.. this is a periodic timer , whose interval
+*         is equal to the collection interval. Note that collection is per
+*         unit and hence we need per timer per unit.
+*
+*********************************************************************/
+BVIEW_STATUS bst_trigger_timer_add (unsigned int  unit)
+{
+  BVIEW_BST_CONFIG_PARAMS_t *ptr;
+  BVIEW_BST_DATA_t *bst_data_ptr;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  int interval = 0;
+
+  bst_data_ptr = BST_UNIT_DATA_PTR_GET (unit);
+  ptr = BST_CONFIG_FEATURE_PTR_GET (unit);
+
+  if ((NULL == bst_data_ptr) || (NULL == ptr)) 
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* check if the timer node is already in use.
+  */
+    /* take lock */
+    BST_RWLOCK_WR_LOCK (unit);
+
+  if (true != bst_data_ptr->bst_trigger_timer.in_use)
+  {
+    interval = ptr->triggerTransmitInterval;
+
+
+    /* The timer add function expects the time in milli seconds..
+       so convert the time into milli seconds. , before adding
+       the timer node */
+    
+    rv =  system_timer_add (bst_trigger_timer_cb,
+        &bst_data_ptr->bst_trigger_timer.bstTimer,
+        interval*BVIEW_BST_TIME_CONVERSION_FACTOR,
+        PERIODIC_MODE, &bst_data_ptr->bst_trigger_timer.unit);
+
+    if (BVIEW_STATUS_SUCCESS == rv)
+    {
+      bst_data_ptr->bst_trigger_timer.in_use = true;
+      LOG_POST (BVIEW_LOG_INFO,
+          "bst application: trigger timer is successfully started for unit %d.\r\n", unit);
+    }
+    else
+    {
+      /* timer node add has failed. log the same */
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Failed to add trigger timer for unit %d, err %d \r\n", unit, rv);
+    }
+  }
+    /* release lock */
+    BST_RWLOCK_UNLOCK (unit);
+  return rv;
+}
+
+
+/*********************************************************************
+* @brief : Deletes the timer node for the given unit
+*
+* @param[in] unit : unit id for which  the timer needs to be deleted.
+*
+* @retval  : BVIEW_STATUS_INVALID_PARAMETER -- Inpput paramerts are invalid. 
+* @retval  : BVIEW_STATUS_FAILURE -- timer is successfully deleted 
+* @retval  : BVIEW_STATUS_SUCCESS -- failed to delete the timer 
+*
+* @note  : The periodic timer is deleted when send asyncronous reporting
+*          is turned off. This timer is per unit.
+*
+*********************************************************************/
+BVIEW_STATUS bst_trigger_timer_delete (int unit)
+{
+  BVIEW_BST_DATA_t *bst_data_ptr;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  bst_data_ptr = BST_UNIT_DATA_PTR_GET (unit);
+
+  if (NULL == bst_data_ptr)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+    /* take lock */
+    BST_RWLOCK_WR_LOCK (unit);
+  if (true == bst_data_ptr->bst_trigger_timer.in_use)
+  {
+    rv = system_timer_delete (bst_data_ptr->bst_trigger_timer.bstTimer);
+    if (BVIEW_STATUS_SUCCESS == rv)
+    {
+      bst_data_ptr->bst_trigger_timer.in_use = false;
+        LOG_POST (BVIEW_LOG_INFO,
+              "bst application: successfully deleted trigger timer for unit %d , timer id %d.\r\n", unit, bst_data_ptr->bst_trigger_timer.bstTimer);
+    }
+    else
+    {
+      /* timer node add has failed. log the same */
+      LOG_POST (BVIEW_LOG_ERROR, 
+           "Failed to delete trigger timer for unit %d, err %d \r\n", unit, rv);
+    }
+  }
+    /* release lock */
+    BST_RWLOCK_UNLOCK (unit);
+  
+  return rv;
+}
+
+
diff --git a/src/infrastructure/logging/Makefile b/src/infrastructure/logging/Makefile
new file mode 100755
index 0000000..3c9732e
--- /dev/null
+++ b/src/infrastructure/logging/Makefile
@@ -0,0 +1,35 @@
+MODULE := log
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+CFLAGS += -Wall -g -I../../public
+
+export OUT_LOG=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_LOG=$(MODULE).a
+
+OBJECTS_LOG := $(patsubst %.c,%.o,$(wildcard *.c))
+
+$(OUT_LOG)/%.o : %.c
+	@mkdir -p $(OUT_LOG) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_LOG)/$(LIBS_LOG): $(patsubst %,$(OUT_LOG)/%,$(subst :, ,$(OBJECTS_LOG))) 
+	@cd $(OUT_LOG) && $(AR) rvs $(MODULE).a $(OBJECTS_LOG)  
+
+#default target
+$(MODULE) all: $(OUT_LOG)/$(LIBS_LOG) 
+	$(NOOP)
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_LOG)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_LOG=$(OUT_LOG)"
+	@echo "LIBS_LOG=$(LIBS_LOG)"
diff --git a/src/infrastructure/logging/openapp_log.c b/src/infrastructure/logging/openapp_log.c
new file mode 100755
index 0000000..2f234fe
--- /dev/null
+++ b/src/infrastructure/logging/openapp_log.c
@@ -0,0 +1,383 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <string.h>
+#include <pthread.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "openapps_log_api.h"
+
+static pthread_mutex_t logMutex;
+static void  map_bview_to_syslog_severity(BVIEW_SEVERITY severity,
+                                           int * syslog_severity);
+BVIEW_STATUS check_file_availability(char * filename);
+BVIEW_STATUS filebased_logging_init(void);
+void log_to_file(char *buf);
+
+static char logFile[MAX_STRING_LENGTH] = "/tmp/agent_log_latest";
+static char logBkpFile[MAX_STRING_LENGTH] = "/tmp/agent_log_latest.bkp";
+
+#define FILE_OPEN do { \
+    fp = fopen(logFile, "a");\
+    if (fp == NULL) { \
+        printf("Log : Unable to open file for logging [%d:%s] \n", \
+                    errno, strerror(errno)); \
+        pthread_mutex_unlock(&logMutex); \
+        return; \
+    } \
+} while(0)
+
+/*********************************************************************
+* @brief        Initialize logging module.
+*               This function uses "openlog()" in-order
+*               to open a connection to system logger
+*               Logs are stored in a file incase syslog 
+*               is not available 
+*
+*
+* @param[in]    NA
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+void logging_init()
+{
+  /*Filebased logging is used when syslog is not available*/
+  if ((check_file_availability(RSYSLOG_CFG_FILENAME) == BVIEW_STATUS_FAILURE) &&
+      (check_file_availability(SYSLOG_CFG_FILENAME) == BVIEW_STATUS_FAILURE))
+  {
+    if (filebased_logging_init() != BVIEW_STATUS_SUCCESS)
+    {
+      printf("Error! Filebased Logging not initialized\n");
+    }
+  }
+  else
+  {
+  /*"openapps" is prepended to every logged message*/
+  /*SYSLOG is configured to log generic user-level messages
+    and includes PID in every message*/
+    openlog("openapps", LOG_PID, LOG_USER);
+  }
+}
+
+/*********************************************************************
+* @brief        Deinitialize logging module
+*
+*
+* @param[in]    NA
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+void logging_deinit()
+{
+  if ((check_file_availability(RSYSLOG_CFG_FILENAME) == BVIEW_STATUS_FAILURE) &&
+     (check_file_availability(SYSLOG_CFG_FILENAME) == BVIEW_STATUS_FAILURE))
+  {
+    pthread_mutex_destroy(&logMutex);
+  }
+  else
+  {
+    closelog();
+  }
+}
+
+
+/*********************************************************************
+* @brief  Initializes file based logging
+*
+*
+* @param[in]    NA
+*
+* @retval BVIEW_STATUS_SUCCESS  when logging is initialized successfully
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+BVIEW_STATUS filebased_logging_init(void)
+{
+    FILE *fp;
+    struct stat st = {0};
+
+    if (stat(LOG_PATH,&st) == -1)
+    {
+      if (mkdir(LOG_PATH,0777) != -1)
+      {
+        strcpy(logFile,LOG_FILE);
+        strcpy(logBkpFile,BACKUP_LOG_FILE);
+      }
+      else
+      {
+        printf("Log files will be stored in /tmp \n");
+      }
+    }
+    else
+    {
+      if (S_ISDIR(st.st_mode))
+      {
+        strcpy(logFile,LOG_FILE);
+        strcpy(logBkpFile,BACKUP_LOG_FILE);
+      }
+      else
+      {
+        printf("Log files will be stored in /tmp \n");
+      }
+    } 
+
+    /* initialize the mutex*/
+    if(pthread_mutex_init(&logMutex, NULL) != 0)
+    {
+      printf("Logging Mutex Error \n");
+      return BVIEW_STATUS_FAILURE;
+    }
+    /* truncate the logging file if already available */
+    fp = fopen(logFile, "w");
+    if (fp != NULL)
+    {
+        fclose(fp);
+    }
+    else
+    {
+      printf("Log : Unable to open file for logging [%d:%s] \n", 
+                  errno, strerror(errno)); 
+      return BVIEW_STATUS_FAILURE;
+    }
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Check if file exists
+ *
+ * @param[in] filename Name of the file/directory 
+ *
+ * @retval    0  when logging is initialized successfully
+ *
+ * @note
+ *
+ * @end
+ *********************************************************************/
+
+BVIEW_STATUS check_file_availability(char * filename)
+{
+  int filedesc;
+  if (NULL == filename)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  filedesc = open (filename, O_RDONLY, 0);
+  if (filedesc == -1)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  close(filedesc);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
+
+/*********************************************************************
+* @brief         This function is used to map BVIEW_SEVERITY
+*                to standard SYSLOG severity
+*
+*
+* @param[in]     severity BVIEW severity set by a component
+* @param[out]    SYSLOG severity corrosponding to the BVIEW
+*                severity
+*
+* @retval       BVIEW_STATUS
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+static void map_bview_to_syslog_severity(BVIEW_SEVERITY severity,
+                                                   int * syslog_severity)
+{
+  switch(severity)
+  {
+    case BVIEW_LOG_EMERGENCY:
+      *syslog_severity = LOG_EMERG;
+      break;
+    case BVIEW_LOG_ALERT:
+      *syslog_severity = LOG_ALERT;
+      break;
+    case BVIEW_LOG_CRITICAL:
+      *syslog_severity = LOG_CRIT;
+      break;
+    case BVIEW_LOG_ERROR:
+      *syslog_severity = LOG_ERR;
+      break;
+    case BVIEW_LOG_WARNING:
+      *syslog_severity = LOG_WARNING;
+      break;
+    case BVIEW_LOG_NOTICE:
+      *syslog_severity = LOG_NOTICE;
+      break;
+    case BVIEW_LOG_INFO:
+      *syslog_severity = LOG_INFO;
+      break;
+    case BVIEW_LOG_DEBUG:
+      *syslog_severity = LOG_DEBUG;
+      break;
+    default:
+      *syslog_severity = LOG_EMERG;
+      break;
+  }
+}
+
+
+/*********************************************************************
+* @brief        Function used to post log to a file
+*
+*
+* @param[in]    Text which needs to be printed in log file 
+*
+* @retval       NA
+*
+* @note         Logs are stored at a location based on their severity 
+*               and the location specified in rsyslog.conf
+*
+* @end
+*********************************************************************/
+
+void log_to_file(char *buf)
+{
+  FILE *fp = NULL;
+  int length = 0,status = 0;
+  char timeString[MAX_STRING_LENGTH] = { 0 };
+  time_t logtime;
+  struct stat fileStat;
+  struct tm *timeinfo;
+  
+  if (buf == NULL)
+  {
+    printf("Log: NULL Pointer, Cannot log to file\n");
+    return;
+  }
+  
+  time(&logtime);
+  timeinfo = localtime(&logtime);
+  strftime(timeString, MAX_STRING_LENGTH, TIME_FORMAT, timeinfo);
+  
+  pthread_mutex_lock(&logMutex);
+  FILE_OPEN;
+  length = (strlen(buf) + strlen(timeString));
+  if (stat(logFile,&fileStat) < 0)
+  {
+    printf("Log : Unable to read file stats [%d:%s] \n",
+                errno, strerror(errno));
+    pthread_mutex_unlock(&logMutex);
+    fclose(fp);
+    return;
+  }
+  if ((fileStat.st_size + length) > MAX_FILE_SIZE)
+  {
+    if (check_file_availability(logBkpFile) == BVIEW_STATUS_FAILURE)
+    {
+      fclose(fp);
+      status = rename(logFile,logBkpFile);
+      if (status == -1)
+      {
+        printf("Error Unable to rename file [%d:%s] \n",
+                  errno, strerror(errno));
+      }
+    }
+    else
+    {
+      status = remove(logBkpFile);
+      if (status == -1)
+      {
+        printf("Error Unable to remove file [%d:%s] \n",
+                  errno, strerror(errno));
+      }
+      fclose(fp);
+      status = rename(logFile,logBkpFile);
+      if (status == -1)
+      {
+        printf("Error Unable to rename file [%d:%s] \n",
+                  errno, strerror(errno));
+      }
+    }
+    FILE_OPEN;
+  }
+  fprintf(fp,"%s %s\n",timeString,buf);  
+  fclose(fp);
+  pthread_mutex_unlock(&logMutex);
+}
+
+
+/*********************************************************************
+* @brief        Function used to post log
+*
+*
+* @param[in]    severity of the log (SYSLOG severity) 
+* @param[in]    format string with arguments to be stored in log
+*
+* @retval       NA
+*
+* @note         Logs are stored at a location based on their severity 
+*               and the location specified in rsyslog.conf
+*
+* @end
+*********************************************************************/
+
+void log_post(BVIEW_SEVERITY severity, char * format, ...)
+{
+  char buf[MAX_STRING_LENGTH];
+  int syslog_severity,rc=0;
+
+  map_bview_to_syslog_severity(severity, &syslog_severity); 
+  if ((check_file_availability(RSYSLOG_CFG_FILENAME) == BVIEW_STATUS_FAILURE) &&
+     (check_file_availability(SYSLOG_CFG_FILENAME) == BVIEW_STATUS_FAILURE))
+  {
+    va_list ap;
+    va_start(ap, format);
+    rc = vsnprintf(buf, sizeof(buf), format, ap);
+    va_end(ap);
+    if (rc < 0)
+    {
+      printf("Log : Unable to copy data to buffer  \n");
+      return;
+    }
+    log_to_file(buf);
+  }
+  else
+  {
+    va_list ap;
+    va_start(ap, format);
+    vsyslog(syslog_severity, format,ap);
+    va_end(ap);
+  }
+}
diff --git a/src/infrastructure/module_mgr/Makefile b/src/infrastructure/module_mgr/Makefile
new file mode 100755
index 0000000..241ac26
--- /dev/null
+++ b/src/infrastructure/module_mgr/Makefile
@@ -0,0 +1,34 @@
+MODULE := modulemgr
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+CFLAGS += -Wall -g -I../../public -I../../../vendor/cjson
+export OUT_MODULEMGR=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_MODULEMGR=$(MODULE).a
+
+OBJECTS_MODULEMGR := $(patsubst %.c,%.o,$(wildcard *.c))
+
+$(OUT_MODULEMGR)/%.o : %.c
+	@mkdir -p $(OUT_MODULEMGR) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_MODULEMGR)/$(LIBS_MODULEMGR): $(patsubst %,$(OUT_MODULEMGR)/%,$(subst :, ,$(OBJECTS_MODULEMGR))) 
+	@cd $(OUT_MODULEMGR) && $(AR) rvs $(MODULE).a $(OBJECTS_MODULEMGR)  
+
+#default target
+$(MODULE) all: $(OUT_MODULEMGR)/$(LIBS_MODULEMGR) 
+	$(NOOP)
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_MODULEMGR)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_MODULEMGR=$(OUT_MODULEMGR)"
+	@echo "LIBS_MODULEMGR=$(LIBS_MODULEMGR)"
diff --git a/src/infrastructure/module_mgr/modulemgr.c b/src/infrastructure/module_mgr/modulemgr.c
new file mode 100755
index 0000000..c935c67
--- /dev/null
+++ b/src/infrastructure/module_mgr/modulemgr.c
@@ -0,0 +1,364 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <pthread.h>
+#include <string.h>
+#include "modulemgr.h"
+#include "broadview.h"
+#include "json.h"
+#include "cJSON.h"
+#include "openapps_log_api.h"
+
+
+/* Module info structure - this contains modules information
+ * that are registered with module manager                  */
+typedef struct _module_info_ {
+    bool                     isInUse;
+    BVIEW_MODULE_FETAURE_INFO_t  moduleData;
+} BVIEW_MODULE_INFO_t;
+
+/* Module managers local data used to keep different modules information */
+BVIEW_MODULE_INFO_t   moduleData[BVIEW_MAX_MODULES]; 
+/* Read-Write lock for protection */
+pthread_rwlock_t            moduleMgrRWLock; 
+/* Module managers debug flag */
+int moduleMgrDebugFlag = 1;
+
+/* Macro used for printing the log messages*/
+#define MODULE_MANAGER_DEBUG_PRINT(severity,format, args...)         \
+                              if (moduleMgrDebugFlag)                \
+                              {                                      \
+                                  log_post(severity,format, ##args); \
+                              } 
+
+
+/* Macro to acquire read lock */
+#define MODULE_MANAGER_RWLOCK_RD_LOCK(lock)                          \
+           if (pthread_rwlock_rdlock(&lock) != 0)                    \
+           {                                                         \
+               MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,           \
+			   "(%s:%d) Failed to take Module manager"               \
+               "read write lock for read\n", __FILE__, __LINE__);    \
+               return BVIEW_STATUS_FAILURE;                          \
+           } 
+
+
+/* Macro to acquire write lock */
+#define MODULE_MANAGER_RWLOCK_WR_LOCK(lock)                          \
+           if (pthread_rwlock_wrlock(&lock) != 0)                    \
+           {                                                         \
+               MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,           \
+			   "(%s:%d) Failed to take Module manager"               \
+               "read write lock for write\n", __FILE__, __LINE__);   \
+               return BVIEW_STATUS_FAILURE;                          \
+           } 
+
+/* Macro to release RW lock */
+#define MODULE_MANAGER_RWLOCK_UNLOCK(lock)                           \
+           if (pthread_rwlock_unlock(&lock) != 0)                    \
+           {                                                         \
+               MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,           \
+			   "(%s:%d) Failed to release Module manager"            \
+               "read write lock          \n", __FILE__, __LINE__);   \
+               return BVIEW_STATUS_FAILURE;                          \
+           } 
+
+
+/*********************************************************************
+* @brief       Set debug flag for Module Manager 
+*
+* @param[in]  val      Debug flag   
+*
+* @retval   none
+*
+*
+* @note    none
+*
+*********************************************************************/
+void module_mgr_debug_set(int val)
+{
+    moduleMgrDebugFlag = val;  
+}
+
+/*********************************************************************
+* @brief       Get api string from Json buffer 
+*
+* @param[in]  jsonBuffer       Json Buffer  
+* @param[out]  apiString       api String
+*
+* @retval   BVIEW_STATUS_FAILURE     Not able to get api string from 
+*                                    Json buffer 
+* @retval   BVIEW_STATUS_SUCCESS     When api string is successfully 
+*                                    decoded from Json buffer  
+*
+* @retval   BVIEW_STATUS_INVALID_JSON    JSON is malformatted, or doesn't
+*                                         have necessary data.
+* @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+*
+*
+* @note    none
+*
+*********************************************************************/
+static BVIEW_STATUS json_buf_to_api_string_get(char *jsonBuffer, char *apiString)
+{
+    cJSON *json_method;
+    cJSON *root;
+    BVIEW_STATUS status = BVIEW_STATUS_SUCCESS;
+   
+    /* Validating 'jsonBuffer' */ 
+    JSON_VALIDATE_POINTER(jsonBuffer,"jsonBuffer",BVIEW_STATUS_INVALID_PARAMETER);
+
+    /* Parse JSON to a C-JSON root */ 
+    root = cJSON_Parse(jsonBuffer);
+    JSON_VALIDATE_JSON_POINTER(root,"root",BVIEW_STATUS_INVALID_JSON);
+
+    /* Parsing and Validating 'method' from JSON buffer */
+    json_method = cJSON_GetObjectItem(root,"method");
+    JSON_VALIDATE_JSON_POINTER(json_method,"method",BVIEW_STATUS_INVALID_JSON);
+    JSON_VALIDATE_JSON_AS_STRING(json_method,"method",BVIEW_STATUS_INVALID_JSON);
+
+    /* Copy the string, with a limit on max characters */
+    strncpy (&apiString[0], json_method->valuestring, JSON_MAX_NODE_LENGTH-1);
+    return status;
+}
+/*********************************************************************
+* @brief       Initialize module manager data with default values
+*
+* @retval   BVIEW_STATUS_FAILURE   if failed to initialize data
+* @retval   BVIEW_STATUS_SUCCESS   Module manager is successfully initialized
+*
+*
+* @note    none
+*
+*********************************************************************/
+BVIEW_STATUS modulemgr_init()
+{
+    BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+    /* Set local data to 0x00 */
+    memset(moduleData, 0x00, sizeof(moduleData));
+    /* Initialize Read Write lock with default attributes */ 
+    if (pthread_rwlock_init(&moduleMgrRWLock, NULL) != 0)
+    {
+          MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,
+                          "(%s:%d) Failed to create Module manager read write"
+                          "lock with deafault attributes\n", 
+                                                           __FILE__, __LINE__);
+          rv = BVIEW_STATUS_FAILURE;
+    }
+    return rv;
+}
+
+/*********************************************************************
+* @brief       Register a feature with Module manager, all the modules
+*              such as BSt and packet trace need to register api handlers
+*              with module manager. 
+*
+* @param[in]  featureInfo        Feature information
+*
+* @retval   BVIEW_STATUS_FAILURE     If failed to acquire lock
+*
+* @retval   BVIEW_STATUS_TABLE_FULL  BVIEW_MAX_MODULES number of modules 
+*                                    already registered   
+*
+* @retval   BVIEW_STATUS_DUPLICATE   If a module is already registered 
+*                                    with same feature ID
+*
+* @retval   BVIEW_STATUS_SUCCESS     Upon registering successfully with 
+*                                    Module Manager
+*
+*
+* @note    none
+*
+*********************************************************************/
+BVIEW_STATUS modulemgr_register(BVIEW_MODULE_FETAURE_INFO_t * featureInfoPtr)
+{
+    int   moduleIndex = 0;
+	int   freeEntryIndex = 0;
+    bool  freeEntryFound = false;
+    bool  entryAlreadyPresent = false;
+    BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+    BVIEW_MODULE_FETAURE_INFO_t featureInfo = *featureInfoPtr;
+
+    /* Acquire write lock */
+    MODULE_MANAGER_RWLOCK_WR_LOCK(moduleMgrRWLock);
+
+    /* Loop through module list to find out the free/entry to be replaced. */ 
+    /* This will loop till moduleIndex = BVIEW_MAX_MODULES   or            */
+    /*  a module entry with the same feature is already  present.          */
+    for (moduleIndex = 0; moduleIndex < BVIEW_MAX_MODULES; moduleIndex++)
+    {
+       /* Check for free entry, if it is not yet found */ 
+       if ((moduleData[moduleIndex].isInUse == false) && 
+		                          (freeEntryFound == false))
+       {
+           freeEntryFound = true;
+           freeEntryIndex = moduleIndex;
+       } /* Check whether a module is already registered with this feature ID*/ 
+       else if (moduleData[moduleIndex].moduleData.featureId 
+                                                 == featureInfo.featureId)
+       {
+          MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,
+                             "(%s:%d) Module manager has already a module",
+                             "registered with feature ID = %d\n", __FILE__, 
+                                             __LINE__, featureInfo.featureId);
+          entryAlreadyPresent = true;
+          break;
+       }
+    }
+
+    /* First check for duplicate entry */
+    if (entryAlreadyPresent == true)
+    {
+        rv = BVIEW_STATUS_DUPLICATE;
+    }
+    else if ((moduleIndex == BVIEW_MAX_MODULES) && (freeEntryFound == false))
+    {
+     /* To know whether a table is full or not, need to check freeEntryFound flag 
+        also as the "above for loop" goes through all entries in search of 
+        a duplicate entry. so moduleIndex does not alone provide table full/not */
+        MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,
+                                  "(%s:%d) Module manager has already a module",
+                                  "registered with feature ID = %d\n", 
+                                     __FILE__, __LINE__, featureInfo.featureId);
+        rv = BVIEW_STATUS_TABLE_FULL;
+    }
+    else
+    {
+        MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_INFO,
+                 "(%s:%d) Found free entry at index %d, placing modules info\n", 
+                                            __FILE__, __LINE__, freeEntryIndex);
+        moduleData[freeEntryIndex].isInUse = true;
+        moduleData[freeEntryIndex].moduleData = featureInfo;
+        rv = BVIEW_STATUS_SUCCESS;
+    
+	}
+    /* Release RW lock */
+    MODULE_MANAGER_RWLOCK_UNLOCK(moduleMgrRWLock);
+    return rv;
+}
+
+
+/*********************************************************************
+* @brief     When a REST API is received, the web server thread obtains 
+*            the associated handler using this API 
+*
+* @param[in]  jsonBuffer       Json Buffer  
+* @param[in]  bufLength        Length of the Buffer
+* @param[out]  handler          Function handler     
+*
+* @retval   BVIEW_STATUS_FAILURE     Unable to find function handler
+*                                     for the api string in Json buffer
+* @retval   BVIEW_STATUS_SUCCESS     Function handler is found
+*                                     for the api string in Json buffer
+*
+*
+* @retval   BVIEW_STATUS_INVALID_JSON    JSON is malformatted, or doesn't
+*                                         have necessary data.
+* @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+*
+*
+*
+* @note    none
+*
+*********************************************************************/
+BVIEW_STATUS modulemgr_rest_api_handler_get(char * jsonBuffer, 
+                                            int bufLength, 
+                                            BVIEW_REST_API_HANDLER_t *handler)
+{
+    BVIEW_STATUS rv;
+    int   moduleIndex = 0;
+    int   apiMapIndex = 0;
+    bool  entryFound = false;
+    BVIEW_REST_API_t  *moduleApiListPtr;
+    char  apiString[JSON_MAX_NODE_LENGTH] = {0};
+
+    /* Get api string from json buffer */
+    if ((rv = json_buf_to_api_string_get(jsonBuffer, apiString)) 
+                                                 != BVIEW_STATUS_SUCCESS)
+    {
+        MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,
+                      "(%s:%d) Failed to get api string from json buffer, rv = %d\n",
+                                                       __FILE__, __LINE__, rv);
+        return rv;
+    }
+
+    MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_INFO,
+                   "(%s:%d) Api string in json buffer is %s\n",
+                                            __FILE__, __LINE__, apiString);
+    
+    /* Acquire read lock */   
+    MODULE_MANAGER_RWLOCK_RD_LOCK(moduleMgrRWLock);
+
+    /* Loop through the module list to find out correct module */ 
+    for (moduleIndex = 0; (moduleIndex < BVIEW_MAX_MODULES); moduleIndex++)
+    {
+        moduleApiListPtr = moduleData[moduleIndex].moduleData.restApiList;
+
+        /* Loop through the API list to find out the correct handler */  
+        for (apiMapIndex = 0; apiMapIndex < BVIEW_MAX_API_CMDS_PER_FEATURE; 
+                                                                 apiMapIndex++)
+        {
+            /* Validate apiString in module api list */
+            if (moduleApiListPtr[apiMapIndex].apiString == NULL)
+            {
+                continue;
+            }
+
+            /* Check with the API string */
+            if (strcmp(moduleApiListPtr[apiMapIndex].apiString, apiString) == 0) 
+            { /* api string is matched */
+                if (moduleApiListPtr[apiMapIndex].handler != NULL)
+                {
+                    entryFound = true;
+                    *handler = moduleApiListPtr[apiMapIndex].handler;
+                }
+                else
+                {
+                    MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,
+                      "(%s:%d) Handler for api string %s is not present/NULL\n",
+                                                 __FILE__, __LINE__, apiString);
+                    rv = BVIEW_STATUS_FAILURE;
+                }
+                break;
+            }
+        }
+        /* If entry found then break out of main for loop */
+        if (entryFound == true)
+        {
+            MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_INFO, 
+                                "(%s:%d) Handler for api string %s is found\n",
+                                __FILE__, __LINE__, apiString);
+            break;
+        }
+    }
+
+    
+    if (entryFound == false)
+    {
+        MODULE_MANAGER_DEBUG_PRINT(BVIEW_LOG_ERROR,
+                          "(%s:%d) Failed to find handler for api string %s\n",
+                                                __FILE__, __LINE__, apiString);
+        rv = BVIEW_STATUS_FAILURE;
+    }
+
+    /* Release read lock */
+    MODULE_MANAGER_RWLOCK_UNLOCK(moduleMgrRWLock);
+    return rv;
+}
+
diff --git a/src/infrastructure/system/Makefile b/src/infrastructure/system/Makefile
new file mode 100755
index 0000000..9858637
--- /dev/null
+++ b/src/infrastructure/system/Makefile
@@ -0,0 +1,35 @@
+MODULE := system
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+export OUT_SYSTEM=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_SYSTEM=$(MODULE).a
+
+CFLAGS += -Wall -g -I../../public -I ../../nb_plugin/rest/ -I../../sb_plugin/include -I $(OPENAPPS_OUTPATH)
+
+OBJECTS_SYSTEM := $(patsubst %.c,%.o,$(wildcard *.c))
+
+$(OUT_SYSTEM)/%.o : %.c
+	@mkdir -p $(OUT_SYSTEM) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_SYSTEM)/$(LIBS_SYSTEM): $(patsubst %,$(OUT_SYSTEM)/%,$(subst :, ,$(OBJECTS_SYSTEM))) 
+	@cd $(OUT_SYSTEM) && $(AR) rvs $(MODULE).a $(OBJECTS_SYSTEM)  
+
+#default target
+$(MODULE) all: $(OUT_SYSTEM)/$(LIBS_SYSTEM) 
+	$(NOOP)
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_SYSTEM)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_SYSTEM=$(OUT_SYSTEM)"
+	@echo "LIBS_SYSTEM=$(LIBS_SYSTEM)"
diff --git a/src/infrastructure/system/system.c b/src/infrastructure/system/system.c
new file mode 100755
index 0000000..20595ff
--- /dev/null
+++ b/src/infrastructure/system/system.c
@@ -0,0 +1,146 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include "rest_api.h"
+#include "system.h"
+#include "openapps_log_api.h"
+#include "modulemgr.h"
+#include "sb_redirector_api.h"
+
+#include "broadview.h"
+#include "feature.h"
+#include "bst.h"
+#include "sbplugin_api.h"
+
+#ifdef FEAT_VENDOR_INIT
+extern int openapps_driver_init(bool debug, bool menu);
+#define VENDOR_PLATFORM_INIT(debug, menu) openapps_driver_init(debug, menu);
+#else
+#define VENDOR_PLATFORM_INIT(debug,menu);
+#endif
+
+#ifdef FEAT_PT
+extern BVIEW_STATUS pt_main ();
+extern void pt_app_uninit();
+#endif
+
+extern  void driv_app_get_user_input();
+
+/*********************************************************************
+* @brief        Function used to initialize various system components
+*               such as module manager, redirector, agent and sbplugins
+*
+* @param[in]    param 
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+void bview_system_init_ph2(void *param)
+{
+ 
+
+  /*Initialize logging, Not handling error as openlog() does not return anything*/ 
+  logging_init();
+
+  /*Initialize Module manager*/ 
+  if (modulemgr_init() != BVIEW_STATUS_SUCCESS)
+  {
+    LOG_POST (BVIEW_LOG_CRITICAL, "Failed to initialize Module Manager\r\n");
+  }  
+  /*Initialize south-bound plugin*/ 
+  if (sb_redirector_init() != BVIEW_STATUS_SUCCESS)
+  {
+    LOG_POST (BVIEW_LOG_CRITICAL, "Failed to initialize south-bound plugin\r\n");
+  }  
+  /*Initialize south-bound BST plugin*/ 
+  if (sbplugin_common_init() != BVIEW_STATUS_SUCCESS)
+  {
+    LOG_POST (BVIEW_LOG_CRITICAL, "Failed to initialize south-bound BST plugin r\n");
+  }  
+  /*Initialize BST application*/ 
+  if (bst_main() != BVIEW_STATUS_SUCCESS)
+  {
+    LOG_POST (BVIEW_LOG_CRITICAL, "Failed to initialize BST application\r\n");
+  }  
+
+#ifdef FEAT_PT
+  /*Initialize PT application*/ 
+  if (pt_main() != BVIEW_STATUS_SUCCESS)
+  {
+    LOG_POST (BVIEW_LOG_CRITICAL, "Failed to initialize PT application\r\n");
+  } 
+#endif
+  /*Initialize REST*/ 
+  if (rest_init() != BVIEW_STATUS_SUCCESS)
+  {
+    LOG_POST (BVIEW_LOG_CRITICAL, "Failed to initialize REST \n All components must be De-initialized\r\n");
+    bview_system_deinit();
+  }  
+} 
+
+/*********************************************************************
+* @brief        Function used to initialize various system components
+*               such as openapps driver and calls phase-2 init
+*
+* @param[in]    debug     debug mode of openapps driver
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+void bview_system_init_ph1(bool vendor_debug , bool menu)
+{
+  /* Initialize platform */
+  VENDOR_PLATFORM_INIT(vendor_debug, menu);
+  if (false == vendor_debug)
+  {
+  bview_system_init_ph2(NULL); 
+  }
+}
+/*********************************************************************
+* @brief     Function used to deinitialize various system components
+*            Individual components are deinitialized using proper
+*            function calls  
+*
+*
+* @param[in] NA
+*
+* @retval    NA
+*
+* @note      NA
+*
+* @end
+*********************************************************************/
+
+void bview_system_deinit()
+{
+  /*Deinitialize logging, Not handling error as closelog() does not return anything*/ 
+
+  /*Functions used to deinitialize other modules needs to be called from here*/
+  /*TBD respective component owners to include appropriate function call*/ 
+  logging_deinit();
+  bst_app_uninit();
+#ifdef FEAT_PT
+  pt_app_uninit();
+#endif
+}  
diff --git a/src/infrastructure/system/system_time.c b/src/infrastructure/system/system_time.c
new file mode 100755
index 0000000..235e321
--- /dev/null
+++ b/src/infrastructure/system/system_time.c
@@ -0,0 +1,169 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <time.h>
+#include <signal.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include "system.h"
+#include "openapps_log_api.h"
+
+#define CONVERSION_FACTOR 1000000L
+
+/*********************************************************************
+* @brief         Function used to create and arm a timer
+*
+*
+* @param[in]     handler        function pointer to handle the callback
+*                               The callback function address is passed
+*                               using a void * because the function declared
+*                               in linux "sigev_notify_function" has a 
+*                               return type "void"  
+* @param[in,out] timerId        timerId of the timer which is created
+* @param[in]     timeInMilliSec Time after which callback is required
+* @param[in]     mode           mode specifing if the timer must be
+*                               periodic or oneshot
+* @param[in]     param          Arguments passed from the calling function
+*
+* @retval        BVIEW_STATUS_SUCCESS
+* @retval        BVIEW_STATUS_FAILURE
+*
+* @note          NA
+*
+* @end
+*********************************************************************/
+
+
+BVIEW_STATUS system_timer_add(void * handler,timer_t * timerId, int timeInMilliSec, TIMER_MODE mode, void * param)
+{
+  struct sigevent sigTime;
+  struct timespec monotonic_time;
+  clockid_t clock;
+  int ret = BVIEW_STATUS_SUCCESS;
+  /*Validate callback function pointers*/
+  if (handler == NULL)
+  {
+    LOG_POST (BVIEW_LOG_ERROR, "Invalid handler during timer registration \r\n");
+    return BVIEW_STATUS_FAILURE;
+  }
+  
+  /*Validate pointer which stores timer id*/
+  if (timerId == NULL)
+  {
+    LOG_POST (BVIEW_LOG_ERROR, "Invalid timer id during timer registration\r\n");
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /*Populate the structures in-order to create the timer*/
+  memset(&sigTime, 0,sizeof(struct sigevent)); 
+  sigTime.sigev_notify = SIGEV_THREAD;
+  sigTime.sigev_notify_attributes = NULL;
+  sigTime.sigev_notify_function = handler;
+  sigTime.sigev_value.sival_ptr = param;
+  /*Monotonic clock is used if available else realtime clock is used*/ 
+  if (!clock_gettime(CLOCK_MONOTONIC, &monotonic_time)) 
+   {
+     clock = CLOCK_MONOTONIC;
+   } 
+   else 
+   {
+     clock = CLOCK_REALTIME;
+   }
+
+  /*Timer is created*/
+  if (timer_create(clock, &sigTime, timerId) == 0)
+   {
+     ret = system_timer_set(*timerId,timeInMilliSec,mode); 
+   }
+   else 
+   {
+     LOG_POST (BVIEW_LOG_ERROR, "Timer Creation Failed Error no : %d\r\n",errno);
+     ret = BVIEW_STATUS_FAILURE;
+   }
+  return ret;
+}
+
+/*********************************************************************
+* @brief      Function used to destroy a timer
+*
+*
+* @param[in]  timerId Timer id of the timer which needs to be destroyed
+*
+* @retval     BVIEW_STATUS_SUCCESS
+* @retval     BVIEW_STATUS_FAILURE
+*
+* @note          NA
+*
+* @end
+*********************************************************************/
+
+
+BVIEW_STATUS system_timer_delete(timer_t timerId)
+{
+  int ret = BVIEW_STATUS_SUCCESS;
+  if ((timer_delete(timerId)) !=0)
+  {
+    ret = BVIEW_STATUS_FAILURE;
+  }
+  return ret;
+}
+
+/*********************************************************************
+* @brief      Function used to set/reset a timer
+*
+*
+* @param[in]  timerId        Timer id of the timer which needs to be 
+*                            set/reset
+* @param[in]  timeInMilliSec Time after which callback is required
+* @param[in]  mode           mode specifing if the timer must be
+*                            periodic or oneshot
+*
+* @retval     BVIEW_STATUS_SUCCESS
+* @retval     BVIEW_STATUS_FAILURE
+*
+* @note       NA
+*
+* @end
+*********************************************************************/
+
+
+BVIEW_STATUS system_timer_set(timer_t timerId,int timeInMilliSec,TIMER_MODE mode)
+{
+  int ret = BVIEW_STATUS_SUCCESS;
+  struct itimerspec timerVal;
+  timerVal.it_value.tv_sec = timeInMilliSec / 1000;
+  timerVal.it_value.tv_nsec = (long)(timeInMilliSec % 1000) * CONVERSION_FACTOR;
+  if (mode == PERIODIC_MODE)/*Timer is triggered periodically*/
+  {
+    timerVal.it_interval.tv_sec = timerVal.it_value.tv_sec;
+    timerVal.it_interval.tv_nsec = timerVal.it_value.tv_nsec;
+  }
+  else/*Timer is triggered only once, but timer is not destroyed*/
+  {
+    timerVal.it_interval.tv_sec = 0;
+    timerVal.it_interval.tv_nsec = 0;
+  }
+  /*Timer is set*/
+  if (timer_settime(timerId, 0, &timerVal, NULL) != 0)
+  {
+    LOG_POST (BVIEW_LOG_ERROR, "Timer Initialization Failed, Error no : %d\r\n",errno);
+    ret = BVIEW_STATUS_FAILURE;
+  }
+  return ret;
+}
diff --git a/src/nb_plugin/rest/Makefile b/src/nb_plugin/rest/Makefile
new file mode 100755
index 0000000..e3814a0
--- /dev/null
+++ b/src/nb_plugin/rest/Makefile
@@ -0,0 +1,35 @@
+MODULE := rest
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+CFLAGS += -Wall -std=c99 -g -I. -I../../public/ -I../../../vendor/cjson
+export OUT_REST=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_REST=$(MODULE).a
+
+OBJECTS_REST := $(patsubst %.c,%.o,$(wildcard *.c))
+
+$(OUT_REST)/%.o : %.c
+	@mkdir -p $(OUT_REST) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_REST)/$(LIBS_REST): $(patsubst %,$(OUT_REST)/%,$(subst :, ,$(OBJECTS_REST))) 
+	@cd $(OUT_REST) && $(AR) rvs $(MODULE).a $(OBJECTS_REST)  
+#	@cd $(OUT_REST) && $(CC) $(CFLAGS) -o $(MODULE) $(OBJECTS_REST) #This line needs to be removed.
+
+#default target
+$(MODULE) all: $(OUT_REST)/$(LIBS_REST) 
+	$(NOOP)
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_REST)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_REST=$(OUT_REST)"
+	@echo "LIBS_REST=$(LIBS_REST)"
diff --git a/src/nb_plugin/rest/agent_config.cfg b/src/nb_plugin/rest/agent_config.cfg
new file mode 100755
index 0000000..4d3d9e6
--- /dev/null
+++ b/src/nb_plugin/rest/agent_config.cfg
@@ -0,0 +1,4 @@
+bview_client_ip=127.0.0.1
+bview_client_port=9070
+agent_port=8080
+
diff --git a/src/nb_plugin/rest/rest.h b/src/nb_plugin/rest/rest.h
new file mode 100755
index 0000000..6735669
--- /dev/null
+++ b/src/nb_plugin/rest/rest.h
@@ -0,0 +1,238 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_REST_H
+#define	INCLUDE_REST_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <arpa/inet.h>
+#include <pthread.h>
+
+#include "broadview.h"
+#include "rest_debug.h"
+
+#define REST_MAX_STRING_LENGTH      128
+#define REST_MAX_HTTP_BUFFER_LENGTH 2048
+
+#define REST_MAX_SESSIONS    5
+
+#define REST_MAX_IP_ADDR_LENGTH    20
+
+/* file from where the configuration properties are read. */
+#define REST_CONFIG_FILE    "/etc/broadview_config.cfg"
+
+#define REST_CONFIG_PROPERTY_CLIENT_IP   "bview_client_ip"
+#define REST_CONFIG_PROPERTY_CLIENT_IP_DEFAULT   "127.0.0.1"    
+
+#define REST_CONFIG_PROPERTY_CLIENT_PORT   "bview_client_port"
+#define REST_CONFIG_PROPERTY_CLIENT_PORT_DEFAULT   9070
+
+#define REST_CONFIG_PROPERTY_LOCAL_PORT "agent_port"
+#define REST_CONFIG_PROPERTY_LOCAL_PORT_DEFAULT 8080
+
+
+/* Macro to acquire lock */
+#define REST_LOCK_TAKE(_ptr)                                                        \
+        {                                                                           \
+           if (0 != pthread_mutex_lock (&_ptr->config_mutex))                          \
+           {                                                                        \
+              LOG_POST (BVIEW_LOG_ERROR,                                            \
+                  "Failed to take the lock for rest config \r\n");                \
+              return BVIEW_STATUS_FAILURE;                                          \
+           }                                                                        \
+         }
+/*  to release lock*/
+#define REST_LOCK_GIVE(_ptr)                                                        \
+         {                                                                          \
+           if (0 != pthread_mutex_unlock(&_ptr->config_mutex))                         \
+           {                                                                        \
+              LOG_POST (BVIEW_LOG_ERROR,                                            \
+              "Failed to Release the lock for rest config \r\n");                 \
+               return BVIEW_STATUS_FAILURE;                                         \
+            }                                                                       \
+          }
+
+
+typedef struct _rest_config_
+{
+    char clientIp[REST_MAX_IP_ADDR_LENGTH];
+
+    int clientPort;
+
+    int localPort;
+} REST_CONFIG_t;
+
+/* REST session */
+typedef struct _rest_session_
+{
+    /* is this session in use ? */
+    bool inUse;
+
+    /* http method */
+    char httpMethod[REST_MAX_STRING_LENGTH+1];
+
+    /* incoming URL */
+    char url[REST_MAX_STRING_LENGTH+1];
+
+    /* incoming REST method */
+    char restMethod[REST_MAX_STRING_LENGTH];
+
+    /* socket on which the response message, if any, is to be sent */
+    int connectionFd;
+
+    /* buffer to store the HTTP request message */
+    char buffer[REST_MAX_HTTP_BUFFER_LENGTH + 1];
+
+    /* data length */
+    int length;
+
+    /* JSON content start, filled while parsing */
+    char *json;
+
+    /* peer address */
+    struct sockaddr_in peerAddr;
+
+    /* time the session is created */
+    time_t creationTime;
+
+} REST_SESSION_t;
+
+typedef struct _rest_context_
+{
+    REST_CONFIG_t config;
+
+    REST_SESSION_t sessions[REST_MAX_SESSIONS];
+
+    pthread_mutex_t config_mutex;
+
+} REST_CONTEXT_t;
+
+typedef BVIEW_STATUS(*BVIEW_REST_ERROR_HANDLER_t) (int fd,
+                                                 char *jsonBuffer,
+                                                 int bufLength);
+
+
+typedef struct _rest_json_error_map_
+{
+ BVIEW_STATUS return_code;
+ int   json_code;
+ char *errorstr;
+ BVIEW_REST_ERROR_HANDLER_t handler;
+}REST_JSON_ERROR_t;
+
+
+
+/* initialize configurations */
+BVIEW_STATUS rest_config_init(REST_CONTEXT_t *rest);
+
+/* dumps existing sessions */
+void rest_session_dump(REST_SESSION_t *session);
+
+/* allocations an available session (returns the index) */
+BVIEW_STATUS rest_allocate_session(REST_CONTEXT_t *context, int *sessionId);
+
+/* initialize sessions */
+BVIEW_STATUS rest_sessions_init(REST_CONTEXT_t *context);
+
+/* sends a HTTP 200 OK message to the client  */
+BVIEW_STATUS rest_send_200(int fd);
+
+/* sends a HTTP 404 message to the client  */
+BVIEW_STATUS rest_send_404(int fd);
+
+/* sends a HTTP 400 message to the client  */
+BVIEW_STATUS rest_send_400(int fd);
+
+/* sends a HTTP 500 message to the client  */
+BVIEW_STATUS rest_send_500(int fd);
+
+/* sends asynchronous report to client */
+BVIEW_STATUS rest_send_async_report(REST_CONTEXT_t *rest, char *buffer, int length);
+
+BVIEW_STATUS rest_http_server_run(REST_CONTEXT_t *rest);
+BVIEW_STATUS rest_session_validate(REST_CONTEXT_t *context, REST_SESSION_t *session);
+BVIEW_STATUS rest_send_200_with_data(int fd, char *buffer, int length);
+
+/******************************************************************
+ * @brief  sends a HTTP 404 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ * @param[in]   buffer  Buffer containing data to be sent
+ * @param[in]   length  number of bytes to be sent 
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if send is successful
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_404_with_data(int fd, char *buffer, int length);
+
+
+/******************************************************************
+ * @brief  sends a HTTP 400 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ * @param[in]   buffer  Buffer containing data to be sent
+ * @param[in]   length  number of bytes to be sent 
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if send is successful
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_400_with_data(int fd, char *buffer, int length);
+
+/******************************************************************
+ * @brief  sends a HTTP 500 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ * @param[in]   buffer  Buffer containing data to be sent
+ * @param[in]   length  number of bytes to be sent 
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if send is successful
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_500_with_data(int fd, char *buffer, int length);
+ 
+BVIEW_STATUS rest_send_json_error_async(BVIEW_STATUS rv);
+
+BVIEW_STATUS rest_send_json_error(void *cookie,  BVIEW_STATUS rv, int id);
+
+BVIEW_STATUS rest_session_fd_get (void *cookie, int *fd);
+
+BVIEW_STATUS rest_json_error_fn_invoke(int fd, BVIEW_STATUS rv, int id);
+
+BVIEW_STATUS rest_get_json_error_data(BVIEW_STATUS rv, int *json_val, 
+                                      char *ptr, BVIEW_REST_ERROR_HANDLER_t *handler);
+BVIEW_STATUS rest_get_id_from_request(char * jsonBuffer, int bufLength, int *id);
+
+
+int rest_agent_config_params_modify(char *ipaddr, unsigned int clientPort);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_REST_H */
+
diff --git a/src/nb_plugin/rest/rest_api.c b/src/nb_plugin/rest/rest_api.c
new file mode 100755
index 0000000..e17cfde
--- /dev/null
+++ b/src/nb_plugin/rest/rest_api.c
@@ -0,0 +1,387 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "broadview.h"
+#include "rest.h"
+#include "rest_http.h"
+#include "rest_api.h"
+
+#include "openapps_feature.h"
+#include "modulemgr.h"
+
+static REST_CONTEXT_t rest;
+const REST_JSON_ERROR_t rest_json_error_array[] = {
+  {BVIEW_STATUS_FAILURE, -32603, "Internal Error", rest_send_400_with_data},
+  {BVIEW_STATUS_OUTOFMEMORY, -32603, "Internal Error", rest_send_400_with_data},
+  {BVIEW_STATUS_RESOURCE_NOT_AVAILABLE, -32603, "Internal Error", rest_send_400_with_data},
+  {BVIEW_STATUS_INVALID_MEMORY, -32603, "Internal Error", rest_send_400_with_data},
+  {BVIEW_STATUS_INVALID_PARAMETER, -32602, "Invalid Params", rest_send_400_with_data},
+  {BVIEW_STATUS_INVALID_ID, -32602, "Invalid Params", rest_send_400_with_data},
+  {BVIEW_STATUS_UNSUPPORTED, -32601, "Method Not Found", rest_send_404_with_data},
+  {BVIEW_STATUS_INVALID_JSON, -32700, "Parse Error", rest_send_500_with_data}
+};
+  const char json_error[] = "{     \
+                             \"jsonrpc\": \"2.0\", \
+                             \"error\": { \
+                             \"code\": %d, \
+                             \"message\": \"%s\" , \
+                             \"version\": \"%d\" }, \
+                             \"id\":  %d\
+                              }";
+
+const char json_error_async[] = "{     \
+                                \"jsonrpc\": \"2.0\", \
+                                \"error\": { \
+                                \"code\": %d, \
+                                \"message\": \"%s\" , \
+                                \"version\": \"%d\" }, \
+                                }";
+
+#define REST_HTTP_JSON_MAX_ELEMENTS 7
+#define REST_JSON_BUFF_LEN 512
+#define REST_JSON_MSG_LEN 64
+
+/******************************************************************
+ * @brief  Initializes the REST component.  
+ * 
+ * @note     This function setsup the component and starts the webserver.
+ *           It doesn't return.
+ *********************************************************************/
+BVIEW_STATUS rest_init(void)
+{
+    BVIEW_STATUS status;
+
+    _REST_LOG(_REST_DEBUG_TRACE, "REST component initializing ..  \n");
+
+    memset(&rest, 0, sizeof (rest));
+
+    /* Read the configuration and configure the component */
+    status = rest_config_init(&rest);
+    _REST_ASSERT_ERROR( (status == BVIEW_STATUS_SUCCESS), BVIEW_STATUS_FAILURE);
+
+    /* Initialize the session table */
+    status = rest_sessions_init(&rest);
+    _REST_ASSERT_ERROR( (status == BVIEW_STATUS_SUCCESS), BVIEW_STATUS_FAILURE);
+
+    /* Initialize and Start the webserver */
+    status = rest_http_server_run(&rest);
+    _REST_ASSERT_ERROR( (status == BVIEW_STATUS_SUCCESS), BVIEW_STATUS_FAILURE);
+
+    return status;
+}
+
+/******************************************************************
+ * @brief  Sends response to a client 
+ * 
+ * @note   The cookie is the 'session' and identifies the socket 
+ *         on which the data needs to be sent. This function adds 
+ *         HTTP header and sends it to client.
+ *********************************************************************/
+BVIEW_STATUS rest_response_send(void *cookie, char *pBuf, int size)
+{
+    REST_SESSION_t *session = (REST_SESSION_t *) cookie;
+    BVIEW_STATUS status;
+
+    /* if input is not valid, we still need to clean up session, if valid */
+    if ((pBuf == NULL) && (session != NULL))
+    {
+        if (rest_session_validate(&rest, session) == BVIEW_STATUS_SUCCESS)
+        {
+            close(session->connectionFd);
+            session->inUse = false;
+        }
+
+        return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+    else if (NULL == pBuf)
+    {
+      return BVIEW_STATUS_INVALID_PARAMETER;
+    }
+
+    /* session == NULL indicates an asynchronous send. 
+     * It needs to be handled differently. 
+     */
+    if (session != NULL)
+    {
+        status = rest_session_validate(&rest, session);
+        if (status == BVIEW_STATUS_SUCCESS)
+        {
+            status = rest_send_200_with_data(session->connectionFd, pBuf, size);
+        }
+
+        close(session->connectionFd);
+        session->inUse = false;
+        return status;
+    }
+
+    /* asynchronous data sending */
+    status = rest_send_async_report(&rest, pBuf, size);
+    return status;
+}
+
+
+/******************************************************************
+ * @brief  Sends successful response to a client 
+ * 
+ * @note   The cookie is the 'session' and identifies the socket 
+ *         on which the data needs to be sent and invokes the 
+ *         function to send the successful response.
+ *********************************************************************/
+BVIEW_STATUS rest_response_send_ok (void *cookie)
+{
+  BVIEW_STATUS ret;
+  int fd = 0;
+  REST_SESSION_t *session = (REST_SESSION_t *) cookie;
+
+
+  if (NULL == cookie)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+    ret= rest_session_fd_get(cookie, &fd);
+    if (BVIEW_STATUS_SUCCESS != ret)
+      return ret;
+
+    ret = rest_send_200(fd);
+    close(session->connectionFd);
+    session->inUse = false;
+    return ret;
+
+}
+
+/******************************************************************
+ * @brief  Sends error response to a client 
+ * 
+ * @note   The cookie is the 'session' and identifies the socket 
+ *         on which the data needs to be sent. The error value which
+ *         is returned in the value is used when the report is asyncronous
+ *         and the return value and id are used for the syncronous responses.
+ *********************************************************************/
+
+BVIEW_STATUS rest_response_send_error(void *cookie, BVIEW_STATUS rv, int id)
+{
+  BVIEW_STATUS ret;
+
+
+  if (NULL == cookie)
+  {
+    /* Send the error reporting for the asyncronous
+       reports */
+    ret = rest_send_json_error_async(rv);
+  }
+  else
+  {
+    ret = rest_send_json_error(cookie, rv, id);
+  }
+
+  return ret;
+}
+
+/******************************************************************
+ * @brief  Sends error response to a client 
+ * 
+ * @note   The cookie is the 'session' and identifies the socket 
+ *         on which the data needs to be sent.The cookie, returned error code 
+ *         and the id are used for the syncronous error responses.
+ *********************************************************************/
+
+BVIEW_STATUS rest_send_json_error(void *cookie,  BVIEW_STATUS rv, int id)
+{
+  BVIEW_STATUS ret;
+  int fd = 0;
+  REST_SESSION_t *session = (REST_SESSION_t *) cookie;
+
+  /* get the fd */
+
+  if (NULL == cookie)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+    ret= rest_session_fd_get(cookie, &fd);
+    if (BVIEW_STATUS_SUCCESS != ret)
+      return ret;
+
+  /* call the api to prepare the json info and send */
+    ret = rest_json_error_fn_invoke(fd, rv, id);
+    close(session->connectionFd);
+    session->inUse = false;
+    return ret;
+}
+
+
+/******************************************************************
+ * @brief  invokes the json error function for the given error code 
+ * 
+ * @note   The return value is used to retrieved the json error code, 
+ *         json error string and the rest api which is used to send
+ *         the error respnse to the client.
+ *********************************************************************/
+BVIEW_STATUS rest_json_error_fn_invoke(int fd, BVIEW_STATUS rv, int id)
+{
+  BVIEW_STATUS ret_json;
+  char json[REST_JSON_BUFF_LEN];
+  BVIEW_REST_ERROR_HANDLER_t handler;
+  int json_val =0;
+  char str[REST_JSON_MSG_LEN];
+
+  memset (str, 0, REST_JSON_MSG_LEN);
+
+
+
+  ret_json = rest_get_json_error_data(rv, &json_val, str, &handler);
+
+  if (BVIEW_STATUS_SUCCESS != ret_json)
+    return ret_json;
+
+  memset (json, 0, REST_JSON_BUFF_LEN);
+  snprintf(json, REST_JSON_BUFF_LEN, json_error, json_val, str, BVIEW_JSON_VERSION, id);
+
+  /* call the function to send the json error */
+
+  ret_json = handler(fd, json, strlen(json));
+  return ret_json;
+}
+
+
+
+/******************************************************************
+ * @brief  invokes the json error function for the given error code 
+ * 
+ * @note   The return value is used to retrieved the json error code, 
+ *         json error string and the rest api which is used to send
+ *         the error respnse to the client.This api is used for error
+ *         reporting incase of failures in async report genetation.
+ *********************************************************************/
+BVIEW_STATUS rest_send_json_error_async(BVIEW_STATUS rv)
+{
+  BVIEW_STATUS ret_json;
+  char json[REST_JSON_BUFF_LEN];
+  BVIEW_REST_ERROR_HANDLER_t handler;
+  int json_val =0;
+  char str[REST_JSON_MSG_LEN];
+
+  memset (str, 0, REST_JSON_MSG_LEN);
+
+
+
+  ret_json = rest_get_json_error_data(rv, &json_val, str, &handler);
+
+  if (BVIEW_STATUS_SUCCESS != ret_json)
+    return ret_json;
+
+  memset (json, 0, REST_JSON_BUFF_LEN);
+  snprintf(json, REST_JSON_BUFF_LEN, json_error_async, json_val, str, BVIEW_JSON_VERSION);
+
+  /* call the function to send the json error */
+  ret_json = rest_send_async_report(&rest, json, strlen(json));
+  return ret_json;
+}
+
+/******************************************************************
+ * @brief  utility api to get the json error code, rest handler and
+ *         json error string for the failure code.
+ * 
+ * @note   The return value is used to retrieved the json error code, 
+ *         json error string and the rest api.
+ *********************************************************************/
+BVIEW_STATUS rest_get_json_error_data(BVIEW_STATUS rv, int *json_val, 
+                                      char *ptr, BVIEW_REST_ERROR_HANDLER_t *handler)
+{
+  unsigned int i;
+
+  for (i = 0; i < (sizeof(rest_json_error_array)/sizeof(rest_json_error_array[0])); i++)
+  {
+    if (rv == rest_json_error_array[i].return_code)
+    {
+      *json_val = rest_json_error_array[i].json_code;
+      strncpy(ptr, rest_json_error_array[i].errorstr, strlen(rest_json_error_array[i].errorstr));
+      *handler = rest_json_error_array[i].handler;
+      return BVIEW_STATUS_SUCCESS;
+    }
+  }
+
+  return BVIEW_STATUS_INVALID_PARAMETER;
+}
+
+/******************************************************************
+ * @brief  utility api to get the fd for the given session. 
+ * 
+ * @note   The session id is used to retrieve the corresponding
+ *          fd for the given session. 
+ *********************************************************************/
+BVIEW_STATUS rest_session_fd_get (void *cookie, int *fd)
+{
+    REST_SESSION_t *session = (REST_SESSION_t *) cookie;
+    BVIEW_STATUS status = BVIEW_STATUS_INVALID_PARAMETER;
+
+
+    /* session == NULL indicates an asynchronous send. 
+     * It needs to be handled differently. 
+     */
+    if (session != NULL)
+    {
+        status = rest_session_validate(&rest, session);
+        if (status == BVIEW_STATUS_SUCCESS)
+        {
+          *fd = session->connectionFd;
+           return status;
+        }
+    }
+
+    return status;
+
+}
+
+
+/******************************************************************
+ * @brief  Initializes configuration, reads it from file or assumes defaults.
+ *
+ * @param[in]   *ipaddr     pointer to client ip addr string 
+ * @param[in]   clientPort  client port 
+ *                           
+ * @retval   0  when configuration is initialized successfully
+ *
+ * @note     
+ *********************************************************************/
+int rest_agent_config_params_modify(char *ipaddr, unsigned int clientPort)
+{
+  REST_CONTEXT_t *ptr;
+
+  ptr = &rest;
+
+     REST_LOCK_TAKE(ptr);
+
+     /* setup default client IP */
+     strncpy(&ptr->config.clientIp[0], ipaddr, REST_MAX_IP_ADDR_LENGTH);
+
+     /* setup default client port */
+     ptr->config.clientPort = clientPort;
+
+     REST_LOCK_GIVE(ptr);
+
+     return 0;
+}
+
+
diff --git a/src/nb_plugin/rest/rest_config.c b/src/nb_plugin/rest/rest_config.c
new file mode 100755
index 0000000..cdf1b93
--- /dev/null
+++ b/src/nb_plugin/rest/rest_config.c
@@ -0,0 +1,220 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <arpa/inet.h>
+
+#include "broadview.h"
+
+#include "rest.h"
+
+#define _REST_CONFIGFILE_LINE_MAX_LEN   256
+#define _REST_CONFIGFILE_READ_MODE      "r"
+#define _REST_CONFIGFILE_DELIMITER      "="
+
+#define _REST_ASSERT_CONFIG_FILE_ERROR(condition) do { \
+    if (!(condition)) { \
+        _REST_LOG(_REST_DEBUG_ERROR, \
+                    "REST (%s:%d) Unrecognized Config File format, may be corrupted. Errno : %s  \n", \
+                    __func__, __LINE__, strerror(errno)); \
+                        fclose(configFile); \
+        return (BVIEW_STATUS_FAILURE); \
+    } \
+} while(0)
+
+/******************************************************************
+ * @brief  Sets the configuration, to defaults.
+ *
+ * @param[in]   rest      REST context for operation
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  when configuration is initialized successfully
+ *
+ * @note     
+ *********************************************************************/
+
+static BVIEW_STATUS rest_config_set_defaults(REST_CONTEXT_t *rest)
+{
+    _REST_LOG(_REST_DEBUG_INFO, "REST : Setting configuration to defaults \n");
+
+    memset(&rest->config, 0, sizeof (REST_CONFIG_t));
+
+    /* setup default client IP */
+    strncpy(&rest->config.clientIp[0], REST_CONFIG_PROPERTY_CLIENT_IP_DEFAULT, REST_MAX_IP_ADDR_LENGTH);
+
+    /* setup default client port */
+    rest->config.clientPort = REST_CONFIG_PROPERTY_CLIENT_PORT_DEFAULT;
+
+    /* setup default local port */
+    rest->config.localPort = REST_CONFIG_PROPERTY_LOCAL_PORT_DEFAULT;
+
+    _REST_LOG(_REST_DEBUG_INFO, "REST : Using default configuration %s:%d <-->local:%d \n",
+              rest->config.clientIp, rest->config.clientPort, rest->config.localPort);
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Reads configuration from a file.
+ *
+ * @param[in]   rest      REST context for operation
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  when configuration is initialized successfully
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE  if config file is not readable
+ * @retval   BVIEW_STATUS_FAILURE if config file contents are invalid
+ *
+ * @note     
+ *********************************************************************/
+
+static BVIEW_STATUS rest_config_read(REST_CONTEXT_t *rest)
+{
+    FILE *configFile;
+    char line[_REST_CONFIGFILE_LINE_MAX_LEN] = { 0 };
+    int numLinesRead = 0;
+
+    /* dummy structure for validating IP address */
+    struct sockaddr_in clientIpAddr;
+    int temp;
+
+    /* for string manipulation */
+    char *property, *value;
+
+    _REST_LOG(_REST_DEBUG_INFO, "REST : Reading configuration from %s \n", REST_CONFIG_FILE);
+
+    memset(&rest->config, 0, sizeof (REST_CONFIG_t));
+
+    /* open the file. if file not available/readable, return appropriate error */
+    configFile = fopen(REST_CONFIG_FILE, _REST_CONFIGFILE_READ_MODE);
+
+    if (configFile == NULL)
+    {
+        _REST_LOG(_REST_DEBUG_ERROR,
+                  "REST : Configuration file %s not found: \n",
+                  REST_CONFIG_FILE);
+        return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE;
+    }
+
+    /* read the lines one-by-one. if any of the lines is corrupted 
+     * i.e., doesn't contain valid tokens, return error 
+     */
+
+    while (numLinesRead < 3)
+    {
+        memset (&line[0], 0, _REST_CONFIGFILE_LINE_MAX_LEN);
+
+        /* read one line from the file */
+        property = fgets(&line[0], _REST_CONFIGFILE_LINE_MAX_LEN, configFile);
+        _REST_ASSERT_CONFIG_FILE_ERROR(property != NULL);
+
+        numLinesRead++;
+
+        /* split the line into tokens, based on the file format */
+        property = strtok(&line[0], _REST_CONFIGFILE_DELIMITER);
+        _REST_ASSERT_CONFIG_FILE_ERROR(property != NULL);
+        value = property + strlen(property) + 1;
+
+        /* Is this token the client IP address ?*/
+        if (strcmp(property, REST_CONFIG_PROPERTY_CLIENT_IP) == 0)
+        {
+            /* truncate the newline characters */
+            value[strlen(value) - 1] = 0;
+
+            /* is this IP address valid ? */
+            temp = inet_pton(AF_INET, value, &(clientIpAddr.sin_addr));
+            _REST_ASSERT_CONFIG_FILE_ERROR(temp > 0);
+
+            /* copy the client ip address */
+            strncpy(&rest->config.clientIp[0], value, REST_MAX_IP_ADDR_LENGTH - 1);
+            continue;
+        }
+
+        /* Is this token the client port number ?*/
+        if (strcmp(property, REST_CONFIG_PROPERTY_CLIENT_PORT) == 0)
+        {
+            /* is this port number valid ? */
+            temp = strtol(value, NULL, 10);
+            _REST_ASSERT_CONFIG_FILE_ERROR( errno != ERANGE);
+
+            /* copy the client port number */
+            rest->config.clientPort = temp;
+            continue;
+        }
+
+        /* Is this token the local port number ?*/
+        if (strcmp(property, REST_CONFIG_PROPERTY_LOCAL_PORT) == 0)
+        {
+            /* is this port number valid ? */
+            temp = strtol(value, NULL, 10);
+            _REST_ASSERT_CONFIG_FILE_ERROR( errno != ERANGE);
+
+            /* copy the client port number */
+            rest->config.localPort = temp;
+            continue;
+        }
+
+        /* unknown property */
+        _REST_LOG(_REST_DEBUG_ERROR,
+                  "REST : Unknown property in configuration file : %s \n",
+                  property);
+
+        fclose(configFile);
+        return BVIEW_STATUS_FAILURE;
+    }
+
+    _REST_LOG(_REST_DEBUG_INFO, "REST : Using configuration %s:%d <-->local:%d \n",
+              rest->config.clientIp, rest->config.clientPort, rest->config.localPort);
+
+    fclose(configFile);
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  Initializes configuration, reads it from file or assumes defaults.
+ *
+ * @param[in]   rest      REST context for operation
+ *                           
+ * @retval   BVIEW_STATUS_SUCCESS  when configuration is initialized successfully
+ *
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_config_init(REST_CONTEXT_t *rest)
+{
+    BVIEW_STATUS status;
+    pthread_mutex_t *rest_mutex = NULL;
+
+    /* aim to read */
+    _REST_LOG(_REST_DEBUG_TRACE, "REST : Configuring ...");
+ 
+    /* create the mutex for agent_config data */
+    rest_mutex = &rest->config_mutex;
+    pthread_mutex_init (rest_mutex, NULL);
+
+    status = rest_config_read(rest);
+    if (status != BVIEW_STATUS_SUCCESS)
+    {
+        rest_config_set_defaults(rest);
+    }
+
+    _REST_LOG(_REST_DEBUG_TRACE, "REST : Configuration Complete");
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
diff --git a/src/nb_plugin/rest/rest_debug.h b/src/nb_plugin/rest/rest_debug.h
new file mode 100755
index 0000000..bb2fbe6
--- /dev/null
+++ b/src/nb_plugin/rest/rest_debug.h
@@ -0,0 +1,94 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_REST_DEBUG_H
+#define	INCLUDE_REST_DEBUG_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+#include  "openapps_log_api.h"
+#define _REST_DEBUG
+
+#define _REST_DEBUG_LEVEL         0x00 
+
+#define _REST_DEBUG_TRACE        (0x1)
+#define _REST_DEBUG_INFO         (0x01 << 1)
+#define _REST_DEBUG_ERROR        (0x01 << 2)
+#define _REST_DEBUG_DUMPJSON     (0x01 << 3)
+#define _REST_DEBUG_ALL          (0xFF)
+extern void log_post(BVIEW_SEVERITY severity, char * format, ...);
+#ifdef _REST_DEBUG
+#define _REST_LOG(level, format,args...)   do { \
+            if ((level) & _REST_DEBUG_LEVEL) { \
+                printf(format, ##args); \
+            } \
+        }while(0)
+#else 
+#define _REST_LOG(level, format,args...)
+#endif
+
+/* Utility Macros for parameter validation */
+#define _REST_ASSERT_ERROR(condition, errcode) do { \
+    if (!(condition)) { \
+        _REST_LOG(_REST_DEBUG_ERROR, \
+                    "REST (%s:%d) Invalid Input Parameter  \n", \
+                    __func__, __LINE__); \
+        return (errcode); \
+    } \
+} while(0)
+
+#define _REST_ASSERT(condition) _REST_ASSERT_ERROR((condition), (BVIEW_STATUS_INVALID_PARAMETER))
+
+/* Utility Logging Macros */
+
+#define _REST_ASSERT_NET_ERROR(condition, errString) do { \
+    if (!(condition)) { \
+        _REST_LOG(_REST_DEBUG_ERROR, \
+                    "REST (%s:%d) %s. [ERRNO : %s ] \n", \
+                    __func__, __LINE__, (errString), strerror(errno)); \
+        return (BVIEW_STATUS_FAILURE); \
+    } \
+} while(0)
+
+#define _REST_PASSIVE_ASSERT_NET_ERROR(condition, errString) do { \
+    if (!(condition)) { \
+        _REST_LOG(_REST_DEBUG_ERROR, \
+                    "REST (%s:%d) %s. [ERRNO : %s ] \n", \
+                    __func__, __LINE__, (errString), strerror(errno)); \
+    } \
+} while(0)
+
+#define _REST_ASSERT_NET_SOCKET_ERROR(condition, errString,fd) do { \
+    if (!(condition)) { \
+        _REST_LOG(_REST_DEBUG_ERROR, \
+                    "REST (%s:%d) %s. [ERRNO : %s ] \n", \
+                    __func__, __LINE__, (errString), strerror(errno)); \
+        close(fd); \
+        return (BVIEW_STATUS_FAILURE); \
+    } \
+} while(0)
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_REST_DEBUG_H */
+
diff --git a/src/nb_plugin/rest/rest_http.h b/src/nb_plugin/rest/rest_http.h
new file mode 100755
index 0000000..c1d3832
--- /dev/null
+++ b/src/nb_plugin/rest/rest_http.h
@@ -0,0 +1,39 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_REST_HTTP_H
+#define	INCLUDE_REST_HTTP_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#define REST_HTTP_CRLF          "\r\n"
+#define REST_HTTP_TWIN_CRLF     "\r\n\r\n"
+#define REST_HTTP_SPACE         " "    
+    
+    
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_REST_HTTP_H */
+
diff --git a/src/nb_plugin/rest/rest_http_client.c b/src/nb_plugin/rest/rest_http_client.c
new file mode 100755
index 0000000..fd5069b
--- /dev/null
+++ b/src/nb_plugin/rest/rest_http_client.c
@@ -0,0 +1,319 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "broadview.h"
+#include "rest.h"
+#include "rest_http.h"
+
+/******************************************************************
+ * @brief  sends a HTTP 200 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ *
+ * @retval   BVIEW_STATUS_SUCCESS 
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_200_with_data(int fd, char *buffer, int length)
+{
+    char *response = "HTTP/1.1 200 OK \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n"
+            "Content-Type: text/json \r\n\r\n";
+    int bytes_sent =0;
+    BVIEW_STATUS  rv = BVIEW_STATUS_SUCCESS;
+    int sendbuff =0;
+
+    if (0 > send(fd, response, strlen(response), MSG_MORE))
+    {
+      rv = BVIEW_STATUS_FAILURE;
+    }
+    bytes_sent = send(fd, buffer, length, MSG_MORE);
+    if (0 > bytes_sent)
+    {
+      rv = BVIEW_STATUS_FAILURE;
+    }
+   
+ 
+    while (length - bytes_sent > 0)
+    {
+       /* Calling continues send with buffer size more than 8K will result in ERROR from
+        * kernel so increase kernel buffer size for this FD.
+        */
+       sendbuff = length;
+       if (0 > setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &sendbuff, sizeof(sendbuff)))
+       {
+         return BVIEW_STATUS_FAILURE;
+       }
+
+       buffer = buffer + bytes_sent;
+       length = length - bytes_sent;
+       bytes_sent = send(fd, buffer, length, 0);
+       if (0 > bytes_sent)
+       {
+         return BVIEW_STATUS_FAILURE;
+       }
+    }
+    return rv;
+}
+
+/******************************************************************
+ * @brief  sends a HTTP 200 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ *
+ * @retval   BVIEW_STATUS_SUCCESS 
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_200(int fd)
+{
+    char *response = "HTTP/1.1 200 OK \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n\r\n";
+
+    if (0 > send(fd, response, strlen(response), 0))
+        return BVIEW_STATUS_FAILURE;
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  sends a HTTP 404 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ *
+ * @retval   BVIEW_STATUS_SUCCESS 
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_404(int fd)
+{
+    char *response = "HTTP/1.1 404 Not Found \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n\r\n "
+            "<html> <body> Unsupported </body> </html>";
+
+    if (0 > send(fd, response, strlen(response), 0))
+        return BVIEW_STATUS_FAILURE;
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  sends a HTTP 400 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ *
+ * @retval   BVIEW_STATUS_SUCCESS 
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_400(int fd)
+{
+    char *response = "HTTP/1.1 400 Bad Request \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n\r\n"
+            "<html> <body> Bad Request </body> </html>";
+
+   if (0 > send(fd, response, strlen(response), 0))
+        return BVIEW_STATUS_FAILURE;
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  sends a HTTP 500 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ *
+ * @retval   BVIEW_STATUS_SUCCESS 
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_500(int fd)
+{
+    char *response = "HTTP/1.1 500 Internal Server Error \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n\r\n"
+            "<html> <body> Internal Server Error </body> </html>";
+
+   if (0 > send(fd, response, strlen(response), 0))
+        return BVIEW_STATUS_FAILURE;
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  sends an asynchronous report to the client 
+ *
+ * @param[in]   rest    context for reading configuration
+ * @param[in]   buffer  Buffer containing data to be sent
+ * @param[in]   length  number of bytes to be sent 
+ * 
+ * @retval   BVIEW_STATUS_SUCCESS if send is successful
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_async_report(REST_CONTEXT_t *rest, char *buffer, int length)
+{
+    char *header = "POST /agent_response HTTP/1.1\r\n"
+            "Host: BVIEW Client\r\n"
+            "User-Agent: BroadViewAgent\r\n"
+            "Accept: text/html,application/xhtml+xml,application/xml\r\n"
+            "Content-Length: %d\r\n"
+            "\r\n";
+
+    char buf[REST_MAX_HTTP_BUFFER_LENGTH] = { 0 };
+    int clientFd;
+    struct sockaddr_in clientAddr;
+    int temp = 0;
+    BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+    snprintf(buf, REST_MAX_HTTP_BUFFER_LENGTH - 1, header, length);
+
+    /* create socket to send data to */
+    clientFd = socket(AF_INET, SOCK_STREAM, 0);
+    _REST_ASSERT_NET_ERROR((clientFd != -1), "Error Creating server socket");
+
+    /* take lock while copying the info */
+    if (0 != pthread_mutex_lock (&rest->config_mutex))
+    {
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Failed to take the lock for rest config \r\n");
+      close(clientFd);
+      return BVIEW_STATUS_FAILURE;
+    }
+
+    /* setup the socket */
+    memset(&clientAddr, 0, sizeof (struct sockaddr_in));
+    clientAddr.sin_family = AF_INET;
+    clientAddr.sin_port = htons(rest->config.clientPort);
+
+    temp = inet_pton(AF_INET, &rest->config.clientIp[0], &clientAddr.sin_addr);
+    /* release the lock */
+    if (0 != pthread_mutex_unlock (&rest->config_mutex))
+    {
+      LOG_POST (BVIEW_LOG_ERROR,
+          "Failed to release the lock for rest config \r\n");
+      close(clientFd);
+      return BVIEW_STATUS_FAILURE;
+    }
+    _REST_ASSERT_NET_SOCKET_ERROR((temp > 0), "Error Creating server socket",clientFd);
+
+    /* connect to the peer */
+    temp = connect(clientFd, (struct sockaddr *) &clientAddr, sizeof (clientAddr));
+    _REST_ASSERT_NET_SOCKET_ERROR((temp != -1), "Error connecting to client for sending async reports",clientFd);
+
+    /* send data */
+    if (0 > send(clientFd, buf, strlen(buf),MSG_MORE))
+      rv = BVIEW_STATUS_FAILURE;
+
+    if (0 > send(clientFd, buffer, length, 0))
+      rv = BVIEW_STATUS_FAILURE;
+    
+    /* close down session */
+    close(clientFd);
+
+    return rv;
+
+}
+
+/******************************************************************
+ * @brief  sends a HTTP 404 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ * @param[in]   buffer  Buffer containing data to be sent
+ * @param[in]   length  number of bytes to be sent 
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if send is successful
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_404_with_data(int fd, char *buffer, int length)
+{
+    char *response = "HTTP/1.1 404 Not Found \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n\r\n "
+             "Content-Type: text/json";
+
+    if (0 > send(fd, response, strlen(response), MSG_MORE))
+      return BVIEW_STATUS_FAILURE;
+
+    if (0 > send(fd, buffer, length, 0))
+      return BVIEW_STATUS_FAILURE;
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  sends a HTTP 400 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ * @param[in]   buffer  Buffer containing data to be sent
+ * @param[in]   length  number of bytes to be sent 
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if send is successful
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_400_with_data(int fd, char *buffer, int length)
+{
+    char *response = "HTTP/1.1 400 Bad Request \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n\r\n"
+             "Content-Type: text/json";
+
+    if (0 > send(fd, response, strlen(response), MSG_MORE))
+      return BVIEW_STATUS_FAILURE;
+
+    if (0 > send(fd, buffer, length, 0))
+      return BVIEW_STATUS_FAILURE;
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  sends a HTTP 500 message to the client 
+ *
+ * @param[in]   fd    socket for sending message
+ * @param[in]   buffer  Buffer containing data to be sent
+ * @param[in]   length  number of bytes to be sent 
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if send is successful
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_send_500_with_data(int fd, char *buffer, int length)
+{
+    char *response = "HTTP/1.1 500 Internal Server Error \r\n"
+            "Server: BroadViewAgent (Unix) (Linux) \r\n\r\n"
+             "Content-Type: text/json";
+
+    if (0 > send(fd, response, strlen(response), MSG_MORE))
+      return BVIEW_STATUS_FAILURE;
+
+    if (0 > send(fd, buffer, length, 0))
+      return BVIEW_STATUS_FAILURE;
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+
diff --git a/src/nb_plugin/rest/rest_http_server.c b/src/nb_plugin/rest/rest_http_server.c
new file mode 100755
index 0000000..df6786e
--- /dev/null
+++ b/src/nb_plugin/rest/rest_http_server.c
@@ -0,0 +1,461 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <arpa/inet.h>
+#include <errno.h>
+
+#include "broadview.h"
+
+#include "json.h"
+#include "cJSON.h"
+
+#include "rest.h"
+#include "rest_http.h"
+
+#include "openapps_feature.h"
+#include "modulemgr.h"
+
+#define BVIEW_REST_MAX_SUPPORTED_METHODS 4
+
+/******************************************************************
+ * @brief  validates a string , whether its a proper HTTP method or not 
+ *
+ * @param[in]   method    string for validation
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if the string is a valid HTTP method
+ * @retval   BVIEW_STATUS_FAILURE otherwise
+ * 
+ * @note     
+ *********************************************************************/
+static BVIEW_STATUS rest_validate_http_method(char *method)
+{
+    /* Not exhaustive, but minimal methods for functionality */
+    static char *supportedMethods[] = { "GET" , "POST", "PUT", "DELETE" };
+    int i = 0;
+    for (i = 0; i < BVIEW_REST_MAX_SUPPORTED_METHODS; i++)
+    {
+        if (strcmp(method, supportedMethods[i]) == 0)
+            return BVIEW_STATUS_SUCCESS;
+    }
+
+    return BVIEW_STATUS_FAILURE;
+}
+
+/******************************************************************
+ * @brief  validates a string , whether its a supported URL or not 
+ *
+ * @param[in]   method    string for validation
+ *
+ * @retval   BVIEW_STATUS_SUCCESS if the string is a valid URL
+ * @retval   BVIEW_STATUS_FAILURE otherwise
+ * 
+ * @note     
+ *********************************************************************/
+static BVIEW_STATUS rest_validate_url(char *url)
+{
+    /* currently hard-coded for BST */
+    if ((strstr(url, "broadview/bst/") != NULL) ||
+        (strstr(url, "broadview/packettrace/") != NULL) || 
+        (strstr(url, "broadview/")))
+    {
+        return BVIEW_STATUS_SUCCESS;
+    }
+
+    return BVIEW_STATUS_FAILURE;
+}
+
+/******************************************************************
+ * @brief  This function parses http request to extract relevant fields.
+ *
+ * @param[in]   rest    REST context for operation
+ * @param[in]   fd      socket to read request data from
+ * @param[in]   peer    The connecting peer details
+ * 
+ * @note     
+ *********************************************************************/
+static BVIEW_STATUS rest_parse_http_request_to_session (REST_SESSION_t *session)
+{
+    char *buf = &session->buffer[0];
+    char *httpMethod, *url, *json, *restMethod;
+    BVIEW_STATUS status;
+    int temp = 0, urlLength = 0;
+
+    /* raw http data is available @ session->buffer */
+    /* This needs to be parsed into httpMethod, URL and the JSON body */
+
+
+    /* HTTP method will be the first word of the request */
+    httpMethod = strtok(buf, REST_HTTP_SPACE);
+    _REST_ASSERT_NET_ERROR((httpMethod != NULL), "REST : Invalid HTTP Request \n");
+
+    /* validate the method */
+    status = rest_validate_http_method(httpMethod);
+    _REST_ASSERT_NET_ERROR((status == BVIEW_STATUS_SUCCESS), "REST : Unsupported HTTP Method \n");
+
+    /* advance the buf, now it should point to the URL */
+    buf += strlen(httpMethod) + 1;
+
+    url = strtok(buf, REST_HTTP_SPACE);
+    _REST_ASSERT_NET_ERROR((url != NULL), "REST : Invalid HTTP Request \n");
+
+    /* validate the URL */
+    status = rest_validate_url(url);
+    _REST_ASSERT_NET_ERROR((status == BVIEW_STATUS_SUCCESS),
+                           "REST : Unsupported URL \n");
+
+    /* obtain the REST method */
+    restMethod = url;
+    urlLength = strlen(url);
+    for (temp = 0; temp < urlLength; temp++)
+    {
+        /* method is the string after the last / */
+        if (url[temp] == '/')
+        {
+            if (temp < (urlLength - 1))
+                restMethod = &url[temp + 1];
+        }
+    }
+
+    /* move buf, past the URL, this should now point to HTTP header, */
+    buf += urlLength + 1;
+
+    /* look for the twin carriage-return-linefeed sequence, which signals end of header */
+    json = strstr(buf, REST_HTTP_TWIN_CRLF);
+    _REST_ASSERT_NET_ERROR((json != NULL), "REST : Invalid HTTP Request \n");
+
+    /* move past the end of header, after which, json points to body */
+    json += strlen(REST_HTTP_TWIN_CRLF);
+
+    /* update the session */
+    session->json = json;
+    strncpy(session->httpMethod, httpMethod, REST_MAX_STRING_LENGTH);
+    strncpy(session->url, url, REST_MAX_STRING_LENGTH);
+    memcpy(session->restMethod, restMethod, REST_MAX_STRING_LENGTH);
+    session->length -= (json - session->buffer);
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  This function processes incoming http request .
+ *
+ * @param[in]   rest    REST context for operation
+ * @param[in]   fd      socket to read request data from
+ * @param[in]   peer    The connecting peer details
+ * 
+ * @note     All errors are processed internally. Caller ignores the RV
+ *********************************************************************/
+static BVIEW_STATUS rest_process_http_request (REST_CONTEXT_t *rest,
+                                               int fd,
+                                               struct sockaddr_in peer,
+                                               socklen_t peerLen)
+{
+    int sessionId;
+    BVIEW_STATUS status, ret;
+    REST_SESSION_t *session;
+    char *buf;
+    int length = 0;
+    int temp = 0;
+    int id =0;
+    struct timeval timeout;
+    fd_set cset;
+    int retval = 0;
+    
+
+    BVIEW_REST_API_HANDLER_t handler;
+
+    _REST_LOG(_REST_DEBUG_TRACE, "Extracting data from incoming request  \n");
+
+    /* find an available session buffer for this request */
+    status = rest_allocate_session(rest, &sessionId);
+    _REST_ASSERT_NET_ERROR((status == BVIEW_STATUS_SUCCESS),
+                           "REST : No available session for incoming request \n");
+    session = &rest->sessions[sessionId];
+
+    buf = &session->buffer[0];
+
+   for (;;)
+   {
+     FD_ZERO (&cset);
+     FD_SET (fd, &cset);
+
+     timeout.tv_sec = 2;
+     timeout.tv_usec = 0;
+
+     retval = select (fd+1, &cset, NULL, NULL, &timeout);
+     if (retval < 0) 
+     {
+       /* error; log/die/whatever and close() socket */
+       _REST_LOG(_REST_DEBUG_ERROR,
+           "REST : Error select of socket failed, closing socket [%d : %s] \n",
+           errno, strerror(errno));
+       close(fd);
+       return BVIEW_STATUS_SUCCESS;
+     }
+     else if (retval == 0) 
+     {
+       /* timed out without receiving any data; log/die/whatever and close() */
+       _REST_LOG(_REST_DEBUG_ERROR,
+           "REST : Socket timed out no data, closing socket [%d : %s] \n",
+           errno, strerror(errno));
+       break;
+     }
+
+     temp = read(fd, (buf + length), (REST_MAX_HTTP_BUFFER_LENGTH - length));
+     if (temp < 0)
+     {
+       if (errno == EINTR)
+       {
+         continue; /* perfectly normal; try again */
+       }
+       else if (errno == EAGAIN) 
+       {
+         continue;
+       }
+       else
+       {
+         /* some real error; log/die/whatever and close() socket */
+         _REST_LOG(_REST_DEBUG_ERROR,
+             "REST : Socket read error, closing socket [%d : %s] \n",
+             errno, strerror(errno));
+         close(fd);
+         return BVIEW_STATUS_SUCCESS;
+       }
+     } 
+     else if (temp == 0)
+     {
+       /* the connection has been closed by your peer; clean-up and close() */
+       _REST_LOG(_REST_DEBUG_ERROR,
+           "REST : Socket closed by peer, closing socket [%d : %s] \n",
+           errno, strerror(errno));
+       break;
+     }
+     else
+     {
+       /* you got some data; do whatever with it... */
+       length += temp;
+       continue;
+     }
+   }
+
+
+    /* update the session */
+    session->connectionFd = fd;
+    session->peerAddr = peer;
+    time(&session->creationTime);
+    session->length = length;
+
+    status = rest_parse_http_request_to_session(session);
+
+    ret =  rest_get_id_from_request (session->json, session->length, &id);
+
+    if ((BVIEW_STATUS_SUCCESS == ret) && (BVIEW_STATUS_SUCCESS != status))
+    {
+      status = BVIEW_STATUS_UNSUPPORTED;
+      rest_json_error_fn_invoke(fd, status, id);
+      close(fd);
+      session->inUse = false;
+      return BVIEW_STATUS_SUCCESS;
+    }
+    else
+    {
+      if (status != BVIEW_STATUS_SUCCESS)
+      {
+        /* send a 404 unsupported back to client */
+        rest_send_404(fd);
+        close(fd);
+        return BVIEW_STATUS_SUCCESS;
+      }
+    }
+
+    _REST_LOG(_REST_DEBUG_TRACE, "Data extraction from incoming request complete  \n");
+
+    rest_session_dump(session);
+
+    /* mark the session as 'used' */
+    session->inUse = true;
+
+    /* talk to module manager and get the handler for this request */
+    status = modulemgr_rest_api_handler_get(session->json, session->length, &handler);
+   
+    if (BVIEW_STATUS_SUCCESS == status)
+    {
+      _REST_LOG(_REST_DEBUG_TRACE, "successfully found the api handler for the inputted json\n");
+    }
+ 
+    if ((BVIEW_STATUS_SUCCESS == ret) && (BVIEW_STATUS_SUCCESS != status))
+    {
+      status = BVIEW_STATUS_UNSUPPORTED;
+      rest_json_error_fn_invoke(fd, status, id);
+      close(fd);
+      session->inUse = false;
+      return BVIEW_STATUS_SUCCESS;
+    }
+    else
+    {
+      /* if there is no registered handler for this request, send a 404 */
+      if (status != BVIEW_STATUS_SUCCESS)
+      {
+        /* send a 404 unsupported back to client */
+        rest_send_404(fd);
+        close(fd);
+        session->inUse = false;
+        return BVIEW_STATUS_SUCCESS;
+      }
+    }
+
+    /* invoke the handler */
+    status = handler(session, session->json, session->length);
+
+    if ((BVIEW_STATUS_SUCCESS == ret) && (BVIEW_STATUS_SUCCESS != status))
+    {
+      rest_json_error_fn_invoke(fd, status, id);
+      close(fd);
+      session->inUse = false;
+      return BVIEW_STATUS_SUCCESS;
+    }
+    else
+    {
+      /* if not successful processing the request, send appropriate error code */
+      if (status != BVIEW_STATUS_SUCCESS)
+      {
+        if (status == BVIEW_STATUS_INVALID_JSON)
+        {
+          rest_send_500(fd);
+        }
+        else
+        {
+          rest_send_400(fd);
+        }
+
+        close(fd);
+        session->inUse = false;
+        return BVIEW_STATUS_SUCCESS;
+      }
+    }
+
+    /* we keep the session, and keep the fd open. */
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  This function starts a web server and never returns (unless an error).
+ *
+ * @param[in]   rest      REST context for operation
+ *                           
+ * @retval   BVIEW_STATUS_FAILURE Error creating web server
+ *
+ * @note     IPv4 only, non-multi-threaded.
+ *********************************************************************/
+BVIEW_STATUS rest_http_server_run(REST_CONTEXT_t *rest)
+{
+    int listenFd, connectionFd;
+    int temp;
+    struct sockaddr_in serverAddr;
+    struct sockaddr_in peerAddr;
+    socklen_t peerLen;
+
+    _REST_ASSERT(rest != NULL);
+
+    _REST_LOG(_REST_DEBUG_INFO, "Starting HTTP server on port %d \n", rest->config.localPort);
+
+    /* setup listening socket */
+    listenFd = socket(AF_INET, SOCK_STREAM, 0);
+    _REST_ASSERT_NET_ERROR((listenFd != -1), "Error Creating server socket");
+
+    /* Initialize the server address and bind to the required port */
+    memset(&serverAddr, 0, sizeof (struct sockaddr_in));
+    serverAddr.sin_family = AF_INET;
+    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
+    serverAddr.sin_port = htons(rest->config.localPort);
+
+    /* bind to the socket, */
+    temp = bind(listenFd, (struct sockaddr*) &serverAddr, sizeof (serverAddr));
+    _REST_ASSERT_NET_SOCKET_ERROR((temp != -1), "Error binding to the port",listenFd);
+
+    /* Listen for connections */
+    temp = listen(listenFd, REST_MAX_SESSIONS);
+    _REST_ASSERT_NET_SOCKET_ERROR((temp != -1), "Error listening (making socket as passive) ",listenFd);
+
+    /* Every thing set, start accepting connections */
+    while (true)
+    {
+        _REST_LOG(_REST_DEBUG_TRACE, "Waiting for HTTP connections on port %d \n", rest->config.localPort);
+
+        peerLen = sizeof (peerAddr);
+
+        /* wait for an incoming connection */
+        temp = accept(listenFd, (struct sockaddr*) &peerAddr, &peerLen);
+        if (temp == -1)
+        {
+          _REST_LOG(_REST_DEBUG_TRACE, "Accept Failed \n");
+          continue;
+        }
+
+        _REST_LOG(_REST_DEBUG_TRACE, "Received connection \n");
+
+        /* initialize the connection socket */
+        connectionFd = temp;
+
+        /* process the request */
+        rest_process_http_request(rest, connectionFd, peerAddr, peerLen);
+    }
+
+    /* execution  shouldn't reach here */
+    _REST_LOG(_REST_DEBUG_TRACE, "HTTP Server , Unknown error, exiting [%d: %s] \n", errno, strerror(errno));
+    close(listenFd);
+    return BVIEW_STATUS_SUCCESS;
+
+}
+
+
+BVIEW_STATUS rest_get_id_from_request(char * jsonBuffer, int bufLength, int *id)
+{
+  cJSON *root, *json_id;
+  int temp_id =0;
+
+  /* Validating 'jsonBuffer' */
+  JSON_VALIDATE_POINTER(jsonBuffer,"jsonBuffer",BVIEW_STATUS_INVALID_PARAMETER);
+
+
+  /* Parse JSON to a C-JSON root */
+  root = cJSON_Parse(jsonBuffer);
+  JSON_VALIDATE_JSON_POINTER(root,"root",BVIEW_STATUS_INVALID_JSON);
+
+
+  json_id = cJSON_GetObjectItem(root, "id");
+  JSON_VALIDATE_JSON_POINTER(json_id, "id", BVIEW_STATUS_INVALID_JSON);
+  JSON_VALIDATE_JSON_AS_NUMBER(json_id, "id");
+  temp_id = json_id->valueint;
+  /* Ensure  that the number 'id' is within range of [1,100000] */
+  JSON_CHECK_VALUE_AND_CLEANUP (temp_id, 1, 100000);
+
+  *id = temp_id;
+  return BVIEW_STATUS_SUCCESS;
+
+}
+
diff --git a/src/nb_plugin/rest/rest_session.c b/src/nb_plugin/rest/rest_session.c
new file mode 100755
index 0000000..250a97c
--- /dev/null
+++ b/src/nb_plugin/rest/rest_session.c
@@ -0,0 +1,110 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "broadview.h"
+#include "rest.h"
+
+/******************************************************************
+ * @brief  initialize sessions 
+ *
+ * @param[in]   rest      REST context for operation
+ *
+ * @retval   BVIEW_STATUS_SUCCESS on successful initialization
+ * @retval   BVIEW_STATUS_FAILURE otherwise
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_sessions_init(REST_CONTEXT_t *context)
+{
+    int i = 0;
+    REST_SESSION_t *session;
+
+    /* Just basic initialization */
+
+    for (i = 0; i < REST_MAX_SESSIONS; i++)
+    {
+        session = &context->sessions[i];
+        memset(session, 0, sizeof (REST_SESSION_t));
+        session->inUse = false;
+    }
+
+    return BVIEW_STATUS_SUCCESS;
+}
+
+/******************************************************************
+ * @brief  allocates an available session (returns the index) 
+ *
+ * @param[in]   rest      REST context for operation
+ *
+ * @retval   BVIEW_STATUS_SUCCESS on successful allocation
+ * @retval   BVIEW_STATUS_RESOURCE_NOT_AVAILABLE otherwise
+ * 
+ * @note     
+ *********************************************************************/
+BVIEW_STATUS rest_allocate_session(REST_CONTEXT_t *context, int *sessionId)
+{
+    int i = 0;
+    for (i = 0; i < REST_MAX_SESSIONS; i++)
+    {
+        if (context->sessions[i].inUse == false)
+        {
+            *sessionId = i;
+            memset(&context->sessions[i], 0, sizeof (REST_SESSION_t));
+            return BVIEW_STATUS_SUCCESS;
+        }
+    }
+
+    return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE;
+}
+
+/******************************************************************
+ * @brief  Checks if the supplied session is valid 
+ *
+ * @param[in]   session      session to be validated
+ *
+ *********************************************************************/
+BVIEW_STATUS rest_session_validate(REST_CONTEXT_t *context, REST_SESSION_t *session)
+{
+    int i = 0;
+    
+    for (i = 0; i < REST_MAX_SESSIONS; i++)
+    {
+        if (&context->sessions[i] == session)
+            return BVIEW_STATUS_SUCCESS;
+    }
+    
+    return BVIEW_STATUS_RESOURCE_NOT_AVAILABLE;
+}
+
+/******************************************************************
+ * @brief  dump a session on console/log
+ *
+ * @param[in]   session      data to be dumped
+ *
+ *********************************************************************/
+void rest_session_dump(REST_SESSION_t *session)
+{
+    _REST_LOG(_REST_DEBUG_TRACE, "Session : HTTPMethod : %s - REST Method : %s - URL : %s - Length %d \n",
+              session->httpMethod, session->restMethod, session->url, session->length);
+}
+
+
diff --git a/src/public/asic.h b/src/public/asic.h
new file mode 100755
index 0000000..bbc3296
--- /dev/null
+++ b/src/public/asic.h
@@ -0,0 +1,89 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_ASIC_H
+#define	INCLUDE_ASIC_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#define BVIEW_ASIC_MAX_PORTS            130
+#define BVIEW_ASIC_MAX_UC_QUEUES        4096
+#define BVIEW_ASIC_MAX_UC_QUEUE_GROUPS  128
+#define BVIEW_ASIC_MAX_MC_QUEUES        1040
+#define BVIEW_ASIC_MAX_SERVICE_POOLS    4
+#define BVIEW_ASIC_MAX_COMMON_POOLS     1
+#define BVIEW_ASIC_MAX_CPU_QUEUES       8
+#define BVIEW_ASIC_MAX_RQE_QUEUES       11
+#define BVIEW_ASIC_MAX_RQE_QUEUE_POOLS  4
+#define BVIEW_ASIC_MAX_PRIORITY_GROUPS  8
+
+#define BVIEW_ASIC_MAX_INGRESS_SERVICE_POOLS  \
+    (BVIEW_ASIC_MAX_SERVICE_POOLS + BVIEW_ASIC_MAX_COMMON_POOLS)
+
+/** Different scalability numbers for the ASIC */
+typedef struct _capabilities_
+{
+        /** Number of ports of Asic */
+        int numPorts;
+        /** Number of unicast queues */
+        int numUnicastQueues;
+        /** Number of unicast queue groups */
+        int numUnicastQueueGroups;
+        /** Number of multicast queues */
+        int numMulticastQueues;
+        /** Number of service pools */
+        int numServicePools;
+        /** Number of common pools */
+        int numCommonPools;
+        /** Number of CPU queues */
+        int numCpuQueues;
+        /** Number of RQE queues */
+        int numRqeQueues;
+        /** Number of RQE queue pools */
+        int numRqeQueuePools;
+        /** Number of priority groups */
+        int numPriorityGroups;
+        /** can this ASIC provide accurate time ? */
+        bool support1588;
+        /** MMU Cell to BYTE conversion*/
+        int cellToByteConv;
+        
+} BVIEW_ASIC_CAPABILITIES_t;
+
+
+/** This structure defines an ASIC from an instrumentation perspective */
+typedef struct _bview_asic_
+{
+    /** Asic/Unit number */
+    int unit;
+    /** The ASIC model number */
+    BVIEW_ASIC_TYPE  asicType;
+    /** Asic Capabilities */
+    BVIEW_ASIC_CAPABILITIES_t scalingParams;
+} BVIEW_ASIC_t;
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_ASIC_H */
+
diff --git a/src/public/broadview.h b/src/public/broadview.h
new file mode 100755
index 0000000..97d23ed
--- /dev/null
+++ b/src/public/broadview.h
@@ -0,0 +1,127 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_BVIEW_H
+#define INCLUDE_BVIEW_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdio.h>
+#include <time.h>
+#include <stdbool.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+/** Maximum length of network os string*/
+#define BVIEW_NETWORK_OS_LEN_MAX       32
+
+/** Maximum supported asics on a platform */ 
+#define BVIEW_MAX_ASICS_ON_A_PLATFORM   1
+
+/** Maximum supported features */
+#define BVIEW_MAX_FEATURES              16
+
+/** Max api cmds supported per feature */
+#define BVIEW_MAX_API_CMDS_PER_FEATURE  16
+
+/** Maximum supported sb plugins */
+#define BVIEW_MAX_SUPPORTED_SB_PLUGINS   8 
+
+/** Maximum supported features per a sb plug-in (BVIEW_MAX_FEATURES+system feature) */
+#define BVIEW_SBPLUGIN_MAX_FEATURES    (BVIEW_MAX_FEATURES+1) 
+
+/** json version */
+#define BVIEW_JSON_VERSION   1 
+    /** Indicates various status codes.
+    *  This status codes are typically used as return values for function 
+    *  calls. However, they can be used elsewhere as well to indicate
+    *  execution status.
+    */
+
+    typedef enum _bview_status
+    {
+        BVIEW_STATUS_SUCCESS = 0, /**< Successful completion of request */
+        BVIEW_STATUS_FAILURE, /**< Unsuccessful completion of request */
+        BVIEW_STATUS_INVALID_PARAMETER,
+        BVIEW_STATUS_UNSUPPORTED,
+        BVIEW_STATUS_OUTOFMEMORY,
+        BVIEW_STATUS_TIMEOUT,
+        BVIEW_STATUS_NOTREADY,
+        BVIEW_STATUS_TABLE_FULL,
+        BVIEW_STATUS_INVALID_COMMAND,
+        BVIEW_STATUS_INVALID_JSON,
+        BVIEW_STATUS_RESOURCE_NOT_AVAILABLE,
+        BVIEW_STATUS_INVALID_MEMORY,
+        BVIEW_STATUS_OUTOFRANGE,
+        BVIEW_STATUS_INIT_FAILED,
+        BVIEW_STATUS_INVALID_ID,
+        BVIEW_STATUS_DUPLICATE  /** If the entry is alreadey present */ 
+    } BVIEW_STATUS;
+
+    typedef enum _asic_type
+    {
+      BVIEW_ASIC_TYPE_TD2   =  (1 << 0), 
+      BVIEW_ASIC_TYPE_TH    =  (1 << 1),
+      BVIEW_ASIC_TYPE_ALL   =  (0xFFFF) 	  
+    } BVIEW_ASIC_TYPE;
+
+ /** type define time_t to BVIEW_TIME_t */
+    typedef time_t BVIEW_TIME_t;
+
+#if (__STDC_VERSION__ >= 199901L)
+  #include <stdint.h>
+#else
+#ifndef _STDINT_H
+    typedef unsigned long long uint64_t;
+    typedef unsigned char uint8_t;
+#endif
+#endif
+
+#if (CPU==gto)||(CPU==xlp)
+    #define ENV32BIT
+#elif (CPU==x86_64)||(CPU==pclinux)
+    #define ENV64BIT
+#else 
+    #define ENV32BIT  /* Default environment */
+#endif
+	
+#ifdef ENV32BIT
+    typedef unsigned long int ptr_to_uint_t;
+    #define PRI_PTR_TO_UINT_FMT "lx" 
+#else
+#ifdef ENV64BIT
+	typedef unsigned long long int ptr_to_uint_t;
+    #define PRI_PTR_TO_UINT_FMT "llx" 
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_BVIEW_H */
diff --git a/src/public/bst.h b/src/public/bst.h
new file mode 100755
index 0000000..6e13163
--- /dev/null
+++ b/src/public/bst.h
@@ -0,0 +1,514 @@
+/*! \file bst.h
+ */
+
+/*! @addtogroup GLUSMDB API Definitions
+ *  @{
+ *    @addtogroup GLBVIEW BroadView BST Feature Declarations And Definitions [BVIEW]
+ *    @{
+ */
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_BST_H
+#define INCLUDE_BST_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "asic.h"
+#include "sbplugin.h"
+
+/* Buffer Count for the device */
+typedef struct _bst_device_
+{
+    uint64_t bufferCount;
+} BVIEW_BST_DEVICE_DATA_t;
+
+/* Buffer Count for Ingress Port + Priority Groups */
+typedef struct _bst_i_p_pg_
+{
+
+    struct _ippg_data_
+    {
+        uint64_t umShareBufferCount;
+        uint64_t umHeadroomBufferCount;
+    } data[BVIEW_ASIC_MAX_PORTS][BVIEW_ASIC_MAX_PRIORITY_GROUPS];
+
+} BVIEW_BST_INGRESS_PORT_PG_DATA_t;
+
+/* Buffer Count for Ingress Port + Service Pools */
+typedef struct _bst_i_p_sp_
+{
+
+    struct _ipsp_data_
+    {
+        uint64_t umShareBufferCount;
+    } data[BVIEW_ASIC_MAX_PORTS][BVIEW_ASIC_MAX_INGRESS_SERVICE_POOLS];
+
+} BVIEW_BST_INGRESS_PORT_SP_DATA_t;
+
+/* Buffer Count for Ingress Service Pools */
+typedef struct _bst_i_sp_
+{
+
+    struct _isp_data_
+    {
+        uint64_t umShareBufferCount;
+    } data[BVIEW_ASIC_MAX_INGRESS_SERVICE_POOLS];
+
+} BVIEW_BST_INGRESS_SP_DATA_t;
+
+/* Buffer Count for Egress Port + Service Pools */
+typedef struct _bst_e_p_sp_
+{
+
+    struct _epsp_data_
+    {
+        uint64_t ucShareBufferCount;
+        uint64_t umShareBufferCount;
+        uint64_t mcShareBufferCount;
+        uint64_t mcShareQueueEntries;
+    } data[BVIEW_ASIC_MAX_PORTS][BVIEW_ASIC_MAX_SERVICE_POOLS];
+
+} BVIEW_BST_EGRESS_PORT_SP_DATA_t;
+
+/* Buffer Count for Egress Service Pools */
+typedef struct _bst_e_sp_
+{
+
+    struct _esp_data_
+    {
+        uint64_t umShareBufferCount;
+        uint64_t mcShareBufferCount;
+        uint64_t mcShareQueueEntries;
+    } data[BVIEW_ASIC_MAX_SERVICE_POOLS];
+
+} BVIEW_BST_EGRESS_SP_DATA_t;
+
+/* Buffer Count for Egress Unicast Queues */
+typedef struct _bst_e_ucq_
+{
+
+    struct _eucq_data_
+    {
+        uint64_t ucBufferCount;
+        uint64_t port; /* to indicate the port number using this queue */
+    } data[BVIEW_ASIC_MAX_UC_QUEUES];
+
+} BVIEW_BST_EGRESS_UC_QUEUE_DATA_t;
+
+/* Buffer Count for Egress Unicast Queue Groups */
+typedef struct _bst_e_ucqg_
+{
+
+    struct _eucqg_data_
+    {
+        uint64_t ucBufferCount;
+    } data[BVIEW_ASIC_MAX_UC_QUEUE_GROUPS];
+
+} BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t;
+
+/* Buffer Count for Egress Multicast Queues */
+typedef struct _bst_e_mcq_
+{
+
+    struct _emcq_data_
+    {
+        uint64_t mcBufferCount;
+        uint64_t mcQueueEntries;
+        uint64_t port; /* to indicate the port number using this queue */
+    } data[BVIEW_ASIC_MAX_MC_QUEUES];
+
+} BVIEW_BST_EGRESS_MC_QUEUE_DATA_t;
+
+/* Buffer Count for CPU Queues */
+typedef struct _bst_cpu_q_
+{
+
+    struct _cpuq_data_
+    {
+        uint64_t cpuBufferCount;
+        uint64_t cpuQueueEntries;
+    } data[BVIEW_ASIC_MAX_CPU_QUEUES];
+
+} BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t;
+
+/* Buffer Count for RQE Queues */
+typedef struct _bst_rqe_q_
+{
+
+    struct _rqeq_data_
+    {
+        uint64_t rqeBufferCount;
+        uint64_t rqeQueueEntries;
+    } data[BVIEW_ASIC_MAX_RQE_QUEUES];
+
+} BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t;
+
+/* A Complete Data set for a 'snapshot' */
+
+typedef struct _bst_asic_data_snapshot_
+{
+    /* Device Section */
+    BVIEW_BST_DEVICE_DATA_t device;
+
+    /* Ingress Section */
+    BVIEW_BST_INGRESS_PORT_PG_DATA_t iPortPg;
+    BVIEW_BST_INGRESS_PORT_SP_DATA_t iPortSp;
+    BVIEW_BST_INGRESS_SP_DATA_t iSp;
+
+    /* Egress Section */
+    BVIEW_BST_EGRESS_PORT_SP_DATA_t ePortSp;
+    BVIEW_BST_EGRESS_SP_DATA_t eSp;
+    BVIEW_BST_EGRESS_UC_QUEUE_DATA_t eUcQ;
+    BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t eUcQg;
+    BVIEW_BST_EGRESS_MC_QUEUE_DATA_t eMcQ;
+    BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t cpqQ;
+    BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t rqeQ;
+
+} BVIEW_BST_ASIC_SNAPSHOT_DATA_t;
+
+/* Statistics collection mode */
+typedef enum _bst_collection_mode_
+{
+    BVIEW_BST_MODE_CURRENT = 1,
+    BVIEW_BST_MODE_PEAK
+} BVIEW_BST_COLLECTION_MODE;
+
+/* Feature Configuration */
+typedef struct _bst_config_
+{
+    /* enable the feature */
+    bool enableStatsMonitoring;
+
+    /* For enabling selectively. When all are disabled, feature is disabled. */
+    bool enableDeviceStatsMonitoring;
+    bool enableIngressStatsMonitoring;
+    bool enableEgressStatsMonitoring;
+
+    /* Statistics collection mode */
+    BVIEW_BST_COLLECTION_MODE mode;
+    /*Periodic collection*/
+    bool enablePeriodicCollection;
+    int  collectionPeriod;
+} BVIEW_BST_CONFIG_t;
+
+/* Trigger Type */
+typedef enum _bst_trigger_type_
+{
+    BVIEW_BST_TRIGGER_DEVICE = (0x1 << 0),
+    BVIEW_BST_TRIGGER_INGRESS = (0x1 << 1),
+    BVIEW_BST_TRIGGER_EGRESS = (0x1 << 2)
+
+} BVIEW_BST_TRIGGER_TYPE;
+
+#define BVIEW_MAX_STRING_NAME_LEN 256
+/* Trigger info */
+typedef struct  _bst_trigger_info_
+{
+  char realm[BVIEW_MAX_STRING_NAME_LEN];
+  char counter[BVIEW_MAX_STRING_NAME_LEN];
+  int port;
+  int queue;
+} BVIEW_BST_TRIGGER_INFO_t;
+
+
+/* Profile configuration  for Egress Port + Service Pools */
+typedef struct _bst_ep_sp_threshold_
+{
+    uint64_t ucShareThreshold;
+    uint64_t umShareThreshold;
+    uint64_t mcShareThreshold;
+    uint64_t mcShareQueueEntriesThreshold;
+} BVIEW_BST_EGRESS_PORT_SP_THRESHOLD_t;
+
+/* Profile configuration for the device level buffers*/
+typedef struct _bst_device_threshold_
+{
+    uint64_t threshold;
+} BVIEW_BST_DEVICE_THRESHOLD_t;
+
+/* Profile configuration for Ingress Port + Priority Groups */
+typedef struct _bst_i_p_pg_threshold_
+{
+    uint64_t umShareThreshold;
+    uint64_t umHeadroomThreshold;
+} BVIEW_BST_INGRESS_PORT_PG_THRESHOLD_t;
+
+/* Profile configuration for Ingress Port + Service Pools */
+typedef struct _bst_i_p_sp_threshold_
+{
+    uint64_t umShareThreshold;
+} BVIEW_BST_INGRESS_PORT_SP_THRESHOLD_t;
+
+/* Profile configuration for Ingress Service Pools */
+typedef struct _bst_i_sp_threshold_
+{
+    uint64_t umShareThreshold;
+} BVIEW_BST_INGRESS_SP_THRESHOLD_t;
+
+/* Profile configuration for Egress Service Pools */
+typedef struct _bst_e_sp_threshold_
+{
+    uint64_t umShareThreshold;
+    uint64_t mcShareThreshold;
+} BVIEW_BST_EGRESS_SP_THRESHOLD_t;
+
+/* Profile configuration for Egress Unicast Queues */
+typedef struct _bst_e_ucq_threshold_
+{
+    uint64_t ucBufferThreshold;
+} BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD_t;
+
+/* Profile configuration for Egress Unicast Queue Groups */
+typedef struct _bst_e_ucqg_threshold_
+{
+    uint64_t ucBufferThreshold;
+} BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD_t;
+
+/* Profile configuration for Egress Multicast Queues */
+typedef struct _bst_e_mcq_threshold_
+{
+    uint64_t mcBufferThreshold;
+    uint64_t mcQueueThreshold;
+} BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD_t;
+
+/* Profile configuration for CPU Queues */
+typedef struct _bst_cpu_q_threshold_
+{
+    uint64_t cpuBufferThreshold;
+    uint64_t cpuQueueThreshold;
+} BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD_t;
+
+/* Profile configuration for RQE Queues */
+typedef struct _bst_rqe_q_threshold_
+{
+    uint64_t rqeBufferThreshold;
+    uint64_t rqeQueueThreshold;
+} BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_t;
+
+/* Maximum length of ASIC ID notation*/
+#define BVIEW_ASIC_NOTATION_LEN             32
+
+typedef struct _switch_asic_info_
+{
+   char              asic_notation[BVIEW_ASIC_NOTATION_LEN];
+   BVIEW_ASIC_TYPE   asicType;
+   int               numPorts;
+   BVIEW_BST_ASIC_SNAPSHOT_DATA_t defBufferVal;
+}  BVIEW_SWITCH_ASIC_INFO_t;
+
+/* Structure to pass API parameters to the BST APP */
+typedef struct _switch_properties_
+{
+    uint8_t networkOs[BVIEW_NETWORK_OS_LEN_MAX];
+    int     numAsics;
+    int     featureMask;
+     BVIEW_SWITCH_ASIC_INFO_t   asicInfo[BVIEW_MAX_ASICS_ON_A_PLATFORM];
+} BVIEW_SWITCH_PROPERTIES_t;
+
+/* The callback for invoking when a configured trigger goes off */
+typedef BVIEW_STATUS(*BVIEW_BST_TRIGGER_CALLBACK_t) (int asic,
+        void *cookie,
+        BVIEW_BST_TRIGGER_INFO_t *triggerInfo);
+
+
+/* macros for threshold validation */
+
+
+
+/* Check the validity of The BST_Threshold for the Egress CPU queues in units of bytes */
+#define BVIEW_BST_E_CPU_THRESHOLD_CHECK(_p)  ((_p)->cpuBufferThreshold <= 0 || \
+                                              (_p)->cpuBufferThreshold > (BVIEW_BST_E_CPU_UCMC_THRES_DEFAULT))
+
+/* Check the validy of threshold configuration for Egress CPU Queues Entries*/
+#define BVIEW_BST_E_CPU_QUEUE_THRESHOLD_CHECK(_p)  ((_p)->cpuQueueThreshold <= 0 || \
+                                                    (_p)->cpuQueueThreshold > (BVIEW_BST_E_CPU_UCMC_THRES_DEFAULT))
+
+/* Check the validy of threshold configuration for Egress Multicast Queues Statistics */
+#define BVIEW_BST_E_MC_THRESHOLD_CHECK(_p)  ((_p)->mcBufferThreshold <= 0 || \
+                                             (_p)->mcBufferThreshold > BVIEW_BST_MCAST_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Egress Multicast Queues Entries*/
+#define BVIEW_BST_E_MC_QUEUE_THRESHOLD_CHECK(_p)  ((_p)->mcQueueThreshold <= 0 || \
+                                                   (_p)->mcQueueThreshold > (0x1FFFF * 208))
+
+/* Check the validy of configuration for Egress Unicast Queue Groups Statistics */
+#define BVIEW_BST_E_UC_GRP_THRESHOLD_CHECK(_p)  ((_p)->ucBufferThreshold <= 0 || \
+                                                 (_p)->ucBufferThreshold > BVIEW_BST_UCAST_QUEUE_GROUP_DEFAULT)
+
+/* Check the validy of configuration for Egress Unicast Queue Entries */
+#define BVIEW_BST_E_UC_THRESHOLD_CHECK(_p)  ((_p)->ucBufferThreshold <= 0 || \
+                                             (_p)->ucBufferThreshold > BVIEW_BST_UCAST_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Egress Port Service Pools UC Statistics */
+#define BVIEW_BST_EPSP_UC_THRESHOLD_CHECK(_p)  ((_p)->ucShareThreshold <= 0 || \
+                                                (_p)->ucShareThreshold > BVIEW_BST_E_P_SP_UC_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Egress Service Pools UC+MC Statistics */
+#define BVIEW_BST_EPSP_UM_THRESHOLD_CHECK(_p)  ((_p)->umShareThreshold <= 0 || \
+                                                (_p)->umShareThreshold > BVIEW_BST_E_P_SP_UCMC_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Egress Service Pools MC Statistics */
+#define BVIEW_BST_EPSP_MC_THRESHOLD_CHECK(_p)  ((_p)->mcShareThreshold <= 0 || \
+                                                (_p)->mcShareThreshold > (0x1FFFF * 208))
+
+/* Check the validy of threshold configuration for Egress Service Pools UC+MC Statistics */
+#define BVIEW_BST_EPSP_MC_SQ_THRESHOLD_CHECK(_p)  ((_p)->mcShareQueueEntriesThreshold <= 0 || \
+                                                (_p)->mcShareQueueEntriesThreshold > (0x1FFFF * 208))
+
+/* Check the validy of threshold configuration for Ingress Service Pools MC+UC Statistics */
+#define BVIEW_BST_IPSP_THRESHOLD_CHECK(_p)  ((_p)->umShareThreshold <= 0 || \
+                                             (_p)->umShareThreshold > BVIEW_BST_I_SP_UCMC_SHARED_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Ingress Priority Group MC+UC Statistics */
+#define BVIEW_BST_IPPG_SHRD_THRESHOLD_CHECK(_p)  ((_p)->umShareThreshold <= 0 || \
+                                                  (_p)->umShareThreshold > BVIEW_BST_I_P_SP_UCMC_SHARED_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Ingress Priority Group Headroom Statistics */
+#define BVIEW_BST_IPPG_HDRM_THRESHOLD_CHECK(_p)  ((_p)->umHeadroomThreshold <= 0 || \
+                                                  (_p)->umHeadroomThreshold > BVIEW_BST_I_P_PG_UCMC_HDRM_THRES_DEFAULT)
+
+
+/* Check the validy of threshold configuration for Device level Statistics*/ 
+#define BVIEW_BST_DEVICE_THRESHOLD_CHECK(_p)      ((_p)->threshold <= 0 || \
+                                                   (_p)->threshold > BVIEW_BST_DEVICE_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Ingress Serivce Pool*/
+#define BVIEW_BST_ISP_THRESHOLD_CHECK(_p)         ((_p)->umShareThreshold <=0 || \
+                                                   (_p)->umShareThreshold > (0x1FFFF * 208))
+
+/* Check the validy of threshold configuration for Egress Service Pools UC + MCStatistics */
+#define BVIEW_BST_E_SP_UM_THRESHOLD_CHECK(_p)  ((_p)->umShareThreshold <= 0 || \
+                                               (_p)->umShareThreshold > BVIEW_BST_E_SP_UCMC_THRES_DEFAULT)
+
+
+/* Check the validy of threshold configuration for Egress Service Pools MC Statistics */
+#define BVIEW_BST_E_SP_MC_THRESHOLD_CHECK(_p)  ((_p)->mcShareThreshold <= 0 || \
+                                                (_p)->mcShareThreshold > BVIEW_BST_E_SP_MC_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for Egress Service Pools MC in Queue Entries */
+#define BVIEW_BST_E_SP_MC_SQ_THRESHOLD_CHECK(_p)  ((_p)->mcShareQueueEntriesThreshold <= 0 || \
+                                                (_p)->mcShareQueueEntriesThreshold > (0x1FFFF * 208))
+
+
+
+/* Check the validy of threshold configuration for Egress RQE Queues in units of buffers */
+#define BVIEW_BST_E_RQE_THRESHOLD_CHECK(_p)        ((_p)->rqeBufferThreshold <= 0 || \
+                                                    (_p)->rqeBufferThreshold > BVIEW_BST_E_RQE_THRES_DEFAULT)
+
+/* Check the validy of threshold configuration for RQE Queues in units of queue Entries*/
+#define BVIEW_BST_E_RQE_QUEUE_THRESHOLD_CHECK(_p)  ((_p)->rqeQueueThreshold <= 0 || \
+                                                    (_p)->rqeQueueThreshold > (0xFFF * 208))
+
+/* Check the validy of threshold configuration for mc egress Queues  grp in units of queue Entries*/
+#define BVIEW_BST_E_MC_QG_THRESHOLD_CHECK(_p)  ((_p)->mcThreshold <= 0 || \
+                                                    (_p)->mcThreshold > (0x1FFFF * 208))
+
+/* Check the validy of threshold configuration for mc shared egress Queues  grp in units of queue Entries*/
+#define BVIEW_BST_E_MC_SQG_THRESHOLD_CHECK(_p)  ((_p)->mcQueueEntriesThreshold <= 0 || \
+                                                    (_p)->mcQueueEntriesThreshold > (0x1FFFF * 208))
+
+
+/* Check the validy of threshold configuration for Egress CPU Queues Statistics */
+#define BVIEW_BST_EGRESS_CPU_THRESHOLD_CHECK(_p)  ((_p)->cpuThreshold <= 0 || \
+                                              (_p)->cpuThreshold > (0x1FFFF * 208))
+
+
+/* Check the validy of threshold configuration for Egress RQE Queues Statistics */
+#define BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_CHECK(_p)  ((_p)->rqeThreshold <= 0 || \
+                                              (_p)->rqeThreshold > (0x1FFFF * 208))
+
+
+/* Check the validy of threshold configuration for Egress RQE Queues Statistics */
+#define BVIEW_BST_EGRESS_UC_THRESHOLD_CHECK(_p)  ((_p)->ucThreshold <= 0 || \
+                                              (_p)->ucThreshold > (0x1FFFF * 208))
+
+/*****************************************************************//**
+* @brief : function to creathe the bst application thread.
+*
+* @param[in]  none 
+*
+* @retval  : BVIEW_STATUS_RESOURCE_NOT_AVAILABLE : Returns when memory is not available
+* @retval  : BVIEW_STATUS_FAILURE : failed to create the message queue or thread. 
+* @retval  : BVIEW_STATUS_SUCCESS : successful completion of task creation. 
+*
+* @note : Main function to invoke the bst thread. This function allocates the required memory 
+*         for bst application. Creates the mutexes for the bst data. Creates the message queue
+*         It assumes that the system is initialized before the bst thread is invoked. This api
+*        depends on the system variables such as number of units per device. Incase of no such 
+*        need, the number of units can be #defined.
+*
+*********************************************************************/
+BVIEW_STATUS bst_main ();
+
+/*****************************************************************//**
+*  @brief:  function to clean up  bst application  
+*
+* @param[in]  none 
+*
+* @retval  : none
+*
+* @note  When in case of any error event, this api cleans up all the resources.
+*         i.e it deletes the timer notes, if any are present.
+*         destroy the mutexes. clears the memory and destroys the message queue.
+*
+*********************************************************************/
+void bst_app_uninit();
+
+/*****************************************************************//**
+* @brief : bst main application function which does processing of messages
+*
+* @param[in] : none
+*
+* @retval  : BVIEW_STATUS_SUCCESS: Fails to register with module manager 
+*             or some error happened due to which the bst application is
+*             unable to process incoming messages.
+*
+*********************************************************************/
+BVIEW_STATUS bst_app_main(void);
+
+/*****************************************************************//**
+* @brief : function to initializes bst structures to default values 
+*
+* @param[in] : number of units on the agent
+*
+* @retval  : BVIEW_STATUS_SUCCESS : configuration is successfully initialized.
+* @retval  : BVIEW_STATUS_FAILURE : Fail to initialize the BST appliation to default.
+*
+* @note  : Initialization functon to make sure both software and asic are configured with
+*          same default values. We are not setting the default values for threshold, but 
+*         we are using the same as that of asic.
+*
+*********************************************************************/
+BVIEW_STATUS bst_app_config_init(unsigned int num_units);
+
+       
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_BST_H */
+
+/*!  @}
+ * @}
+ */
diff --git a/src/public/json.h b/src/public/json.h
new file mode 100755
index 0000000..67eb8c9
--- /dev/null
+++ b/src/public/json.h
@@ -0,0 +1,167 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_JSON_H
+#define INCLUDE_JSON_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "sbplugin_redirect_system.h"
+
+#define JSON_MAX_NODE_LENGTH   64 
+
+#define _jsonlog(format,args...)              printf(format, ##args)  
+
+#define JSON_VALIDATE_POINTER(x,y,z)  do { \
+    if ((x) == NULL) { \
+    _jsonlog("Invalid (NULL) value for parameter %s ", (y) ); \
+    return (z); \
+    } \
+} while(0)
+
+#define JSON_VALIDATE_JSON_POINTER(x,y,z) do { \
+    if ((x) == NULL) { \
+    _jsonlog("Error parsing JSON %s ", (y) ); \
+    return (z); \
+    } \
+}while(0) 
+
+#define JSON_VALIDATE_POINTER_AND_CLEANUP(x,y,z)  do { \
+    if ((x) == NULL) { \
+    _jsonlog("Invalid (NULL) value for parameter %s ", (y) ); \
+    if (root != NULL) { \
+    cJSON_Delete(root); \
+    } \
+    return (z); \
+    } \
+} while(0)
+
+#define JSON_VALIDATE_JSON_POINTER_AND_CLEANUP(x,y,z)  do { \
+    if ((x) == NULL) { \
+    _jsonlog("Error parsing JSON %s ", (y) ); \
+    if (root != NULL) { \
+    cJSON_Delete(root); \
+    } \
+    return (z); \
+    } \
+}while(0)
+
+#define JSON_VALIDATE_JSON_AS_STRING(x,y,z)  do { \
+    if ((x)->type != cJSON_String) { \
+    _jsonlog("Error parsing JSON, %s not a string ", (y) ); \
+    if (root != NULL)  { \
+    cJSON_Delete(root); \
+    } \
+    return (z); \
+    } \
+    if((x)->valuestring == NULL) { \
+    _jsonlog("Error parsing JSON, %s not a valid string ", (y) ); \
+    if (root != NULL) { \
+    cJSON_Delete(root); \
+    } \
+    return (z); \
+    } \
+}while(0)
+
+#define JSON_VALIDATE_JSON_AS_NUMBER(x,y)   do { \
+    if ((x)->type != cJSON_Number) { \
+    _jsonlog("Error parsing JSON, %s not a integer ", (y) ); \
+    if (root != NULL)  { \
+    cJSON_Delete(root); \
+    } \
+    return (BVIEW_STATUS_INVALID_JSON); \
+    } \
+}while(0)
+
+#define JSON_COMPARE_STRINGS_AND_CLEANUP(x,y,z)  do { \
+    if (strcmp((y), (z)) != 0) { \
+    _jsonlog("The JSON contains invalid value for %s (actual %s, required %s) ", (x), (y), (z) ); \
+    if (root != NULL) { \
+    cJSON_Delete(root); \
+    } \
+    return (BVIEW_STATUS_INVALID_JSON); \
+    } \
+}while(0)
+
+#define JSON_COMPARE_VALUE_AND_CLEANUP(x,y,z)  do { \
+    if ((y) != (z)) { \
+    _jsonlog("The JSON contains invalid value for %s (actual %d, required %d) ", (x), (y), (z) ); \
+    if (root != NULL) { \
+    cJSON_Delete(root); \
+    } \
+    return (BVIEW_STATUS_INVALID_JSON); \
+    } \
+}while(0)
+
+#define JSON_CHECK_VALUE_AND_CLEANUP(x,y,z)  do { \
+    if ( ((x) < (y)) || ( (x) > (z)) ) { \
+    _jsonlog("The JSON number out of range %d (min %d, max %d) ", (x), (y), (z) ); \
+    if (root != NULL) { \
+    cJSON_Delete(root); \
+    } \
+    return (BVIEW_STATUS_INVALID_JSON); \
+    } \
+}while(0)
+
+#define JSON_ASIC_ID_MAP_FROM_NOTATION(_aId, _asicStr) do { \
+    int _asicId = 0; \
+    BVIEW_STATUS rv = sbapi_system_asic_translate_from_notation( (_asicStr), &_asicId); \
+    if (rv != BVIEW_STATUS_SUCCESS) { \
+            _jsonlog("The JSON string can't be converted to asicId %s ", (_asicStr)); \
+            return BVIEW_STATUS_INVALID_JSON; \
+    } \
+    (_aId) = _asicId; \
+    } while(0)
+    
+#define JSON_PORT_MAP_FROM_NOTATION(_port, _portStr) do { \
+    int _pId = 0; \
+    BVIEW_STATUS rv = sbapi_system_port_translate_from_notation( (_portStr), &_pId); \
+    if (rv != BVIEW_STATUS_SUCCESS) { \
+            _jsonlog("The JSON string can't be converted to Port# %s ", (_portStr)); \
+            return BVIEW_STATUS_INVALID_JSON; \
+    } \
+    (_port) = _pId; \
+    } while(0)
+        
+
+#define JSON_ASIC_ID_MAP_TO_NOTATION(_aId, _asicStr) do { \
+    BVIEW_STATUS rv = sbapi_system_asic_translate_to_notation( (_aId), (_asicStr)); \
+    if (rv != BVIEW_STATUS_SUCCESS) { \
+            _jsonlog("The asicId can't be converted to external notation %d ", (_aId)); \
+            return BVIEW_STATUS_INVALID_JSON; \
+    } \
+    } while(0)
+    
+#define JSON_PORT_MAP_TO_NOTATION(_port, _asic, _portStr) do { \
+    BVIEW_STATUS rv = sbapi_system_port_translate_to_notation((_asic), (int)(_port), (_portStr)); \
+    if (rv != BVIEW_STATUS_SUCCESS) { \
+            _jsonlog("The port can't be converted to external notation %d ", (int)(_port)); \
+            return BVIEW_STATUS_INVALID_JSON; \
+    } \
+    } while(0)
+    
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_JSON_H */
+
diff --git a/src/public/modulemgr.h b/src/public/modulemgr.h
new file mode 100755
index 0000000..cfdb7f5
--- /dev/null
+++ b/src/public/modulemgr.h
@@ -0,0 +1,110 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_MODULEMGR_H
+#define INCLUDE_MODULEMGR_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "openapps_feature.h"
+
+#define  BVIEW_MAX_MODULES        BVIEW_MAX_FEATURES
+
+    /* Each feature modules information */
+    typedef struct _module_feature_info_ {
+        BVIEW_FEATURE_ID               featureId;   
+        BVIEW_REST_API_t               restApiList[BVIEW_MAX_API_CMDS_PER_FEATURE];
+    } BVIEW_MODULE_FETAURE_INFO_t;
+
+
+/*********************************************************************
+* @brief       Initialize module manager data with default values
+*
+*
+* @retval   BVIEW_STATUS_FAILURE   if failed to initialize read-write lock
+* @retval   BVIEW_STATUS_SUCCESS   if data is successfully initialized 
+*                                   to defaults
+*
+*
+* @note    none
+*
+*********************************************************************/
+BVIEW_STATUS modulemgr_init();
+
+/*********************************************************************
+* @brief       Register a feature with Module manager, all the modules
+*              such as BSt and packet trace need to register api handlers
+*              with module manager. 
+*
+* @param[in]  featureInfo        Feature information
+*
+* @retval   BVIEW_STATUS_FAILURE     If failed to acquire lock
+*
+* @retval   BVIEW_STATUS_TABLE_FULL  BVIEW_MAX_MODULES number of modules 
+*                                    already registered   
+*
+* @retval   BVIEW_STATUS_DUPLICATE   If a module is already registered 
+*                                    with same feature ID
+*
+* @retval   BVIEW_STATUS_SUCCESS     Upon registering successfully with 
+*                                    Module Manager
+*
+*
+* @note    none
+*
+*********************************************************************/
+BVIEW_STATUS modulemgr_register(BVIEW_MODULE_FETAURE_INFO_t * featureInfoPtr);
+
+
+/*********************************************************************
+* @brief     When a REST API is received, the web server thread obtains 
+*            the associated handler using this API 
+*
+* @param[in]  jsonBuffer       Json Buffer  
+* @param[in]  bufLength        Length of the Buffer
+* @param[out]  handler         Function handler     
+*
+* @retval   BVIEW_STATUS_FAILURE     Unable to find function handler
+*                                     for the api string in Json buffer
+* @retval   BVIEW_STATUS_SUCCESS     Function handler is found
+*                                     for the api string in Json buffer
+*
+* @retval   BVIEW_STATUS_INVALID_JSON    JSON is malformatted, or doesn't
+*                                         have necessary data.
+* @retval   BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter
+*
+* @note    none
+*
+*********************************************************************/
+BVIEW_STATUS modulemgr_rest_api_handler_get(char * jsonBuffer, 
+                                            int bufLength, 
+                                            BVIEW_REST_API_HANDLER_t *handler);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_MODULEMGR_H */
diff --git a/src/public/openapps_feature.h b/src/public/openapps_feature.h
new file mode 100755
index 0000000..be3e64f
--- /dev/null
+++ b/src/public/openapps_feature.h
@@ -0,0 +1,63 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_OPENAPPS_FEATURE_H
+#define	INCLUDE_OPENAPPS_FEATURE_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+
+    /** List of Instrumentation features */
+
+    typedef enum _bview_feature_id_
+    {
+        /** enum to represent system feature */
+        BVIEW_FEATURE_SYSTEM = (0x1 << 0),
+        /** enum to represent BST feature */
+        BVIEW_FEATURE_BST = (0x1 << 1),
+        /** enum to represent Packet Trace feature */
+        BVIEW_FEATURE_PACKET_TRACE = (0x1 << 2)
+    } BVIEW_FEATURE_ID;
+
+    /** the web server invokes the handler associated with the incoming REST API  *
+      * the incoming API is containing in the jsonBuffer.                         *
+      * The cookie is used by the web server to hold any context associated with   *
+      * the request. It is passed back the handler when some data needs to be sent back */
+    typedef BVIEW_STATUS(*BVIEW_REST_API_HANDLER_t) (void *cookie,
+        char *jsonBuffer,
+        int bufLength);
+
+    /** Definition of an REST API */
+    typedef struct _feature_rest_api_ 
+    {
+        /** Api string in the Json buffer */  
+        char *apiString;
+        /** Handler associated with the corresponding api string */ 
+        BVIEW_REST_API_HANDLER_t    handler;
+    }BVIEW_REST_API_t;
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_OPENAPPS_FEATURE_H */
+
diff --git a/src/public/openapps_log_api.h b/src/public/openapps_log_api.h
new file mode 100755
index 0000000..866c07b
--- /dev/null
+++ b/src/public/openapps_log_api.h
@@ -0,0 +1,98 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_LOG_H
+#define INCLUDE_LOG_H
+
+#include "broadview.h"
+
+#define RSYSLOG_CFG_FILENAME      "/etc/rsyslog.conf"
+#define SYSLOG_CFG_FILENAME       "/etc/syslog.conf"
+#define MAX_STRING_LENGTH         128
+#define MAX_FILE_SIZE             (1024*1024)
+#define TIME_FORMAT               "%Y-%m-%d %H:%M:%S "
+#define LOG_FILE                  "/var/log/agent_log_latest"
+#define BACKUP_LOG_FILE           "/var/log/agent_log_latest.bkp"
+#define LOG_PATH                  "/var/log"
+
+/**Severity levels used to post logs*/
+typedef enum
+{
+  BVIEW_LOG_EMERGENCY = 0,/* system is unusable */ 
+  BVIEW_LOG_ALERT,        /* action must be taken immediately */ 
+  BVIEW_LOG_CRITICAL,     /* critical conditions */ 
+  BVIEW_LOG_ERROR,        /* error conditions */ 
+  BVIEW_LOG_WARNING,      /* warning conditions */ 
+  BVIEW_LOG_NOTICE,       /* normal but significant condition */ 
+  BVIEW_LOG_INFO,         /* informational */ 
+  BVIEW_LOG_DEBUG         /* debug-level messages */
+} BVIEW_SEVERITY; 
+
+/*********************************************************************
+* @brief        Function used to post log
+*
+*
+* @param[in]    severity severety of the log (SYSLOG severity)
+* @param[in]    format string with arguments to be stored in log
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+extern void log_post(BVIEW_SEVERITY severity, char * format, ...);
+/** Default Msg Log Macro for all logs  */
+/** Log with a format string and variable arguments */
+
+#define LOG_POST(__sev__,__fmt__,__args__...)                         \
+          log_post(__sev__, (char *)__fmt__, ## __args__)
+
+/*********************************************************************
+* @brief        Initialize logging module
+*
+*
+* @param[in]    NA
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+void logging_init();
+
+/*********************************************************************
+* @brief        Deinitialize logging module
+*
+*
+* @param[in]    NA
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+void logging_deinit();
+
+#endif /* INCLUDE_LOG_H */
+
diff --git a/src/public/packet_trace.h b/src/public/packet_trace.h
new file mode 100755
index 0000000..1462e7f
--- /dev/null
+++ b/src/public/packet_trace.h
@@ -0,0 +1,331 @@
+/*! \file packet_trace.h
+ */
+
+/*! @addtogroup GLUSMDB API Definitions
+ *  @{
+ *    @addtogroup GLBVIEWPT BroadView Packet Trace Feature Declarations And Definitions [BVIEW]
+ *    @{
+ */
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_PACKET_TRACE_H
+#define INCLUDE_PACKET_TRACE_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "sbplugin.h"
+
+#define     BVIEW_PT_MAX_PACKET_SIZE                1558 
+
+/* Packet Including Checksum*/
+typedef struct
+{
+  unsigned char     data[BVIEW_PT_MAX_PACKET_SIZE];
+  unsigned int      pkt_len;
+} BVIEW_PT_PACKET_t;
+
+
+/* Drop Reason Types*/
+typedef enum _pt_drop_reason_type_
+{
+   BVIEW_PT_VLAN_XLATE_MISS_DROP,
+   BVIEW_PT_BPDU_DROP,
+   BVIEW_PT_PROTOCOL_PKT_DROP,
+   BVIEW_PT_CML_DROP,
+   BVIEW_PT_SRC_ROUTE_DROP,
+   BVIEW_PT_L2_SRC_DISCARD_DROP,
+   BVIEW_PT_L2SRC_STATIC_MOVE_DROP,
+   BVIEW_PT_L2DST_DISCARD_DROP,
+   BVIEW_PT_CFI_OR_L3DISABLE_DROP,
+   BVIEW_PT_HIGIG_MH_TYPE1_DROP,
+   BVIEW_PT_DISC_STAGE_DROP,
+   BVIEW_PT_SW1_INVALID_VLAN_DROP,
+   BVIEW_PT_HIGIG_HDR_ERROR_DROP,
+   BVIEW_PT_LAG_FAILOVER_DROP,
+   BVIEW_PT_MACSA0_DROP,
+   BVIEW_PT_VFP_DROP,
+   BVIEW_PT_VLAN_CC_OR_PBT_DROP,
+   BVIEW_PT_CLASS_BASED_SM_DROP,
+   BVIEW_PT_MPLS_STAGE_DROP,
+   BVIEW_PT_TIME_SYNC_PKT_DROP,
+   BVIEW_PT_MY_STATION_DROP,
+   BVIEW_PT_BAD_UDP_CHECKSUM_DROP,
+   BVIEW_PT_NIV_FORWARDING_DROP,
+   BVIEW_PT_NIV_RPF_CHECK_FAIL_DROP,
+   BVIEW_PT_PVLAN_VP_EFILTER_DROP,
+   BVIEW_PT_TRILL_HEADER_VERSION_NONZERO_DROP,
+   BVIEW_PT_TRILL_ADJACENCY_CHECK_FAIL_DROP,
+   BVIEW_PT_TRILL_RBRIDGE_LOOKUP_MISS_DROP,
+   BVIEW_PT_TRILL_UC_HDR_MC_MACDA_DROP,
+   BVIEW_PT_TRILL_SLOWPATH_DROP,
+   BVIEW_PT_CORE_IS_IS_PKT_DROP,
+   BVIEW_PT_TRILL_RPF_CHECK_FAIL_DROP,
+   BVIEW_PT_TRILL_PKT_WITH_SNAP_ENCAP_DROP,
+   BVIEW_PT_TRILL_ING_RBRIDGE_EQ_EGR_RBRIDGE_DROP,
+   BVIEW_PT_TRILL_HOPCOUNT_CHECK_FAIL_DROP,
+   BVIEW_PT_BFD_TERMINATED_DROP,
+   BVIEW_PT_L3DST_DISCARD_DROP,
+   BVIEW_PT_TUNNEL_DECAP_ECN_DROP,
+   BVIEW_PT_L3_PKT_RESOURCE_DROP,
+   BVIEW_PT_IPV4_HEADER_ERROR_DROP,
+   BVIEW_PT_L3_IPV6_PKT_RESOURCE_DROP,
+   BVIEW_PT_IPV6_HEADER_ERROR_DROP,
+   BVIEW_PT_INGRESS_PORT_FWD_STATE_DROP,
+   BVIEW_PT_FIELD_PROCESSOR_DROP,
+   BVIEW_PT_MULTICAST_DROP,
+   BVIEW_PT_BITMAP_ZERO_DROP,
+   BVIEW_PT_POLICY_DROP,
+   BVIEW_PT_DOS_L4_HEADER_ERROR_DROP,
+   BVIEW_PT_MTU_ERROR_DROP,
+   BVIEW_PT_RECV_TUNNELED_PKT_ERROR_DROP,
+   BVIEW_PT_VLAN_ERROR_DROP,
+   BVIEW_PT_HIGIG_HEADER_ERROR_DROP,
+   BVIEW_PT_MC_IPMC_INDEX_ERROR_DROP,
+   BVIEW_PT_PARITY_ERROR_DROP,
+   BVIEW_PT_REVERSE_RPF_ERROR_DROP,
+   BVIEW_PT_DST_DISCARD_BIT_ERROR_DROP,
+   BVIEW_PT_ECMP_CALCULATION_ERROR_DROP,
+   BVIEW_PT_MPLS_SEQ_NUM_ERROR_DROP,
+   BVIEW_PT_FIELD_PROCESSOR_REDIRECT_ERROR_DROP,
+   BVIEW_PT_INVALID_L2MC_ENTRY_DROP,
+   BVIEW_PT_NEXTHOP_ZERO_DROP,
+   /* This should be last always*/
+   BVIEW_PT_MAX_DROP_REASON
+} BVIEW_PT_DROP_REASON_TYPE_t;
+
+/*Drop Counters report*/
+typedef struct _pt_drop_counter_report_
+{
+  struct _counter_
+  {
+      uint64_t  counter;
+  } data[BVIEW_PT_MAX_DROP_REASON][BVIEW_ASIC_MAX_PORTS];
+
+} BVIEW_PT_DROP_COUNTER_REPORT_t;
+
+
+/* Callback Data when packet is droped with configured drop reason*/ 
+typedef struct _pt_drop_reason_data_
+{
+   BVIEW_PT_DROP_REASON_TYPE_t dropReason;
+   int                         port;
+   BVIEW_PT_PACKET_t           packet; 
+} BVIEW_PT_DROP_REASON_DATA_t;
+
+/* The callback for invoking when a packet is droped */
+typedef BVIEW_STATUS(*BVIEW_PT_TRIGGER_CALLBACK_t) (int asic,
+        void *cookie,
+        BVIEW_PT_DROP_REASON_DATA_t dropReasonData);
+
+/* Base type for declarations */
+#define     BVIEW_MASK_BASE_UNIT     unsigned int
+#define     BVIEW_MASKWID            (8*sizeof(BVIEW_MASK_BASE_UNIT)) 
+
+/* (internal) Number of BVIEW_MASK_BASE_UNITs needed to contain _max bits */
+#define     BVIEW_MASK_SIZE(_max)    (((_max) + BVIEW_MASKWID - 1) / BVIEW_MASKWID)
+
+/* Interface storage */
+typedef struct
+{
+  BVIEW_MASK_BASE_UNIT   value[BVIEW_MASK_SIZE(BVIEW_ASIC_MAX_PORTS)];
+} BVIEW_PORT_MASK_t;
+
+
+typedef struct
+{
+  BVIEW_MASK_BASE_UNIT   value[BVIEW_MASK_SIZE(BVIEW_PT_MAX_DROP_REASON)];
+} BVIEW_PT_DROP_REASON_MASK_t;
+
+/* Drop Reason Configuration*/
+typedef struct _pt_drop_reason_config_
+{
+    /* Mask of Drop Reasons */
+    BVIEW_PT_DROP_REASON_MASK_t dropReasonMask;
+    /* Port Bitmap */
+    BVIEW_PORT_MASK_t  pbmp;
+    /* Determines whether the send copy of the dropped packets or not.*/
+    bool          sendDropedPacket;
+    /* Determines whether a trace-profile be sent for each dropped packet. */
+    bool          traceProfile;
+    /* Number of packets (default 1) to be sent for a given drop reason.*/
+    int           packetCount;
+    /* A minimum number of packets to be dropped,
+     * exceeding which the dropped packet will be sent to the requestor.*/
+    int           packetThreshold;
+
+} BVIEW_PT_DROP_REASON_CONFIG_t;
+
+
+
+typedef enum _bview_pt_hashing_info_mask_
+{
+  BVIEW_PT_NO_HASHING_RESOLUTION,
+  /* level 1 ecmp hashing resolution done */
+  BVIEW_PT_ECMP_1_RESOLUTION,
+  /* level 2 ecmp hashing resolution done */
+  BVIEW_PT_ECMP_2_RESOLUTION,
+  /* trunk hashing resolution done*/
+  BVIEW_PT_TRUNK_RESOLUTION,
+  /* hg trunk hashing resolution done*/
+  BVIEW_PT_FABRIC_TRUNK_RESOLUTION
+} BVIEW_PT_HASHING_INFO_MASK_t; 
+
+
+#define     BVIEW_MAX_TRUNK_MEMBERS         8
+typedef struct _bview_pt_lag_hashing_info_
+{
+   int trunk;                         /* destination trunk group */
+   int trunk_member;                  /* destination member port which packet egress. */
+   int trunk_members[BVIEW_MAX_TRUNK_MEMBERS];            /* Port Bitmap of trunk members*/
+   int fabric_trunk;                  /* destination hg trunk group */
+   int fabric_trunk_member;           /* destination member hg port which packet will egress. */
+   int fabric_trunk_members[BVIEW_MAX_TRUNK_MEMBERS];     /* Port Bitmap of trunk members*/
+} BVIEW_PT_LAG_HASHING_INFO_t;
+
+#define                  BVIEW_ECMP_MAX_MEMBERS       8
+
+typedef struct _bview_ecmp_member_info_
+{
+  int member;          /* member information */
+  int port;            /*  port */
+  int ip;              /*  IP */
+} BVIEW_ECMP_MEMBER_t; 
+
+typedef struct _bview_ecmp_lag_hashing_info_
+{
+  int ecmp_group;                  /* multipath egress forwarding object. */
+  BVIEW_ECMP_MEMBER_t ecmp_group_members[BVIEW_ECMP_MAX_MEMBERS];           
+  BVIEW_ECMP_MEMBER_t ecmp_egress_info;
+} BVIEW_PT_ECMP_HASHING_INFO_t;
+
+#define                  BVIEW_ECMP_MAX_LEVEL          2
+
+
+/* packet hashing resolution information */
+typedef struct _bview_pt_hashing_info_ 
+{
+    BVIEW_PT_HASHING_INFO_MASK_t flags;        
+    BVIEW_PT_LAG_HASHING_INFO_t  lag;
+    BVIEW_PT_ECMP_HASHING_INFO_t ecmp[BVIEW_ECMP_MAX_LEVEL];
+} BVIEW_PT_HASHING_INFO_t;
+
+
+/* packet trace resolution enums */
+typedef enum _pt_resolution_type_t
+{
+    BVIEW_PT_RESOLUTIONUNKOWN = 0,
+    BVIEW_PT_RESOLUTIONCONTROLPKT = 1, /* 1 */
+    BVIEW_PT_RESOLUTIONOAMPKT = 2,
+    BVIEW_PT_RESOLUTIONBFDPKT = 3,
+    BVIEW_PT_RESOLUTIONBPDUPKT = 4,
+    BVIEW_PT_RESOLUTION1588PKT = 6,
+    BVIEW_PT_RESOLUTIONKNOWNL2UCPKT = 8,
+    BVIEW_PT_RESOLUTIONUNKNOWNL2UCPKT = 9,
+    BVIEW_PT_RESOLUTIONKNOWNL2MCPKT = 10,
+    BVIEW_PT_RESOLUTIONUNKNOWNL2MCPKT = 11,
+    BVIEW_PT_RESOLUTIONL2BCPKT = 12,
+    BVIEW_PT_RESOLUTIONKNOWNL3UCPKT = 16,
+    BVIEW_PT_RESOLUTIONUNKNOWNL3UCPKT = 17,
+    BVIEW_PT_RESOLUTIONKNOWNIPMCPKT = 18,
+    BVIEW_PT_RESOLUTIONUNKNOWNIPMCPKT = 19,
+    BVIEW_PT_RESOLUTIONKNOWNMPLSL2PKT = 24,
+    BVIEW_PT_RESOLUTIONUNKNOWNMPLSPKT = 25,
+    BVIEW_PT_RESOLUTIONKNOWNMPLSL3PKT = 26,
+    BVIEW_PT_RESOLUTIONKNOWNMPLSPKT = 28,
+    BVIEW_PT_RESOLUTIONKNOWNMIMPKT = 32,
+    BVIEW_PT_RESOLUTIONUNKNOWNMIMPKT = 33,
+    BVIEW_PT_RESOLUTIONKNOWNTRILLPKT = 40,
+    BVIEW_PT_RESOLUTIONUNKNOWNTRILLPKT = 41,
+    BVIEW_PT_RESOLUTIONKNOWNNIVPKT = 48,
+    BVIEW_PT_RESOLUTIONUNKNOWNNIVPKT = 49,
+    BVIEW_PT_RESOLUTIONKNOWNL2GREPKT = 50,
+    BVIEW_PT_RESOLUTIONKNOWNVXLANPKT = 51,
+    BVIEW_PT_RESOLUTIONCOUNT = 52
+} BVIEW_PT_RESOULTION_t; 
+
+/* packet trace lookup result enums */
+typedef enum _pt_lookup_result_type_
+{
+    BVIEW_PT_LOOKUPINVALID = 0,
+    BVIEW_PT_LOOKUPFIRSTVLANTRANSLATIONHIT = 1,
+    BVIEW_PT_LOOKUPSECONDVLANTRANSLATIONHIT = 2,
+    BVIEW_PT_LOOKUPFORWARDINGVLANVALID = 3,
+    BVIEW_PT_LOOKUPL2SRCHIT = 6,
+    BVIEW_PT_LOOKUPL2SRCSTATIC = 7,
+    BVIEW_PT_LOOKUPL2DSTHIT = 8,
+    BVIEW_PT_LOOKUPL2CACHEHIT = 9,
+    BVIEW_PT_LOOKUPL3SRCHOSTHIT = 10,
+    BVIEW_PT_LOOKUPL3DESTHOSTHIT = 11,
+    BVIEW_PT_LOOKUPL3DESTROUTEHIT = 12,
+    BVIEW_PT_LOOKUPL2SRCMISS = 13,
+    BVIEW_PT_LOOKUPDOSATTACK = 14,
+    BVIEW_PT_LOOKUPIPTUNNELHIT = 15,
+    BVIEW_PT_LOOKUPMPLSLABEL1HIT = 16,
+    BVIEW_PT_LOOKUPMPLSLABEL2HIT = 17,
+    BVIEW_PT_LOOKUPMPLSTERMINATED = 18,
+    BVIEW_PT_LOOKUPMYSTATIONHIT = 19,
+    BVIEW_PT_LOOKUPCOUNT = 20
+} BVIEW_PT_LOOKUP_RESULT_TYPE_t;
+
+
+/* lookup result set bit map */
+typedef struct
+{
+  BVIEW_MASK_BASE_UNIT   value[BVIEW_MASK_SIZE(BVIEW_PT_LOOKUPCOUNT)]; /* bit map for packet trace lookup result set */
+} BVIEW_PT_LOOKUP_RESULT_MASK_t;
+
+
+typedef enum _stp_state_
+{
+  BVIEW_DISABLED =0,
+  BVIEW_FORWARDING,
+  BVIEW_DISCRADING,
+  BVIEW_LEARNING
+} BVIEW_PT_STP_STATE_t;
+  
+/* Trace Profile */
+typedef struct  _pt_trace_profile_
+{
+    /* port*/
+    int                        port;
+    /* Packet Including Checksum*/
+    BVIEW_PT_PACKET_t          packet;
+    /* packet trace lookup status */
+    BVIEW_PT_LOOKUP_RESULT_MASK_t   lookupResult;
+    /* packet trace resolution result */
+    BVIEW_PT_RESOULTION_t      packetResolution;
+    /* packet trace hashing information */
+    BVIEW_PT_HASHING_INFO_t    hashingInfo;
+    /* packet trace ingress stp state */
+    BVIEW_PT_STP_STATE_t       stpState;
+
+} BVIEW_PT_TRACE_PROFILE_t;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_PACKET_TRACE_H */
+
diff --git a/src/public/rest_api.h b/src/public/rest_api.h
new file mode 100755
index 0000000..a8cbee3
--- /dev/null
+++ b/src/public/rest_api.h
@@ -0,0 +1,57 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_REST_API_H
+#define	INCLUDE_REST_API_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+
+/* Initialize REST component */
+BVIEW_STATUS rest_init(void);
+
+/* API to send the response buffer back to client. 
+ * This function adds HTTP header and sends it to 
+ * client 
+ */
+BVIEW_STATUS rest_response_send(void *cookie, char *pBuf, int size);
+
+/* API to send the response buffer back to client. 
+ * This function adds HTTP header along with JSON error code and 
+ * sends it to client 
+ */
+
+BVIEW_STATUS rest_response_send_error(void *cookie, BVIEW_STATUS rv, int id);
+
+/* API to send the response buffer back to client. 
+ * This function adds HTTP header and sends it to 
+ * client. No JSON buffer is sent with this API.
+ */
+
+BVIEW_STATUS rest_response_send_ok (void *cookie);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_REST_API_H */
+
diff --git a/src/public/sb_redirector_api.h b/src/public/sb_redirector_api.h
new file mode 100755
index 0000000..bbef3f9
--- /dev/null
+++ b/src/public/sb_redirector_api.h
@@ -0,0 +1,75 @@
+/*! \file sb_redirector_api.h
+ */
+
+/*! @addtogroup GLUSMDB API Definitions
+ *  @{
+ *    @addtogroup GLBVIEW BroadView South Bound Plug-In Redirector APIs [BVIEW]
+ *    @{
+ */
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SB_REDIRECTOR_API_H
+#define	INCLUDE_SB_REDIRECTOR_API_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "sbplugin.h"
+
+/*****************************************************************//**
+* @brief       Initialize South bound redirector's local data with defaults
+*
+* @retval   BVIEW_STATUS_FAILURE   if failed to initialize read-write lock
+*
+* @retval   BVIEW_STATUS_SUCCESS   All the data structures are sucessfully 
+*                                  initialized
+*
+*********************************************************************/
+extern BVIEW_STATUS sb_redirector_init ();
+
+/*****************************************************************//**
+* @brief       Register a south bound plug-in with
+*                               south bound redirector
+*
+* @param[in]  sbPlugin        South bound plug-in
+*
+* @retval   BVIEW_STATUS_FAILURE   When validation of sb plug-in fails or
+*                                  Lock acquistion fails 
+*
+* @retval   BVIEW_STATUS_TABLE_FULL  Number of plug-ins already registered 
+*                                    are BVIEW_MAX_SUPPORTED_SB_PLUGINS.
+*
+* @retval   BVIEW_STATUS_SUCCESS    Successfully registered sb plug-in with 
+*                                    sb redirector
+*
+*********************************************************************/
+extern BVIEW_STATUS sb_plugin_register (BVIEW_SB_PLUGIN_t sbPlugin);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_SB_REDIRECTOR_API_H */
+
+/*!  @}
+ * @}
+ */
diff --git a/src/public/sbplugin_api.h b/src/public/sbplugin_api.h
new file mode 100755
index 0000000..8a7bfef
--- /dev/null
+++ b/src/public/sbplugin_api.h
@@ -0,0 +1,48 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_API_H
+#define	INCLUDE_SBPLUGIN_API_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "sbplugin.h"
+
+/*********************************************************************
+* @brief    South bound plugin init
+*
+* @retval   BVIEW_STATUS_SUCCESS if BST feature is
+*                                initialized successfully.
+* @retval   BVIEW_STATUS_FAILURE if initialization is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_common_init ();
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_SBPLUGIN_API_H */
+
diff --git a/src/public/sbplugin_redirect_bst.h b/src/public/sbplugin_redirect_bst.h
new file mode 100755
index 0000000..c04c47c
--- /dev/null
+++ b/src/public/sbplugin_redirect_bst.h
@@ -0,0 +1,696 @@
+/*! \file sbplugin_redirect_bst.h
+ */
+
+/*! @addtogroup GLUSMDB API Definitions
+ *  @{
+ *    @addtogroup GLBVIEWSBREDIRECTOR BroadView BST SB Redirector Feature Declarations And Definitions [BVIEW SB REDIRECTOR]
+ *    @{
+ */
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_REDIRECT_BST_H
+#define	INCLUDE_SBPLUGIN_REDIRECT_BST_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "openapps_feature.h"
+#include "bst.h"
+
+
+/*****************************************************************//**
+* @brief       Get BST configuration
+*
+* @param[in]    asic                  Unit number
+* @param[out]   config                BST config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST config get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST config get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_config_get(int asic, BVIEW_BST_CONFIG_t *config);
+
+/*****************************************************************//**
+* @brief       Set BST configuration
+*
+* @param[in]    asic                  Unit number
+* @param[in]    config                BST config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST config set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST config set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_config_set(int asic, BVIEW_BST_CONFIG_t *config);
+
+
+/*****************************************************************//**
+* @brief       Get BST snapshot
+*
+* @param[in]     asic                  Unit number
+* @param[out]    snapshot              BST snapshot
+* @param[out]    time                  Time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST snapshot get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST snapshot get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_snapshot_get(int asic, BVIEW_BST_ASIC_SNAPSHOT_DATA_t *snapshot, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Device Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             Device data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Device stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Device stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_device_data_get(int asic, BVIEW_BST_DEVICE_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Ingress Port + Priority Groups Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              i_p_pg data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Priority Groups 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Priority Groups 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_ippg_data_get(int asic, BVIEW_BST_INGRESS_PORT_PG_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Ingress Port + Service Pools Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             i_p_sp data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_ipsp_data_get(int asic, BVIEW_BST_INGRESS_PORT_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Ingress Service Pools Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              i_sp structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_isp_data_get(int asic, BVIEW_BST_INGRESS_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Egress Port + Service Pools Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              e_p_sp data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Port + Service Pools
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Port + Service Pools
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_epsp_data_get(int asic, BVIEW_BST_EGRESS_PORT_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Egress Service Pools Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              e_sp data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Service Pools
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Service Pools
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_esp_data_get(int asic, BVIEW_BST_EGRESS_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Egress Unicast Queues Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             Egress Unicast Queue data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queues
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queues
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_eucq_data_get(int asic, BVIEW_BST_EGRESS_UC_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Egress Unicast Queue Groups Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              Egress Unicast Queue Groups data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queue Groups
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queue Groups
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_eucqg_data_get(int asic, BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Egress Multicast Queues Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             Egress Multicast Queue data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Multicast Queues
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Multicast Queues
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_emcq_data_get(int asic, BVIEW_BST_EGRESS_MC_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Egress CPU Queues Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              Egress CPU Queue data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress CPU Queues
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress CPU Queues
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_cpuq_data_get(int asic, BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Obtain Egress RQE Queues Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              Egress RQE Queue data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress RQE Queues 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress RQE Queues 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_rqeq_data_get(int asic, BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+/*****************************************************************//**
+* @brief  Clear BST stats of a particular unit
+*           
+* @param[in]    asic            unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Successfully cleared BST stats 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Clear BST stats functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_bst_clear_stats(int asic);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Device Statistics
+*
+* @param[in]   asic                unit
+* @param[in]   thres               threshold
+* 
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Device Statistics 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Device Statistics 
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_device_threshold_set(int asic, BVIEW_BST_DEVICE_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for  
+*           Ingress Port + Priority Groups Statistics
+*
+* @param[in]   asic               unit
+* @param[in]   port               port
+* @param[in]   pg                 Priority Group
+* @param[out]  thres              Threshold structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Priority Groups 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Priority Groups
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_ippg_threshold_set(int asic, int port, int pg, BVIEW_BST_INGRESS_PORT_PG_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Ingress Port + Service Pools
+*           Statistics
+*
+* @param[in]  asic                                    unit
+* @param[in]  port                                    port
+* @param[in]  sp                                      service pool
+* @param[in]  thres                                   threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Service Pools 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_ipsp_threshold_set(int asic, int port, int sp, BVIEW_BST_INGRESS_PORT_SP_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Ingress Service Pools
+*           Statistics
+*
+* @param[in]  asic                               unit
+* @param[in]  sp                                 service pool
+* @param[in]  thres                              threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Service Pools 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_isp_threshold_set(int asic, int sp, BVIEW_BST_INGRESS_SP_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set Profile configuration for Egress Port + Service Pools
+*           Statistics
+*
+* @param[in]  asic                                  unit
+* @param[in]  port                                  port
+* @param[in]  sp                                    service pool
+* @param[in]  thres                                 threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Port + Service Pools
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Port + Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_epsp_threshold_set(int asic, int port, int sp, BVIEW_BST_EGRESS_PORT_SP_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Egress Service Pools Statistics
+*
+* @param[in]  asic                                unit
+* @param[in]  sp                                  service pool
+* @param[in]  thres                               threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Service Pools
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_esp_threshold_set(int asic, int sp, BVIEW_BST_EGRESS_SP_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Egress Unicast Queues
+*           Statistics
+*
+* @param[in]  asic                            unit
+* @param[in]  ucQueue                         uc queue
+* @param[in]  thres                           threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_eucq_threshold_set(int asic, int ucQueue, BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Egress Unicast Queue Groups
+*           Statistics
+*
+* @param[in] asic                                      unit
+* @param[in] ucQueueGrp                                uc queue group
+* @param[in] thres                                     threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queue Groups
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queue Groups
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_eucqg_threshold_set(int asic, int ucQueueGrp, BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Egress Multicast Queues
+*           Statistics
+*
+* @param[in]  asic                                   - unit
+* @param[in]  mcQueue                                - mcQueue
+* @param[in]  thres                                  - threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Multicast Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Multicast Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_emcq_threshold_set(int asic, int mcQueue, BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Egress CPU Queues
+*           Statistics
+*
+* @param[in]  asic                                    unit
+* @param[in]  cpuQueue                                cpuQueue
+* @param[in]  thres                                   threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress CPU Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress CPU Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_cpuq_threshold_set(int asic, int cpuQueue, BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Set profile configuration for Egress RQE Queues
+*           Statistics
+*
+* @param[in]     asic                    unit
+* @param[in]     rqeQueue                rqeQueue
+* @param[out]    thres                   Threshold data structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress RQE Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress RQE Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_rqeq_threshold_set(int asic, int rqeQueue, BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_t *threshold);
+
+/*****************************************************************//**
+* @brief  Get snapshot of all thresholds configured
+*
+* @param[in]   asic                          unit
+* @param[out]  thresholdSnapshot             threshold snapshot
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Snapshot get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Snapshot get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_threshold_get(int asic, BVIEW_BST_ASIC_SNAPSHOT_DATA_t *thresholdSnapshot,
+                                     BVIEW_TIME_t * time);
+
+/*****************************************************************//**
+* @brief  Restore threshold configuration to defaults
+*
+* @param[in] asic                        unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Resetting threshold to default is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Clear threshold functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_clear_thresholds(int asic);
+
+/*****************************************************************//**
+* @brief  Register hw trigger callback
+*
+* @param[in] asic                  unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Callback is successfully registered 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Trigger callback registration is not supported 
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_register_trigger(int asic, BVIEW_BST_TRIGGER_CALLBACK_t callback, void *cookie);
+
+/*********************************************************************
+* @brief       Get BST default buffer values 
+*
+* @param[in]     asic                  Unit number
+* @param[out]    snapshot              BST snapshot
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST snapshot get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST snapshot get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_default_snapshot_get (int asic,
+                                     BVIEW_BST_ASIC_SNAPSHOT_DATA_t * snapshot);
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_SBPLUGIN_REDIRECT_BST_H */
+
+/*!  @}
+ * @}
+ */
diff --git a/src/public/sbplugin_redirect_packet_trace.h b/src/public/sbplugin_redirect_packet_trace.h
new file mode 100755
index 0000000..6a1aae6
--- /dev/null
+++ b/src/public/sbplugin_redirect_packet_trace.h
@@ -0,0 +1,204 @@
+/*! \file sbplugin_redirect_packet_trace.h
+ */
+
+/*! @addtogroup GLUSMDB API Definitions
+ *  @{
+ *    @addtogroup GLBVIEWSBREDIRECTORPT BroadView Packet Trace SB Redirector Feature Declarations And Definitions [BVIEW SB REDIRECTOR]
+ *    @{
+ */
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+/*#include "sbplugin_redirect.h"*/
+#include "sbfeature_packet_trace.h"
+#include "sbplugin_redirect_system.h"
+
+/*********************************************************************//**
+* @brief       Get Packet Trace configuration
+*
+* @param[in]    asic                  Unit number
+* @param[out]   config                Packet Trace config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Packet Trace config get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Packet Trace config get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_drop_reason_config_get_cb (int asic, 
+                                BVIEW_PT_DROP_REASON_CONFIG_t * config);
+
+/*********************************************************************//**
+* @brief       Set Packet Trace configuration Paramters.
+*
+* @param[in]    asic                  Unit number
+* @param[in]    config                Packet Trace config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Packet Trace config set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Packet Trace config set functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_drop_reason_config_set (int asic, 
+                                 BVIEW_PT_DROP_REASON_CONFIG_t *config);
+
+/*********************************************************************//**
+* @brief  Get Mask of ASIC Configurable drop reasons.
+*
+* @param[in]    asic             unit
+* @param[out]   mask             Mask of drop reasons
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Device stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Device stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_asic_supported_drop_reason_get_cb (int asic,
+                                     BVIEW_PT_DROP_REASON_MASK_t *mask);
+
+/*********************************************************************//**
+* @brief  Obtain Trace Profile for a given packet.
+*
+* @param[in]    asic              unit
+* @param[out]   traceProfile      Trace Profile Data Struture             
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Priority Groups 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Priority Groups 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_trace_profile_get_cb (int asic,
+                                      int  port,
+                                      BVIEW_PT_PACKET_t *packet,
+                                      BVIEW_PT_TRACE_PROFILE_t *traceProfile,
+                                      BVIEW_TIME_t * time);
+
+/*********************************************************************//**
+* @brief  Obtain Drop Counter Report for all Drop Reasons.
+*
+* @param[in]    asic             unit
+* @param[out]   data             i_p_sp data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_drop_counter_get_cb (int asic,
+                                      BVIEW_PT_DROP_COUNTER_REPORT_t *data,
+                                      BVIEW_TIME_t * time);
+
+/*********************************************************************//**
+* @brief  Clear all configured Drop Reasons.
+*
+* @param[in]    asic              unit
+* @param[out]   data              i_sp structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_clear_drop_reason_cb (int asic);
+
+/*********************************************************************//**
+* @brief  Register hw trigger callback
+*
+*
+* @param[in] asic                  unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Callback is successfully registered 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Trigger callback registration is not supported 
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_register_trigger_cb (int asic,
+                                         BVIEW_PT_TRIGGER_CALLBACK_t callback,
+                                         void *cookie);
diff --git a/src/public/sbplugin_redirect_system.h b/src/public/sbplugin_redirect_system.h
new file mode 100755
index 0000000..f54f832
--- /dev/null
+++ b/src/public/sbplugin_redirect_system.h
@@ -0,0 +1,451 @@
+/*! \file sbplugin_redirect_system.h
+ */
+
+/*! @addtogroup GLUSMDB API Definitions
+ *  @{
+ *    @addtogroup GLBVIEW This File Contains System Feature Related South Bound APIs [BVIEW]
+ *    @{
+ */
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_REDIRECT_SYSTEM_H
+#define	INCLUDE_SBPLUGIN_REDIRECT_SYSTEM_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "openapps_feature.h"
+#include "system.h"
+#include "asic.h"
+
+
+/*****************************************************************//**
+* @brief       Get asic capabilites of a unit
+*
+* @param[in]   asic          Unit number
+* @param[out]  asicCapPtr    Pointer to asic capabilities  
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Found asic capabilities
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_capabilities_get (int asic, 
+                                          BVIEW_ASIC_CAPABILITIES_t *asicCapPtr);
+
+/*****************************************************************//**
+* @brief       Get number of units in the system
+*
+* @param[out]  unitNum            Numbers of units
+*
+* @retval   BVIEW_STATUS_FAILURE   When lock acquistion fails or
+*                                  System feature is not avaialable or
+*                                  The number of units is '0'
+*
+* @retval   BVIEW_STATUS_SUCCESS   Read number of units from system feature
+*                                  handler sucessfully
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_num_units_get(int *unitNum);
+
+/*****************************************************************//**
+* @brief       Get asic type of a  unit
+*
+* @param[in]  asic        Unit number
+* @param[out]  asicType    Asic type of unit
+*
+* @retval   BVIEW_STATUS_FAILURE   When lock acquistion fails or
+*                                  System feature is not avaialable or
+*                                  The number of units is '0' or 
+*                                  unit entry is not found
+*
+* @retval   BVIEW_STATUS_SUCCESS   Able to convert unit number to asic type
+*                                  sucessfully
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_unit_to_asic_type_get(int asic,  BVIEW_ASIC_TYPE  *asicType);
+
+/*****************************************************************//**
+* @brief       Get system name
+*
+* @param[out]  buffer        System name
+* @param[in]   length        Buffer length
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_name_get(char *buffer, int length);
+
+/*****************************************************************//**
+* @brief       Get system MAC address
+*
+* @param[out]  buffer        System MAC address
+* @param[in]   length        Buffer length
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for mac get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System mac get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_mac_get(uint8_t *buffer, int length);
+
+/*****************************************************************//**
+* @brief       Get system IPv4 address
+*
+* @param[out]  buffer        IPv4 address
+* @param[in]   length        Buffer length
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for ipv4 get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System  ipv4 get functionality is 
+*                                     not supported on this unit
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_ip4_get(uint8_t *buffer, int length);
+
+/*****************************************************************//**
+* @brief       Get system asic number from notational asic number
+*                                  representation - string form
+*
+* @param[in]   src           Asic number in notational(string) form
+* @param[out]  asic        System asic number 
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_translate_from_notation(char *src, int *asic);
+
+/*******************************************************************//**
+* @brief       Get asic number in notational representation(string) 
+*                from system asic number
+*
+* @param[in]  asic        System asic number 
+* @param[out] dst         Asic number in notational(string) form
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_translate_to_notation(int asic, char *dst);
+
+/*******************************************************************//**
+* @brief       Get system port number from notational port number
+*                                  representation - string form
+*
+* @param[in]   src         Port number in notational(string) form
+* @param[out]  port        System port number 
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_port_translate_from_notation(char *src, int *port);
+
+/*******************************************************************//**
+* @brief       Get port number in notational representation(string) 
+*                from system port number and asic number
+*
+* @param[in]  asic        System asic number 
+* @param[in]  port        System port number 
+* @param[out] dst         Port number in notational(string) form
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_port_translate_to_notation(int asic, int port, char *dst);
+
+  /* Acquire Read lock */
+/*******************************************************************//**
+* @brief       Get number of ports in a unit
+*
+* @param[in]   asic          Unit number
+* @param[out]  numPorts      Number of ports
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of ports is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_ports_get(int asic, int *numPorts);
+
+/*****************************************************************//**
+* @brief       Get number of unicast queues in a unit
+*
+* @param[in]   asic                  Unit number
+* @param[out]  numUnicastQueues      Number of Unicast queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of unicast queues is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_ucq_get(int asic, int *numUnicastQueues);
+
+/*****************************************************************//**
+* @brief       Get number of unicast queue groups in a unit
+*
+* @param[in]   asic                    Unit number
+* @param[out]  numUnicastQueueGroups   Number of Unicast queue groups
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of unicast queue groups 
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_ucqg_get(int asic, int *numUnicastQueueGroups);
+
+/*****************************************************************//**
+* @brief       Get number of multicast queues in a unit
+*
+* @param[in]   asic                    Unit number
+* @param[out]  numMulticastQueueGroups   Number of Multicast queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of multicast queues 
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_mcq_get(int asic, int *numMulticastQueues);
+
+/*****************************************************************//**
+* @brief       Get number of service pools in a unit
+*
+* @param[in]   asic                    Unit number
+* @param[out]  numServicePools         Number of Service pools
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of service pools 
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_sp_get(int asic, int *numServicePools);
+
+/*****************************************************************//**
+* @brief       Get number of common pools in a unit
+*
+* @param[in]   asic                  Unit number
+* @param[out]  numCommonPools        Number of common pools
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of common pools 
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_cp_get(int asic, int *numCommonPools);
+
+/*****************************************************************//**
+* @brief       Get number of cpu queues in a unit
+*
+* @param[in]   asic                Unit number
+* @param[out]  numCpuQueues        Number of cpu queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of cpu queues 
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_cpuq_get(int asic, int *numCpuQueues);
+
+/*****************************************************************//**
+* @brief       Get number of RQE queues in a unit
+*
+* @param[in]   asic                Unit number
+* @param[out]  numRqeQueues        Number of RQE queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of RQE queues 
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_rqeq_get(int asic, int *numRqeQueues);
+
+/*****************************************************************//**
+* @brief       Get number of RQE queue pools in a unit
+*
+* @param[in]   asic                Unit number
+* @param[out]  numRqeQueuePools    Number of RQE queue pools
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of RQE queue pools
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_rqeqp_get(int asic, int *numRqeQueuePools);
+
+/*****************************************************************//**
+* @brief       Get number of priority groups in a unit
+*
+* @param[in]   asic                 Unit number
+* @param[out]  numPriorityGroups    Number of priority groups
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of priority groups
+*                                     is successful
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_num_pg_get(int asic, int *numPriorityGroups);
+
+/*****************************************************************//**
+* @brief       Get whether a unit supports 1588 or not
+*
+* @param[in]   asic                 Unit number
+* @param[out]  support1588          Support for 1588
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Unit's capability for 1588 is successfully 
+*                                     queried
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_asic_support_1588_get(int asic, bool *support1588);
+
+/*********************************************************************
+* @brief       Get Supported Feature Mask
+*
+* @param[out]  featureMask            Supported Feature Mask
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Supported Feature Mask is successfully
+*                                     queried
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_feature_mask_get (int *featureMask);
+
+/*********************************************************************
+* @brief       Get Network OS
+*
+* @param[out]  buffer                 Pointer to network OS String
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure 
+*                                     Failed to get network os
+*
+* @retval   BVIEW_STATUS_SUCCESS      Network OS is successfully
+*                                     queried
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_network_os_get (uint8_t *buffer, int length);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_SBPLUGIN_REDIRECT_SYSTEM_H */
+
+/*!  @}
+ * @}
+ */
diff --git a/src/public/system.h b/src/public/system.h
new file mode 100755
index 0000000..7bbaf87
--- /dev/null
+++ b/src/public/system.h
@@ -0,0 +1,140 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SYSTEM_H
+#define INCLUDE_SYSTEM_H
+
+#include "broadview.h"
+
+
+/**Timer mode Periodic or Non Periodic*/
+
+#define BVIEW_TIME_CONVERSION_FACTOR 1000
+typedef enum
+{
+  PERIODIC_MODE = 0,
+  NON_PERIODIC_MODE = 1,
+}TIMER_MODE;
+
+/*********************************************************************
+* @brief        Function used to initialize various system components
+*               such as openapps driver and calls phase-2 init
+*
+* @param[in]    debug     debug mode of openapps driver
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+void bview_system_init_ph1(bool debug, bool menu);
+
+/*********************************************************************
+* @brief        Function used to initialize various system components
+*               such as module manager, redirector, agent and sbplugins
+*
+* @param[in]    NA
+*
+* @retval       NA
+*
+* @note         NA
+*
+* @end
+*********************************************************************/
+
+void bview_system_init_ph2(void *param);
+
+/*********************************************************************
+* @brief     Function used to deinitialize various system components
+*
+*
+* @param[in] NA
+*
+* @retval    NA
+*
+* @note      NA
+*
+* @end
+*********************************************************************/
+
+void bview_system_deinit();
+
+/*********************************************************************
+* @brief         Function used to create and arm a timer
+*
+*
+* @param[in]     handler        function pointer to handle the callback
+* @param[in,out] timerId        timerId of the timer which is created
+* @param[in]     timeInMilliSec Time after which callback is required
+* @param[in]     mode           mode specifing if the timer must be
+*                               periodic or oneshot
+* @param[in]     param          Arguments passed from the calling function
+*
+* @retval        BVIEW_STATUS_SUCCESS
+* @retval        BVIEW_STATUS_FAILURE
+*
+* @note          NA
+*
+* @end
+*********************************************************************/
+
+BVIEW_STATUS system_timer_add(void * handler,timer_t * timerId, int timeInMilliSec,TIMER_MODE mode,void * param);
+
+
+/*********************************************************************
+* @brief      Function used to destroy a timer
+*
+*
+* @param[in]  timerId Timer id of the timer which needs to be destroyed
+*
+* @retval     BVIEW_STATUS_SUCCESS
+* @retval     BVIEW_STATUS_FAILURE
+*
+* @note          NA
+*
+* @end
+*********************************************************************/
+
+BVIEW_STATUS system_timer_delete(timer_t timerId);
+
+
+
+/*********************************************************************
+* @brief      Function used to set/reset a timer
+*
+*
+* @param[in]  timerId        Timer id of the timer which needs to be
+*                            set/reset
+* @param[in]  timeInMilliSec Time after which callback is required
+* @param[in]  mode           mode specifing if the timer must be
+*                            periodic or oneshot
+*
+* @retval     BVIEW_STATUS_SUCCESS
+* @retval     BVIEW_STATUS_FAILURE
+*
+* @note       NA
+*
+* @end
+*********************************************************************/
+
+BVIEW_STATUS system_timer_set(timer_t timerId,int timeInMilliSec,TIMER_MODE mode);
+
+#endif /* INCLUDE_SYSTEM_H */
+
diff --git a/src/sb_plugin/include/sbfeature.h b/src/sb_plugin/include/sbfeature.h
new file mode 100755
index 0000000..2633fc2
--- /dev/null
+++ b/src/sb_plugin/include/sbfeature.h
@@ -0,0 +1,48 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SB_FEATURE_H
+#define	INCLUDE_SB_FEATURE_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "openapps_feature.h"
+
+    /** The following structure defines a generic South-Bound feature 
+    * Specific Plugins add multiple callback declarations 
+    * underneath the single parameter */
+
+    typedef struct _bview_sb_feature_
+    {
+        /** Feature ID   */
+        BVIEW_FEATURE_ID featureId;
+        /** Mask of asics that support this feature */
+        BVIEW_ASIC_TYPE  supportedAsicMask;
+    } BVIEW_SB_FEATURE_t;
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* INCLUDE_SB_FEATURE_H */
+
diff --git a/src/sb_plugin/include/sbfeature_bst.h b/src/sb_plugin/include/sbfeature_bst.h
new file mode 100755
index 0000000..fe5a01c
--- /dev/null
+++ b/src/sb_plugin/include/sbfeature_bst.h
@@ -0,0 +1,131 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBFEATURE_BST_H
+#define INCLUDE_SBFEATURE_BST_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "sbplugin.h"
+#include "bst.h"
+
+/** The BST Southbound Feature Definition */
+
+typedef struct _bst_sb_feature_
+{
+    /** parent object */
+    BVIEW_SB_FEATURE_t feature;
+
+    /** Feature configuration set/get functions */
+    BVIEW_STATUS(*bst_config_set_cb)(int asic, BVIEW_BST_CONFIG_t *config);
+    BVIEW_STATUS(*bst_config_get_cb)(int asic, BVIEW_BST_CONFIG_t *config);
+
+    /** Obtain Complete ASIC Statistics Report */
+    BVIEW_STATUS(*bst_snapshot_get_cb)(int asic, BVIEW_BST_ASIC_SNAPSHOT_DATA_t *snapshot, BVIEW_TIME_t *time);
+
+    /** Obtain Device Statistics */
+    BVIEW_STATUS(*bst_device_data_get_cb)(int asic, BVIEW_BST_DEVICE_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Ingress Port + Priority Groups Statistics */
+    BVIEW_STATUS(*bst_ippg_data_get_cb)(int asic, BVIEW_BST_INGRESS_PORT_PG_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Ingress Port + Service Pools Statistics */
+    BVIEW_STATUS(*bst_ipsp_data_get_cb)(int asic, BVIEW_BST_INGRESS_PORT_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Ingress Service Pools Statistics */
+    BVIEW_STATUS(*bst_isp_data_get_cb)(int asic, BVIEW_BST_INGRESS_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Egress Port + Service Pools Statistics */
+    BVIEW_STATUS(*bst_epsp_data_get_cb)(int asic, BVIEW_BST_EGRESS_PORT_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Egress Service Pools Statistics */
+    BVIEW_STATUS(*bst_esp_data_get_cb)(int asic, BVIEW_BST_EGRESS_SP_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Egress Egress Unicast Queues Statistics */
+    BVIEW_STATUS(*bst_eucq_data_get_cb)(int asic, BVIEW_BST_EGRESS_UC_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Egress Egress Unicast Queue Groups Statistics */
+    BVIEW_STATUS(*bst_eucqg_data_get_cb)(int asic, BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Egress Egress Multicast Queues Statistics */
+    BVIEW_STATUS(*bst_emcq_data_get_cb)(int asic, BVIEW_BST_EGRESS_MC_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Egress Egress CPU Queues Statistics */
+    BVIEW_STATUS(*bst_cpuq_data_get_cb)(int asic, BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Obtain Egress Egress RQE Queues Statistics */
+    BVIEW_STATUS(*bst_rqeq_data_get_cb)(int asic, BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t *data, BVIEW_TIME_t *time);
+
+    /** Set threshold configuration for Device Statistics */
+    BVIEW_STATUS(*bst_device_threshold_set_cb)(int asic, BVIEW_BST_DEVICE_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for  Ingress Port + Priority Groups Statistics */
+    BVIEW_STATUS(*bst_ippg_threshold_set_cb)(int asic, int port, int pg, BVIEW_BST_INGRESS_PORT_PG_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Ingress Port + Service Pools Statistics */
+    BVIEW_STATUS(*bst_ipsp_threshold_set_cb)(int asic, int port, int sp, BVIEW_BST_INGRESS_PORT_SP_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Ingress Service Pools Statistics */
+    BVIEW_STATUS(*bst_isp_threshold_set_cb)(int asic, int sp, BVIEW_BST_INGRESS_SP_THRESHOLD_t *threshold);
+
+    /** Set Profile configuration for Egress Port + Service Pools Statistics */
+    BVIEW_STATUS(*bst_epsp_threshold_set_cb)(int asic, int port, int sp, BVIEW_BST_EGRESS_PORT_SP_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Egress Service Pools Statistics */
+    BVIEW_STATUS(*bst_esp_threshold_set_cb)(int asic, int sp, BVIEW_BST_EGRESS_SP_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Egress Egress Unicast Queues Statistics */
+    BVIEW_STATUS(*bst_eucq_threshold_set_cb)(int asic, int ucQueue, BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Egress Egress Unicast Queue Groups Statistics */
+    BVIEW_STATUS(*bst_eucqg_threshold_set_cb)(int asic, int ucQueueGrp, BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Egress Egress Multicast Queues Statistics */
+    BVIEW_STATUS(*bst_emcq_threshold_set_cb)(int asic, int mcQueue, BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Egress Egress CPU Queues Statistics */
+    BVIEW_STATUS(*bst_cpuq_threshold_set_cb)(int asic, int cpuQueue, BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD_t *threshold);
+
+    /** Set threshold configuration for Egress Egress RQE Queues Statistics */
+    BVIEW_STATUS(*bst_rqeq_threshold_set_cb)(int asic, int rqeQueue, BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_t *threshold);
+
+    /** Get all threshold configurations  */
+    BVIEW_STATUS(*bst_threshold_get_cb)(int asic, BVIEW_BST_ASIC_SNAPSHOT_DATA_t *thresholdSnapshot, BVIEW_TIME_t *time);
+
+    /** Clear all statistics  */
+    BVIEW_STATUS(*bst_clear_stats_cb) (int asic);
+
+    /** Clear all thresholds */
+    BVIEW_STATUS(*bst_clear_thresholds_cb) (int asic);
+    
+    /** register a callback to be invoked when a configured trigger goes off*/
+    BVIEW_STATUS(*bst_register_trigger_cb) (int asic, BVIEW_BST_TRIGGER_CALLBACK_t callback, void *cookie);
+
+    /** Obtain Complete ASIC default buffer values  */
+    BVIEW_STATUS(*bst_default_snapshot_get_cb)(int asic, BVIEW_BST_ASIC_SNAPSHOT_DATA_t *snapshot);
+} BVIEW_SB_BST_FEATURE_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INCLUDE_SBPLUGIN_BST_H */
diff --git a/src/sb_plugin/include/sbfeature_packet_trace.h b/src/sb_plugin/include/sbfeature_packet_trace.h
new file mode 100755
index 0000000..0b11ec6
--- /dev/null
+++ b/src/sb_plugin/include/sbfeature_packet_trace.h
@@ -0,0 +1,74 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_PACKET_TRACE_H
+#define INCLUDE_SBPLUGIN_PACKET_TRACE_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "sbplugin.h"
+#include "packet_trace.h"
+
+/** The Packet Trace Southbound Feature Definition */
+
+typedef struct _pt_sb_feature_
+{
+    /** parent object */
+    BVIEW_SB_FEATURE_t feature;
+
+    /** Feature configuration set/get functions */
+    BVIEW_STATUS(*pt_drop_reason_config_set_cb)(int asic, 
+                                                BVIEW_PT_DROP_REASON_CONFIG_t *config);
+    BVIEW_STATUS(*pt_drop_reason_config_get_cb)(int asic, 
+                                                BVIEW_PT_DROP_REASON_CONFIG_t *config);
+
+    /** Supported list of  drop reasons*/
+    BVIEW_STATUS(*pt_supported_drop_reason_get_cb)(int asic, 
+                                                   BVIEW_PT_DROP_REASON_MASK_t *mask);
+
+    /** Obtain Trace Profile Report */
+    BVIEW_STATUS(*pt_trace_profile_get_cb)(int asic, int  port,
+                                           BVIEW_PT_PACKET_t *packet,
+                                           BVIEW_PT_TRACE_PROFILE_t *traceProfile, 
+                                           BVIEW_TIME_t *time);
+
+    /** Obtain Compete Drop Counter Report */
+    BVIEW_STATUS(*pt_drop_counter_get_cb)(int asic, 
+                                          BVIEW_PT_DROP_COUNTER_REPORT_t *data, 
+                                          BVIEW_TIME_t *time);
+
+    /** Clear Drop Reasons Configuration*/
+    BVIEW_STATUS(*pt_clear_drop_reason_cb)(int asic);     
+
+    /** register a callback to be invoked when packet droped of matching configured drop reason*/
+    BVIEW_STATUS(*pt_register_trigger_cb) (int asic, 
+                                           BVIEW_PT_TRIGGER_CALLBACK_t callback, 
+                                           void *cookie);
+
+} BVIEW_SB_PT_FEATURE_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INCLUDE_SBPLUGIN_PACKET_TRACE_H */
+
diff --git a/src/sb_plugin/include/sbplugin.h b/src/sb_plugin/include/sbplugin.h
new file mode 100755
index 0000000..16f3508
--- /dev/null
+++ b/src/sb_plugin/include/sbplugin.h
@@ -0,0 +1,49 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_H
+#define INCLUDE_SBPLUGIN_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "asic.h"
+#include "sbfeature.h"
+
+
+/** The following structure defines a generic South-Bound Plugin. */
+typedef struct _bview_sbplugin_
+{
+    /** what features can this sbplugin support ? */
+    int numSupportedFeatures;
+    /** List of features */
+    BVIEW_SB_FEATURE_t *featureList[BVIEW_SBPLUGIN_MAX_FEATURES];
+
+} BVIEW_SB_PLUGIN_t;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_SBPLUGIN_H */
+
diff --git a/src/sb_plugin/include/sbplugin_system.h b/src/sb_plugin/include/sbplugin_system.h
new file mode 100755
index 0000000..b139a74
--- /dev/null
+++ b/src/sb_plugin/include/sbplugin_system.h
@@ -0,0 +1,79 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_SYSTEM_H
+#define INCLUDE_SBPLUGIN_SYSTEM_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "sbplugin.h"
+
+    /** The System Southbound Feature Definition */
+
+    typedef struct _system_sb_feature_
+    {
+        /** parent object */
+        BVIEW_SB_FEATURE_t feature;
+
+        /** what ASIC can this sbplugin support ? */
+        int numSupportedAsics;
+        BVIEW_ASIC_t *asicList[BVIEW_MAX_ASICS_ON_A_PLATFORM];
+
+        /** Supported Feature Mask*/
+        int featureMask;
+
+        /** Obtain System Name. Must return the name as a null-terminated string, 
+         * not exceeding length characters */
+        BVIEW_STATUS(*system_name_get_cb)(char *buffer, int length);
+
+        /** Obtain System (northbound) MAC address */
+        BVIEW_STATUS(*system_mac_get_cb)(uint8_t *buffer, int length);
+
+        /** Obtain System (northbound) IPv4 address */
+        BVIEW_STATUS(*system_ip4_get_cb)(uint8_t *buffer, int length);
+
+        /** Obtain Current Time*/
+        BVIEW_STATUS(*system_time_get_cb)(time_t *time);
+
+        /** Get ASIC from ASIC String*/
+        BVIEW_STATUS(*system_asic_translate_from_notation_cb) (char *src, int *asic);
+
+        /** Get ASIC string from ASIC*/
+        BVIEW_STATUS(*system_asic_translate_to_notation_cb) (int asic, char *dst);
+
+        /** Get Port Number from Port String*/
+        BVIEW_STATUS(*system_port_translate_from_notation_cb) (char *src, int *port);
+
+        /** Get Port String from Port Number*/
+        BVIEW_STATUS(*system_port_translate_to_notation_cb) (int asic, int port, char *dst);        
+ 
+        /** Get network OS*/
+        BVIEW_STATUS(*system_network_os_get_cb) (uint8_t *buffer, int length);        
+
+    } BVIEW_SB_SYSTEM_FEATURE_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INCLUDE_SBPLUGIN_SYSTEM_H */
+
diff --git a/src/sb_plugin/sb_ovsdb/Makefile b/src/sb_plugin/sb_ovsdb/Makefile
new file mode 100755
index 0000000..a41b075
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/Makefile
@@ -0,0 +1,69 @@
+ifeq ($(SBPLUGIN), ovsdb)
+MODULE := sbovsdb
+endif
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+export OUT_SBPLUGIN=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_SBPLUGIN=$(MODULE).a
+
+ifeq ($(SBPLUGIN), ovsdb)
+SB_PLUGIN_DIR = sb_ovsdb
+endif
+
+ifeq ($(PLATFORM), UB-OVSDB)
+SB_OVSDB_VENDOR_INCLUDE_DIR = $(OPENAPPS_BASE)/vendor/ovsdb/include
+endif
+
+ifeq ($(PLATFORM), OP-OVSDB)
+SB_OVSDB_VENDOR_INCLUDE_DIR = $(BV_OVS_INCLUDE)
+endif
+
+CFLAGS += -Wall -g -I$(SB_OVSDB_VENDOR_INCLUDE_DIR) -I../../public -I./include -I./$(SB_PLUGIN_DIR)/include -I../include -I./ -I../../../platform -I./bst/include
+
+
+
+
+searchdirs = $(realpath $(OPENAPPS_BASE)/src/sb_plugin/sb_ovsdb/)
+
+export CPATH += $(searchdirs)
+
+OBJECTS_SBPLUGIN := $(notdir $(patsubst %.c,%.o,$(shell find . -name "*.c")))
+
+export VPATH += $(dir $(shell find . -name "*.c"))
+
+$(OUT_SBPLUGIN)/%.o : %.c
+	@mkdir -p $(OUT_SBPLUGIN) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_SBPLUGIN)/$(LIBS_SBPLUGIN): $(patsubst %,$(OUT_SBPLUGIN)/%,$(subst :, ,$(OBJECTS_SBPLUGIN))) 
+	@cd $(OUT_SBPLUGIN) && $(AR) rvs $(MODULE).a $(OBJECTS_SBPLUGIN)  
+
+ifeq ($(PLATFORM), UB-OVSDB)
+#default target
+$(MODULE) all: $(OUT_SBPLUGIN)/$(LIBS_SBPLUGIN) 
+	@echo "OVSDB LIBS are copying"
+	@cp $(OPENAPPS_BASE)/vendor/ovsdb/*.a $(OUT_SBPLUGIN)/
+	$(NOOP)
+
+endif
+
+ifeq ($(PLATFORM), OP-OVSDB)
+#default target
+$(MODULE) all: $(OUT_SBPLUGIN)/$(LIBS_SBPLUGIN)
+        $(NOOP)
+endif
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_SBPLUGIN)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_SBPLUGIN=$(OUT_SBPLUGIN)"
+	@echo "LIBS_SBPLUGIN=$(LIBS_SBPLUGIN)"
diff --git a/src/sb_plugin/sb_ovsdb/bst/include/ovsdb_bst_ctl.h b/src/sb_plugin/sb_ovsdb/bst/include/ovsdb_bst_ctl.h
new file mode 100755
index 0000000..6133acc
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/bst/include/ovsdb_bst_ctl.h
@@ -0,0 +1,103 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+***************************************************************************/
+
+#ifndef INCLUDE_OVSDB_BST_CTL_H
+#define INCLUDE_OVSDB_BST_CTL_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*********************************************************************
+* @brief           Set default connection parameters                                 
+*
+* @param[in,out]   connectMode  - Connection Type 
+*
+* @notes
+*
+* @retval          none
+*
+*********************************************************************/
+
+void ovsdb_set_default(char * connectMode);
+
+/*********************************************************************
+* @brief           Read OVSDB Config File 
+*
+* @param[in,out]   connectMode  - Connection Type 
+*
+* @notes       
+*
+* @retval          BVIEW_STATUS_SUCCESS for successful execution
+*
+*********************************************************************/
+
+BVIEW_STATUS ovsdb_file_read(char * connectMode);
+
+/*********************************************************************
+* @brief       Commit column "trigger_threshold" in table "bufmon" to 
+*              OVSDB database.
+*
+* @param[in]   asic             -  ASIC ID
+* @param[in]   port             -  Port 
+* @param[in]   index            -  Index 
+* @param[in]   bid              -  Stat ID
+* @param[in]   threshold      -   Threshold.
+*
+* @notes       
+*          
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_threshold_commit (int asic , int port, int index,
+                                         int bid, uint64_t threshold);
+
+/*********************************************************************
+* @brief   Commit Table "System" columns to OVSDB database.
+*
+* @param[in]   asic              -   ASIC ID
+* @param[in]   config            -   Pointer to BST config Data.
+*
+* @retval      
+* 
+* @notes    
+*          
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_bst_config_commit (int asic ,
+                                          BVIEW_OVSDB_CONFIG_DATA_t *config);
+
+/*********************************************************************
+* @brief   BST OVSDB monitor thread
+*
+*
+*
+* @notes   Receive JSON notification from OVSDB-SERVER and Update the 
+*          SB PLUGIN cache.
+*
+*
+*********************************************************************/
+void bst_ovsdb_monitor();
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/src/sb_plugin/sb_ovsdb/bst/include/sbplugin_bst_cache.h b/src/sb_plugin/sb_ovsdb/bst/include/sbplugin_bst_cache.h
new file mode 100755
index 0000000..cab6423
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/bst/include/sbplugin_bst_cache.h
@@ -0,0 +1,201 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_BST_CACHE_H
+#define INCLUDE_SBPLUGIN_BST_CACHE_H
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "sbplugin.h"
+#include "sbplugin_ovsdb.h"
+#include "sbplugin_bst_map.h"
+#include "sbplugin_bst_ovsdb.h"
+
+/* OVSDB BST stat and threshold info per BID*/
+typedef struct _bst_ovsdb_bid_info_
+{
+  uint64_t  stat;      /* buffer usage of a particular BID */
+  uint64_t  threshold; /* Threshold configured */
+} BVIEW_OVSDB_BID_INFO_t;
+
+typedef struct _bst_ovsdb_stat_db_
+{
+  /*Device Data*/
+  BVIEW_OVSDB_BID_INFO_t         device;
+  /* Ingress Data*/
+  BVIEW_OVSDB_BID_INFO_t         iPGShared[SB_OVSDB_PG_SHARED_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         iPGHeadroom[SB_OVSDB_PG_HEADROOM_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         iPortSP[SB_OVSDB_I_P_SP_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         iSP[SB_OVSDB_I_SP_STAT_SIZE];
+  /* Egress Data*/
+  BVIEW_OVSDB_BID_INFO_t         ePortSPucShare[SB_OVSDB_E_P_SP_UC_SHARE_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         ePortSPumShare[SB_OVSDB_E_P_SP_UM_SHARE_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         ePortSPmcShare[SB_OVSDB_E_P_SP_UM_SHARE_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         eSPumShare[SB_OVSDB_E_SP_UM_SHARE_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         eSPmcShare[SB_OVSDB_E_SP_MC_SHARE_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         ucQ[SB_OVSDB_E_UC_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         eUCqGroup[SB_OVSBD_E_UC_Q_GROUP_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         mcQ[SB_OVSDB_E_MC_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         eCPU[SB_OVSDB_E_CPU_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         rqe[SB_OVSDB_E_RQE_STAT_SIZE];
+  BVIEW_OVSDB_BID_INFO_t         rqeQueueEntries[SB_OVSDB_E_RQE_QUEUE_STAT_SIZE];
+} BVIEW_OVSDB_BST_STAT_DB_t;
+
+/* BST Config cache of OVSDB */
+typedef struct _bst_ovsdb_config_data_
+{
+  bool bst_enable;          /* BST enable data */
+  int  bst_tracking_mode;   /* BST tracking mode */
+  bool periodic_collection; /* Periodic collections of stats */
+  int  collection_interval;  /* Periodic collection interval */
+} BVIEW_OVSDB_CONFIG_DATA_t;
+
+
+typedef struct _bst_ovsdb_data_
+{ 
+  /* Semaphore */
+  pthread_rwlock_t  lock;
+  /* BST Configuration data*/
+  BVIEW_OVSDB_CONFIG_DATA_t     config_data;  
+  /* OVSDB plugin Cache */
+  BVIEW_OVSDB_BST_STAT_DB_t     cache[BVIEW_MAX_ASICS_ON_A_PLATFORM];
+
+} BVIEW_OVSDB_BST_DATA_t;
+
+/*********************************************************************
+* @brief   Initialise BST OVSDB cache
+*
+* @param[in]   @none 
+* @param[out]  @none 
+*
+* @retval BVIEW_STATUS_FAILURE   Failed to initialise BST ovsdb cache
+* @retval BVIEW_STATUS_SUCCESS   Successfully initialised BST ovsdb cache
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_init();
+
+/*********************************************************************
+* @brief   Set BST configuration in ovsdb cache
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   config   -  Pointer to BST configuration.
+
+* @param[out]  @none 
+*
+* @retval BVIEW_STATUS_FAILURE  Failed to set bst configuration in ovsdb cache         
+* @retval BVIEW_STATUS_SUCCESS  Successfully set bst cofiguration in cache
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_bst_config_set(int asic,
+                                            BVIEW_OVSDB_CONFIG_DATA_t *config);
+
+/*********************************************************************
+* @brief   Get BST configuration from ovsdb cache
+*
+* @param[in]   asic     -  asic number.   
+* @param[out]  config   -  Pointer to BST configuration data.
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter(s)         
+* @retval BVIEW_STATUS_SUCCESS            Successfully obtained bst 
+*                                         cofiguration from cache
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_bst_config_get(int asic,
+                                            BVIEW_OVSDB_CONFIG_DATA_t *config);
+
+/*********************************************************************
+* @brief   Get the pointer to BST data
+*
+* @retval  Pointer to BVIEW_OVSDB_BST_CACHE_t
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_OVSDB_BST_DATA_t  *bst_ovsdb_cache_get ();
+
+/*********************************************************************
+* @brief    Get row from ovsdb-key  <realm>/<name>/<index1>/<index2>
+*
+*
+* @param[in]   asic      -  asic number
+* @param[in]   ovsdb_key -  ovsdb bufmon table's name/key entry
+* @param[out]  p_row     -  Pointer to the row
+
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to get row from ovsdb key
+* @retval BVIEW_STATUS_SUCCESS
+*
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_row_get (int asic, char *ovsdb_key,
+                                      BVIEW_OVSDB_BID_INFO_t **p_row);
+
+/*********************************************************************
+* @brief    Update the stat/threshold of row with key 'ovsdb_key'. 
+*           
+*
+* @param[in]   asic      -  asic number   
+* @param[in]   ovsdb_key -  ovsdb bufmon table's name/key entry     
+* @param[out]  p_row     -  Pointer to the row    
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to get the row for ovsdb_key.
+* @retval BVIEW_STATUS_SUCCESS      updated cache successfully. 
+*                                   
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS    bst_ovsdb_row_update (int asic, char *ovsdb_key,
+                                      BVIEW_OVSDB_BID_INFO_t *prow);
+
+/*********************************************************************
+* @brief   Dumps BST ovsdb cache. 
+*          Non zero Stats and thresholds are dumped
+*
+* @retval BVIEW_STATUS_FAILURE      
+* @retval BVIEW_STATUS_SUCCESS      
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_dump (int asic);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INCLUDE_SBPLUGIN_BST_CACHE_H */
+
+
diff --git a/src/sb_plugin/sb_ovsdb/bst/ovsdb_bst_ctl.c b/src/sb_plugin/sb_ovsdb/bst/ovsdb_bst_ctl.c
new file mode 100755
index 0000000..f6d86fa
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/bst/ovsdb_bst_ctl.c
@@ -0,0 +1,750 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+***************************************************************************/
+
+/* OVSDB includes*/
+#include <unistd.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <openvswitch/compiler.h>
+#include <json.h>
+#include <jsonrpc.h>
+#include <ovsdb-data.h>
+#include <poll-loop.h>
+#include <stream.h>
+
+/* BroadView Includes*/
+#include "sbplugin_bst_ovsdb.h"
+#include "sbplugin_bst_cache.h"
+
+#define OVSDB_CONFIG_MAX_LINE_LENGTH       256
+#define OVSDB_CONFIG_FILE                  "/etc/broadview_ovsdb_config.cfg"
+#define OVSDB_CONFIG_READMODE              "r"
+#define OVSDB_CONFIG_DELIMITER             "="
+#define OVSDB_CONFIG_MODE_DELIMITER        ":"
+#define OVSDB_MODE_TCP                     "tcp"
+#define OVSDB_MODE_FILE                    "unix"
+#define OVSDB_SOCKET                       "ovsdb_socket"
+#define OVSDB_MAX_LINES                    2  
+#define _DEFAULT_OVSDB_SOCKET "unix:/var/run/openvswitch/db.sock"
+
+#define OVSDB_ASSERT_CONFIG_FILE_ERROR(condition) do { \
+    if (!(condition)) { \
+        SB_OVSDB_LOG(BVIEW_LOG_ERROR, \
+                    "OVSDB (%s:%d) Unrecognized Config File format, may be corrupted. Errno : %s  \n", \
+                    __func__, __LINE__, strerror(errno)); \
+                        fclose(configFile); \
+        return (BVIEW_STATUS_FAILURE); \
+    } \
+} while(0)
+
+
+/* UUID size id 36 as per RFC 7047*/
+#define   OVSDB_UUID_SIZE            36
+
+
+#define   BST_OVSDB_THRESHOLD_JSON    "[\"OpenSwitch\",{\"op\":\"update\",\"table\":\"bufmon\",\"row\":{\"trigger_threshold\":%lld},\"where\":[[\"name\",\"==\", \"%s\"]]}]"
+
+#define   BST_OVSDB_CONFIG_JSON_FORMAT       "[\"OpenSwitch\",{\"op\":\"update\",\"table\":\"System\",\"row\":{\"bufmon_config\":[\"map\",[[\"enabled\",\"%s\"], [\"counters_mode\",\"%s\"], [\"periodic_collection_enabled\",\"%s\"],[\"collection_period\",\"%s\"]]]} , \"where\":[[\"_uuid\",\"==\",[\"uuid\", \"%s\"]]]}]"
+
+
+#define  BST_JSON_MONITOR_BUFMON   "[\"OpenSwitch\",null,{\"bufmon\":[{\"columns\":[\"counter_value\",\"counter_vendor_specific_info\",\"enabled\",\"hw_unit_id\",\"name\",\"status\",\"trigger_threshold\",\"_version\"]}], \"System\":[{\"columns\":[\"bufmon_config\"]},{\"columns\":[\"bufmon_info\"]}]}]"
+
+
+#define  BST_OVSDB_FORM_CONFIG_JSON(_buf, _format, args...) \
+                                  {\
+                                    sprintf ((_buf), (_format), ##args);\
+                                  }  
+
+#define  OVSDB_GET_COLUMN(_column,_old, _new,_columnname)   \
+       {\
+         if (!(_old)) \
+         { \
+           (_column) = shash_find_data (json_object((_new)), (_columnname));  \
+         } \
+         else if (!(_new)) \
+         { \
+           (_column) = shash_find_data (json_object((_old)), (_columnname));  \
+         } \
+         else \
+         { \
+           (_column) = shash_find_data (json_object((_new)), (_columnname)); \
+         }\
+       }
+
+static char system_table_uuid[OVSDB_UUID_SIZE];
+#define  BST_NUM_MONITOR_TABLES              2
+const char *bst_table_name[BST_NUM_MONITOR_TABLES] = {"bufmon", "System"};
+extern sem_t monitor_init_done_sem;
+
+/*********************************************************************
+* @brief       Check the return error code of both reply and request
+*
+* @param[in]  error               -  Erorr 
+* @param[in]  reply               -  Pointer to reply JSON message
+*                       
+* @retval     schema if successful.
+*             NULL   if failure.
+*
+*********************************************************************/
+static void
+check_txn(int error, struct jsonrpc_msg **reply_)
+{
+  struct jsonrpc_msg *reply ;
+
+  if (!reply_)
+  {
+    return;
+  }
+  reply = *reply_;
+
+  if (error) 
+  {
+    SB_OVSDB_DEBUG_PRINT ("Transaction failed");
+    return;  
+  }
+
+  if (reply->error) 
+  {
+    SB_OVSDB_DEBUG_PRINT ("Transaction returned errors");
+    return;
+  }
+}
+
+/*********************************************************************
+* @brief    Open JSON RPC session.
+*
+* @param[in]     server          - Sock file/TCP/UDP port     
+*
+* @retval        Pointer to JSON RPC session.
+*
+* @notes   
+*
+*
+*********************************************************************/
+static struct jsonrpc *
+open_jsonrpc(const char *server)
+{
+  struct stream *stream;
+  int error;
+  
+  /* NULL pointer validation*/
+  SB_OVSDB_NULLPTR_CHECK (server, NULL);
+
+  error = stream_open_block(jsonrpc_stream_open(server, &stream,
+                              DSCP_DEFAULT), &stream);
+  if (error == EAFNOSUPPORT) 
+  {
+    struct pstream *pstream;
+
+    error = jsonrpc_pstream_open(server, &pstream, DSCP_DEFAULT);
+    if (error) 
+    {
+      SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+                   "Failed to connect to: (%s)",
+                    server);
+      return NULL;
+    }
+
+    error = pstream_accept_block(pstream, &stream);
+    if (error) 
+    {
+      SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+                   "Failed to accept connection: (%s)",
+                    server);
+      
+      pstream_close(pstream);
+      return NULL; 
+    }
+  } 
+  else if (error) 
+  {
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+                  "Failed to connect to (%s)",
+                  server);
+    return NULL;
+  }
+
+  return jsonrpc_open(stream);
+}
+
+
+/*********************************************************************
+* @brief    Get 'Value' associated with 'Key' in bufmon_config and 
+*           bufmon_info columns.
+*
+* @param[in]    json_object       - Pointer to the JSON object.
+* @param[in]    p_string          - Pointer to the "Key" String.
+* @param[out]   p_value           - Pointer to the "value" String. 
+*
+* @retval
+* 
+* @notes     This function is to get "Value" string of perticualr 
+*            "key" in bufmon_config and bufmon_info columns.
+*
+*            Need to enchance this function to parse all row elements 
+*            at a time.
+*********************************************************************/
+
+static BVIEW_STATUS
+bst_system_bufmon_config_update (struct json *json_object)
+{
+  int elem = 0;
+  struct json *array = NULL;
+  struct json *key = NULL;
+  struct json *value = NULL;
+  struct json *sub_array = NULL;
+  struct json *map = NULL;
+  BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+  BVIEW_OVSDB_CONFIG_DATA_t  *bufmon_config = NULL; 
+
+  /* NULL pointer validation */ 
+  SB_OVSDB_NULLPTR_CHECK (json_object, BVIEW_STATUS_INVALID_PARAMETER);
+
+  /* bufmon_config column is array of 'key' and 'value' strings
+   * the first element is always string "map".
+   * ["map",[["enabled","true"],["counters_mode","peak"],[ ], p].....] 
+   */
+
+  /* Return failure if object is not an array or 
+   *                if first element is not the string "map"
+   *                if second element type is not an array
+   */
+  map =  json_array(json_object)->elems[0];
+  array = json_array(json_object)->elems[1];
+  if ((json_object->type != JSON_ARRAY) ||
+      (strcmp ("map",map->u.string) != 0) || 
+      (array->type != JSON_ARRAY))
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  p_cache = bst_ovsdb_cache_get ();
+  if (!p_cache)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Acquire read lock*/
+  SB_OVSDB_RWLOCK_WR_LOCK(p_cache->lock);
+
+
+  bufmon_config = &p_cache->config_data;
+  for (elem = 0; elem < json_array(array)->n_allocated; elem++)
+  {
+    /* Each 'key' 'value' pair is an array with two elements*/
+    sub_array = json_array (array)->elems[elem];
+    if (sub_array->type == JSON_ARRAY)
+    {
+      key = json_array (sub_array)->elems[0];
+      value = json_array (sub_array)->elems[1];
+      if (strcmp (key->u.string, "counters_mode") == 0)
+      {
+         bufmon_config->bst_tracking_mode = 
+               ((strcmp (value->u.string, "peak") == 0)? BVIEW_BST_MODE_PEAK : BVIEW_BST_MODE_CURRENT);
+      }
+      else if (strcmp (key->u.string, "enabled") ==0)
+      {
+         bufmon_config->bst_enable = 
+               ((strcmp (value->u.string, "true") == 0)? true : false);  
+      }
+      else if (strcmp (key->u.string, "periodic_collection_enabled") ==0)
+      {
+         bufmon_config->periodic_collection  =
+               ((strcmp (value->u.string, "true") == 0)? true : false);
+      }
+      else if (strcmp (key->u.string, "collection_period") ==0) 
+      {
+         bufmon_config->collection_interval = atoi(value->u.string);
+      }
+    }
+  }
+
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief    Update SB PLUGIN cache.
+*
+* @param[in]   table_name   - Pointer to the table_name string.
+* @param[in]   table_update - Pointer to "Update" JSON Object.
+* @param[in]   Initial      - Initial rows
+*
+* @retval
+*
+* @notes    if Initial 
+*
+*
+*********************************************************************/
+static BVIEW_STATUS
+bst_ovsdb_cache_update_table(const char *table_name, struct json *table_update,
+                               bool initial)
+{
+  struct shash_node *node;
+
+  /* NULL Pointer validation*/
+  SB_OVSDB_NULLPTR_CHECK (table_update, BVIEW_STATUS_INVALID_PARAMETER);
+  SB_OVSDB_NULLPTR_CHECK (table_name, BVIEW_STATUS_INVALID_PARAMETER);
+
+  /* return if JSON type is not object*/
+  if (table_update->type != JSON_OBJECT) 
+  {
+     return BVIEW_STATUS_FAILURE;
+  }
+  /* Loop through all Nodes and update the cahce*/
+  SHASH_FOR_EACH (node, json_object(table_update)) 
+  {
+    BVIEW_OVSDB_BID_INFO_t   row = {0,0};
+    struct json *row_update = node->data;
+    struct json *old, *new, *hw_unit_id, *name, *counter_value, *trigger_threshold;
+
+    if (row_update->type != JSON_OBJECT) {
+        continue;
+    }
+    old = shash_find_data(json_object(row_update), "old");
+    new = shash_find_data(json_object(row_update), "new");
+    if (strcmp (table_name, "bufmon") == 0)
+    {
+      OVSDB_GET_COLUMN (hw_unit_id, old, new , "hw_unit_id")
+      OVSDB_GET_COLUMN (name, old, new , "name")
+      OVSDB_GET_COLUMN (counter_value, old, new , "counter_value")
+      OVSDB_GET_COLUMN (trigger_threshold, old, new , "trigger_threshold")
+      
+      /* Name + hw_unit_id is key, if both are NULL don't update the cache.*/
+      if (name && hw_unit_id)
+      {
+        if (counter_value && counter_value->type == JSON_INTEGER)
+        {
+          row.stat = counter_value->u.integer;
+        }
+          
+        if (trigger_threshold && trigger_threshold->type == JSON_INTEGER)
+        {
+           row.threshold = trigger_threshold->u.integer;
+        }
+    
+        /* Update BST cache*/
+        bst_ovsdb_row_update (hw_unit_id->u.integer, 
+                              name->u.string,
+                              &row);
+      }
+    } /* if (strcmp (table_name, ..... */
+    else if (strcmp (table_name,"System") ==0)
+    {
+      struct json *config;
+
+      /* Validate UUID length*/
+      if (strlen (node->name) !=  OVSDB_UUID_SIZE)
+      {
+        SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+               "OVSDB BST monitor: Invalid UUID length (%d)",
+                strlen (node->name));
+        continue;
+      }  
+      /* COPY UUID*/
+      strncpy (system_table_uuid, node->name, sizeof(system_table_uuid));
+      OVSDB_GET_COLUMN (config, old, new, "bufmon_config");
+      if (config)
+      {
+        bst_system_bufmon_config_update (config);
+      }
+    } 
+  } /* SHASH_FOR_EACH (node, json_object(table_update)) */
+  if (strlen (system_table_uuid) > 0)
+  {
+    if (sem_post(&monitor_init_done_sem) != 0)
+    {
+        SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+               "OVSDB BST monitor: Failed to release semaphore");
+        return BVIEW_STATUS_FAILURE;
+    }
+  }
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
+/*********************************************************************
+* @brief     update the sbplugin cache.
+*
+*@param[in]  table_updates    -  Pointer to "Update" JSON object.
+*@param[in]  mts              -  Pointer to local monitored table.
+*@param[in]  n_mts            -  number of tables monitored.
+*@param[in]  initial          -  Is it initial Notification from server.
+*
+* @retval
+* @notes   
+*
+*
+*********************************************************************/
+static BVIEW_STATUS
+bst_ovsdb_cache_update(struct json *table_updates,
+                       bool initial)
+{
+  size_t i;
+  struct json *table_update;    
+
+  SB_OVSDB_NULLPTR_CHECK (table_updates, BVIEW_STATUS_INVALID_PARAMETER);
+
+  /* Table is JSON object. Dont Process if the type is not
+   * JSON object.
+   */ 
+  if (table_updates->type != JSON_OBJECT) 
+  {
+    SB_OVSDB_DEBUG_PRINT(
+                         "Update JSON type is not object %d", 
+                          table_updates->type);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Loop through all the tables which are configured to be monitored*/
+  for (i = 0; i < BST_NUM_MONITOR_TABLES; i++) 
+  {
+    table_update = shash_find_data(json_object(table_updates),
+                                   bst_table_name[i]);
+    if (table_update) 
+    {
+       bst_ovsdb_cache_update_table(bst_table_name[i], table_update, initial);
+    }
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief           Set default connection parameters                                 
+*
+* @param[in,out]   connectMode  - Connection Type 
+*
+* @notes
+*
+* @retval          none
+*
+*********************************************************************/
+
+void ovsdb_set_default(char * connectMode)
+{
+  if (connectMode != NULL)
+  {
+    strcpy(connectMode,_DEFAULT_OVSDB_SOCKET);
+  }
+  else
+  {
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+               "OVSDB Set Default : NULL Pointer\n");
+    return;
+  } 
+}	
+
+/*********************************************************************
+* @brief           Read OVSDB Config File                                 
+*
+* @param[in,out]   connectMode  - Connection Type 
+*
+* @notes
+*
+* @retval          BVIEW_STATUS_SUCCESS for successful execution
+*
+*********************************************************************/
+
+BVIEW_STATUS ovsdb_file_read(char * connectMode)
+{
+  FILE *configFile;
+  char line[OVSDB_CONFIG_MAX_LINE_LENGTH] = {0};
+  char line_copy[OVSDB_CONFIG_MAX_LINE_LENGTH] = {0};
+  int numLines = 0;
+  char *property,*value;
+  if (connectMode == NULL)
+  {
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+               "OVSDB File Read : NULL Pointer\n");
+    return BVIEW_STATUS_FAILURE;
+  }
+  configFile = fopen(OVSDB_CONFIG_FILE, OVSDB_CONFIG_READMODE);
+  if (configFile == NULL)
+  {
+    ovsdb_set_default(connectMode);
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+               "OVSDB File Read : Failed to open config file %s", 
+                OVSDB_CONFIG_FILE);
+    return BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    while (numLines < OVSDB_MAX_LINES)
+    {
+      memset (&line[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+      memset (&line_copy[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+      property= fgets(&line[0], OVSDB_CONFIG_MAX_LINE_LENGTH, configFile);
+      OVSDB_ASSERT_CONFIG_FILE_ERROR(property != NULL);
+      /*Ignoring commented line in config file*/
+      if (line[0] == '#')
+      {
+        numLines++;
+        continue;
+      }    
+      property = strtok(&line[0], OVSDB_CONFIG_DELIMITER);
+      OVSDB_ASSERT_CONFIG_FILE_ERROR(property != NULL);
+      value = property + strlen(property) + 1; 
+      if (strcmp(property, OVSDB_SOCKET) == 0)
+      {
+        value[strlen(value)] = 0;
+        strcpy(line_copy,value);
+        property = strtok(&value[0], OVSDB_CONFIG_MODE_DELIMITER);
+        OVSDB_ASSERT_CONFIG_FILE_ERROR(property != NULL);
+        if ((strcmp(property, OVSDB_MODE_TCP) == 0) || (strcmp(property, OVSDB_MODE_FILE) == 0))
+        {
+          strncpy(connectMode,line_copy,(strlen(line_copy) - 1));
+        }
+        else
+        {
+          SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+                   "OVSDB File Read : Invalid content in config file %s", 
+                    OVSDB_CONFIG_FILE);
+          fclose(configFile);  
+          return BVIEW_STATUS_FAILURE;
+        } 
+        numLines++;
+        continue; 
+      }
+      else
+      {
+          SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+                   "OVSDB File Read : Invalid content in config file %s", 
+                    OVSDB_CONFIG_FILE);
+          fclose(configFile);  
+          return BVIEW_STATUS_FAILURE;
+      }    
+    }
+  }  
+  SB_OVSDB_LOG (BVIEW_LOG_INFO,
+               "OVSDB File Read : File contents processed sucessfully. config file %s", 
+                OVSDB_CONFIG_FILE);
+  fclose(configFile);
+  return BVIEW_STATUS_SUCCESS;
+}
+/*********************************************************************
+* @brief   BST OVSDB monitor thread
+*
+*
+*
+* @notes   Receive JSON notification from OVSDB-SERVER and Update the 
+*          SB PLUGIN cache.
+*
+*
+*********************************************************************/
+void
+bst_ovsdb_monitor()
+{
+  struct jsonrpc_msg *request;
+  struct json *monitor,*request_id;
+  struct jsonrpc *rpc;
+  struct jsonrpc_msg *msg;
+  int error;
+  char connectMode[OVSDB_CONFIG_MAX_LINE_LENGTH];
+  struct json *params;
+    
+    /* Open RPC Session*/
+  memset (&connectMode[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+  if (ovsdb_file_read(connectMode) != BVIEW_STATUS_SUCCESS)
+  {
+    /*Set default connection mode*/
+    memset (&connectMode[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+    ovsdb_set_default(connectMode);
+  }
+  rpc = open_jsonrpc (connectMode); 
+  if (!rpc) 
+  {
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+               "OVSDB BST monitor:Failed to open JSON RPC session %s", 
+                connectMode);
+    return;
+  }
+  /* Send monitor request to the ovsdb server*/
+  monitor = json_from_string(BST_JSON_MONITOR_BUFMON);
+  request = jsonrpc_create_request("monitor", monitor, NULL);
+  request_id = json_clone (request->id);
+  error = jsonrpc_send(rpc, request);
+  if (error)
+  {
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+               "OVSDB BST monitor:Failed to send 'monitor bufmon table' to ovsdb-server %s",
+                connectMode);
+    return;
+  }
+
+  for (;;)
+  {
+    while (1) 
+    {
+      error = jsonrpc_recv(rpc, &msg);
+      if (error)
+      {
+        break;
+      }
+         /* Initial entries notified by ovsdb-server server through 
+          * Message type "Reply"
+          */
+      if (msg->type == JSONRPC_REPLY &&
+         (json_equal(msg->id, request_id)))
+      {
+        bst_ovsdb_cache_update (msg->result, true);
+      }
+         /* Row/Column Modify (s) are notfied by ovsdb-server through 
+          * Message type "Update
+          */
+      else if (msg->type == JSONRPC_NOTIFY &&
+               !strcmp(msg->method, "update")) 
+      {
+        params = msg->params;
+        if (params->type == JSON_ARRAY
+         && params->u.array.n == 2
+         && params->u.array.elems[0]->type == JSON_NULL) 
+        {
+              /* extract data and update plugin cache*/
+          bst_ovsdb_cache_update (params->u.array.elems[1], false);                 
+        }
+      }
+      jsonrpc_msg_destroy(msg);
+    }
+    jsonrpc_run(rpc);
+    jsonrpc_wait(rpc);
+    jsonrpc_recv_wait(rpc);
+    poll_block();
+  }
+}
+
+/*********************************************************************
+* @brief       Commit column "trigger_threshold" in table "bufmon" to 
+*              OVSDB database.
+*
+* @param[in]   asic             -  ASIC ID
+* @param[in]   port             -  Port 
+* @param[in]   index            -  Index 
+* @param[in]   bid              -  Stat ID
+* @param[in]   threshold      -  Threshold.
+*
+* @notes       
+*          
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_threshold_commit (int asic , int port, int index,
+                                         int bid, uint64_t threshold)
+{
+  char   s_transact[1024] = {0};
+  char   s_key[1024]       = {0};
+  struct json *transaction;
+  struct jsonrpc_msg *request, *reply;
+  struct jsonrpc *rpc;
+  char connectMode[OVSDB_CONFIG_MAX_LINE_LENGTH]; 
+  BVIEW_STATUS   rv = BVIEW_STATUS_SUCCESS;
+  /* Get Row name */
+  rv = bst_bid_port_index_to_ovsdb_key (asic, bid, port, index, 
+                                        s_key, sizeof(s_key));
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT(
+                         "Failed to build the key for (asic(%d) bid(%d) port(%d) index(%d) type (%s)",
+                         asic, bid, port, index, "threshold");
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Create JSON Request*/
+  sprintf (s_transact, BST_OVSDB_THRESHOLD_JSON ,(unsigned long long int) threshold, s_key);
+
+  transaction = json_from_string(s_transact);
+  request = jsonrpc_create_request("transact", transaction, NULL);
+  memset (&connectMode[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+  if (ovsdb_file_read(connectMode) != BVIEW_STATUS_SUCCESS)
+  {
+    /*Set default connection mode*/
+    memset (&connectMode[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+    ovsdb_set_default(connectMode);
+  } 
+  rpc = open_jsonrpc (connectMode);
+  if (rpc == NULL)
+  { 
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+                 "Trigger_threshold commit:Failed to open JSNON RPC session");
+    return BVIEW_STATUS_FAILURE;
+  }
+  check_txn(jsonrpc_transact_block(rpc, request, &reply),&reply);
+  jsonrpc_msg_destroy(reply);
+  jsonrpc_close(rpc);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Commit Table "System" columns to OVSDB database.
+*
+* @param[in]   asic              -   ASIC ID
+* @param[in]   config            -   Pointer to BST config Data.
+*
+* @retval      
+* 
+* @notes    
+*          
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_bst_config_commit (int asic , 
+                                          BVIEW_OVSDB_CONFIG_DATA_t *config)
+{
+  char   s_transact[1024] = {0};
+  char   buf[16]          = {0};
+  struct json *transaction;
+  struct jsonrpc_msg *request, *reply;
+  struct jsonrpc *rpc;
+  char connectMode[OVSDB_CONFIG_MAX_LINE_LENGTH];
+ 
+  /* NULL Pointer validation */
+  SB_OVSDB_NULLPTR_CHECK (config, BVIEW_STATUS_INVALID_PARAMETER);
+
+  printf ("\r\n bst_ovsdb_threshold_commit\r\n"); 
+  sprintf (buf, "%d",config->collection_interval);
+  /* Create JSON request*/ 
+  BST_OVSDB_FORM_CONFIG_JSON (s_transact, BST_OVSDB_CONFIG_JSON_FORMAT,
+                              (config->bst_enable ? "true":"false"),
+                              ((config->bst_tracking_mode == BVIEW_BST_MODE_PEAK) ? "peak":"current"),
+                              (config->periodic_collection ? "true":"false"), 
+                              buf,
+                              system_table_uuid);
+                                  
+  transaction = json_from_string(s_transact);
+  request = jsonrpc_create_request("transact", transaction, NULL);
+  memset (&connectMode[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+  if (ovsdb_file_read(connectMode) != BVIEW_STATUS_SUCCESS)
+  {
+    /*Set default connection mode*/
+    memset (&connectMode[0], 0, OVSDB_CONFIG_MAX_LINE_LENGTH);
+    ovsdb_set_default(connectMode);
+  } 
+  rpc = open_jsonrpc (connectMode);
+  if (rpc == NULL)
+  { 
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR,
+                 "System config commit:Failed to open JSNON RPC session");
+    return BVIEW_STATUS_FAILURE;
+  }
+  check_txn(jsonrpc_transact_block(rpc, request, &reply),&reply);
+  jsonrpc_msg_destroy(reply);
+  jsonrpc_close(rpc);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
diff --git a/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst.c b/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst.c
new file mode 100755
index 0000000..ebeb76b
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst.c
@@ -0,0 +1,2335 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <semaphore.h>
+#include <time.h>
+#include <errno.h>
+#include <signal.h>
+#include <pthread.h>
+#include "common/platform_spec.h"
+#include "bst.h"
+#include "sbfeature_bst.h"
+#include "sbplugin_bst.h"
+#include "sbplugin_system.h"
+#include "sbplugin_bst_map.h"
+#include "sbplugin_bst_ovsdb.h"
+#include "ovsdb_bst_ctl.h"
+
+/* Ovsdb Monitor init time out value */
+#define SB_OVSDB_MONITOR_INIT_TIME_OUT    10   /* Seconds */
+
+/* Macro to iterate all ports*/
+#define  BVIEW_BST_PORT_ITER(_asic,_port)                                         \
+              for ((_port) = 1; (_port) <= asicDb[(_asic)].scalingParams.numPorts; (_port)++)
+
+/* Macro to iterate all Priority Groups*/
+#define  BVIEW_BST_PG_ITER(_asic,_pg)                                                 \
+              for ((_pg) = 0; (_pg) < asicDb[(_asic)].scalingParams.numPriorityGroups; (_pg)++)
+
+/* Macro to iterate all Service Pools*/
+#define  BVIEW_BST_SP_ITER(_asic,_sp)                                                 \
+              for ((_sp) = 0; (_sp) < asicDb[(_asic)].scalingParams.numServicePools; (_sp)++)
+
+/* Macro to iterate all Service Pools + Common Service Pool*/
+#define  BVIEW_BST_TOTAL_SP_ITER(_asic,_sp)                                            \
+              for ((_sp) = 0; (_sp) < (asicDb[(_asic)].scalingParams.numServicePools + \
+                           asicDb[(_asic)].scalingParams.numCommonPools)  ; (_sp)++)
+
+/* Macro to iterate all Unicast queues*/
+#define  BVIEW_BST_UC_QUEUE_ITER(_asic, _ucqueue)                                          \
+              for ((_ucqueue) = 0; (_ucqueue) < asicDb[(_asic)].scalingParams.numUnicastQueues; \
+                   (_ucqueue)++)
+
+/* Macro to iterate all Multicast queues */
+#define  BVIEW_BST_MC_QUEUE_ITER(_asic, _mcqueue)                                                 \
+              for ((_mcqueue) = 0; (_mcqueue) < asicDb[(_asic)].scalingParams.numMulticastQueues; \
+                   (_mcqueue)++)
+
+/* Macro to iterate all CPU queues */
+#define  BVIEW_BST_CPU_QUEUE_ITER(_asic, _cpuqueue)                                              \
+              for ((_cpuqueue) = 0; (_cpuqueue) < asicDb[(_asic)].scalingParams.numCpuQueues;    \
+                   (_cpuqueue)++)
+
+/* Macro to iterate all RQE queues */
+#define  BVIEW_BST_RQE_QUEUE_ITER(_asic, _rqe)                                                    \
+               for ((_rqe) = 0; (_rqe) < asicDb[(_asic)].scalingParams.numRqeQueues;              \
+                   (_rqe)++)
+
+/* Macro to iterate all Queue Groups */
+#define  BVIEW_BST_UC_QUEUE_GRP_ITER(_asic, _qgroup)                                                             \
+               for ((_qgroup) = 0; (_qgroup) < asicDb[(_asic)].scalingParams.numUnicastQueueGroups;              \
+                    (_qgroup)++) 
+
+
+#define BVIEW_OVSDB_BST_GET_DB_INDEX(_asic, _bid, _index1, _index2, _p_dbindex) \
+                          { \
+                            if (BVIEW_STATUS_SUCCESS != bst_ovsdb_resolve_index ((_asic), (_bid), \
+                                                         (_index1), (_index2), (_p_dbindex))) \
+                            { \
+                              return BVIEW_STATUS_FAILURE;\
+                            } \
+                          } 
+
+#define BVIEW_OVSDB_BST_CACHE_GET(_cache) \
+              {\
+                (_cache) = bst_ovsdb_cache_get ();\
+                if (!(_cache)) \
+                { \
+                  return BVIEW_STATUS_FAILURE; \
+                } \
+              }
+
+sem_t monitor_init_done_sem;
+
+pthread_t ovsdb_client_thread;
+
+/*********************************************************************
+* @brief    OVSDB BST client  
+*           
+*
+*
+* @notes    open a JSON RPC session and process "update" notification
+*           from OVSDB-server
+*
+*********************************************************************/
+void bst_ovsdb_client()
+{
+  bst_ovsdb_monitor ();
+}
+
+/*********************************************************************
+* @brief    OVSDB client init and spawn a thread to act as ovsdb client 
+*            for BST
+*
+* @retval   BVIEW_STATUS_SUCCESS if ovsdb client 
+*                                initialized successfully.
+* @retval   BVIEW_STATUS_FAILURE if initialization is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_client_init()
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  struct timespec ts;
+  int retVal = 0;
+  
+/*  char *ovsdb_soc = OVSDB_SOCKET_FILE;*/
+
+  if (sem_init(&monitor_init_done_sem, 0, 0) == -1)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to create semaphore");
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Spawn a thread for ovsdb client */
+  if (0 != pthread_create (&ovsdb_client_thread, NULL, (void *) &bst_ovsdb_client, NULL))
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to create ovsdb client thread");
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to get current time");
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  ts.tv_sec += SB_OVSDB_MONITOR_INIT_TIME_OUT;
+
+  /* Wait unitl registartion with OVSDB-SERVER is successful/10 seconds */
+
+  while (((retVal = sem_timedwait(&monitor_init_done_sem, &ts)) == -1) && (errno == EINTR))
+  {
+    continue;
+  }
+
+  if (retVal == -1)
+  {
+    if (errno == ETIMEDOUT)
+    {
+      SB_OVSDB_DEBUG_PRINT ("Semaphore timed out, not able to initialize ovsdb monitor");
+    }
+    perror("sem_timedwait");
+    rv = BVIEW_STATUS_FAILURE;
+  } 
+  else
+  {
+    rv = BVIEW_STATUS_SUCCESS;   
+  } 
+  printf ("\r\n INIT DONE rv = %d\r\n", rv); 
+  return rv;
+}
+
+/*********************************************************************
+* @brief    OVSDB client and ovsdb bst data cache init
+*
+* @retval   BVIEW_STATUS_SUCCESS if ovsdb client and cache are
+*                                initialized successfully.
+* @retval   BVIEW_STATUS_FAILURE if initialization is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_infra_init()
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  /* Initialize ovsdb bst data cache */
+  if ((rv = bst_ovsdb_cache_init()) != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to initialize OVSDB BST cache");
+    return rv;
+  }
+
+  /* Initialize ovsdb bst data cache */
+  if ((rv = bst_ovsdb_client_init()) != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to initialize OVSDB BST cache");
+    return rv;
+  }
+
+
+  
+  return rv;
+}
+
+/*********************************************************************
+* @brief  BST feature configuration set function
+*
+* @param[in]   asic                  - unit
+* @param[in]   data                  - BST config structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if config set is failed.
+* @retval BVIEW_STATUS_SUCCESS           if config set is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_config_set (int asic, BVIEW_BST_CONFIG_t *data)
+{
+  BVIEW_STATUS   rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_OVSDB_CONFIG_DATA_t     config;
+  
+  /* Check validity of input data and asic validity check*/
+  BVIEW_BST_INPUT_VALID_CHECK (asic, data);
+
+  memset (&config, 0x00, sizeof (config));
+  /* enableStatsMonitoring can be either 'true' or 'false'*/
+  if (data->enableStatsMonitoring != true &&
+      data->enableStatsMonitoring != false) 
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }  
+ 
+  /* Check the validity of tracking mode*/
+  if (BVIEW_BST_MODE_CURRENT != data->mode &&
+      BVIEW_BST_MODE_PEAK != data->mode)
+  {
+     return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+  
+  config.bst_enable           = data->enableStatsMonitoring;
+  config.bst_tracking_mode    = (int) data->mode; 
+  config.periodic_collection  = data->enablePeriodicCollection;
+  config.collection_interval  = data->collectionPeriod;
+
+  rv = bst_ovsdb_bst_config_set(asic, &config);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Failed to set bst mode",asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Get BST configuration 
+*
+* @param[in]   asic                  - unit
+* @param[out]  data                  - BST config structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if config get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if config get is success.
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_config_get (int asic, 
+                                            BVIEW_BST_CONFIG_t *data)
+{
+  BVIEW_STATUS   rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_OVSDB_CONFIG_DATA_t     config;
+
+  /* Check validity of input data*/
+  if (data == NULL)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+  /*validate ASIC*/
+  if (SB_OVSDB_RV_ERROR(SB_OVSDB_API_UNIT_CHECK(asic)))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  rv = bst_ovsdb_bst_config_get(asic,
+                               &config);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Failed to get BST configuration",asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  data->enableStatsMonitoring = config.bst_enable;
+  data->mode = config.bst_tracking_mode;
+  data->enablePeriodicCollection = config.periodic_collection;
+  data->collectionPeriod =  config.collection_interval;
+
+ return  BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Complete ASIC Statistics Report
+*
+* @param[in]      asic               - unit
+* @param[out]     snapshot           - snapshot data structure
+* @param[out]     time               - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if snapshot get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if snapshot get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_snapshot_get (int asic, 
+                                 BVIEW_BST_ASIC_SNAPSHOT_DATA_t *snapshot, 
+                                 BVIEW_TIME_t *time)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  /* Check validity of input data*/
+  BVIEW_BST_INPUT_VALIDATE (asic, snapshot, time);
+
+  /* Obtain Device Statistics */ 
+  rv = sbplugin_ovsdb_bst_device_data_get (asic, &snapshot->device, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Ingress Port + Priority Groups Statistics */
+  rv = sbplugin_ovsdb_bst_ippg_data_get (asic, &snapshot->iPortPg, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Obtain Ingress Port + Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_ipsp_data_get (asic, &snapshot->iPortSp, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Ingress Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_isp_data_get (asic, &snapshot->iSp,time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Port + Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_epsp_data_get (asic, &snapshot->ePortSp, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_esp_data_get (asic, &snapshot->eSp, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+ 
+  /* Obtain Egress Egress Unicast Queues Statistics */
+  rv = sbplugin_ovsdb_bst_eucq_data_get (asic, &snapshot->eUcQ, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress Unicast Queue Groups Statistics */
+  rv = sbplugin_ovsdb_bst_eucqg_data_get (asic, &snapshot->eUcQg ,time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress Multicast Queues Statistics */
+  rv = sbplugin_ovsdb_bst_emcq_data_get (asic, &snapshot->eMcQ, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress CPU Queues Statistics */
+  rv = sbplugin_ovsdb_bst_cpuq_data_get (asic, &snapshot->cpqQ,time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress RQE Queues Statistics */
+  rv = sbplugin_ovsdb_bst_rqeq_data_get (asic, &snapshot->rqeQ, time);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+ 
+/*********************************************************************
+* @brief  Obtain Device Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - Device data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if device stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if device stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_device_data_get (int asic, 
+                                    BVIEW_BST_DEVICE_DATA_t *data, 
+                                    BVIEW_TIME_t *time)
+{
+  BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+  /* Check validity of input data*/
+  BVIEW_BST_INPUT_VALIDATE (asic, data, time); 
+
+  /* Get OVSDB cache*/
+  BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+  SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+
+  /* Update current local time*/
+  sbplugin_ovsdb_system_time_get (time);
+
+  /*Get total use-count is expressed in terms of buffers used in the device*/ 
+  data->bufferCount = p_cache->cache[asic].device.stat;
+
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+  return BVIEW_STATUS_SUCCESS; 
+}
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Priority Groups Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_pg data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ippg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ippg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ippg_data_get (int asic, 
+                              BVIEW_BST_INGRESS_PORT_PG_DATA_t *data, 
+                              BVIEW_TIME_t *time)
+{
+  unsigned int  port  =0; 
+  unsigned int  pg    =0; 
+  BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+  int         db_index = 0;
+
+  /* Check validity of input data*/
+  BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+  /* Update current local time*/
+  sbplugin_ovsdb_system_time_get (time);
+
+  /* Get OVSDB cache*/
+  BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+  SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+
+  /* Loop through all the ports*/
+  BVIEW_BST_PORT_ITER (asic, port)
+  {
+    /* Loop through all priority groups*/
+    BVIEW_BST_PG_ITER (asic, pg)
+    {
+      /*BST_Stat for each of the (Ingress Port, PG) UC plus MC 
+       * Shared use-counts in units of buffers.
+       */
+      BVIEW_OVSDB_BST_GET_DB_INDEX(asic, SB_OVSDB_BST_STAT_ID_PRI_GROUP_SHARED, 
+                                   port, pg, &db_index);
+      data->data[port - 1][pg].umShareBufferCount = 
+                     p_cache->cache[asic].iPGShared[db_index].stat;   
+
+      /* BST_Stat for each of the (Ingress Port, PG) UC plus MC 
+       * Headroom use-counts in units of buffers.
+       */
+      BVIEW_OVSDB_BST_GET_DB_INDEX(asic, SB_OVSDB_BST_STAT_ID_PRI_GROUP_HEADROOM, 
+                                   port, pg, &db_index);
+      data->data[port - 1][pg].umHeadroomBufferCount =
+                     p_cache->cache[asic].iPGHeadroom[db_index].stat;
+    } /* for (pg = 0; pg < BVI ....*/
+  } /* for (port = 0; port < BVIEW......*/
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+
+  return BVIEW_STATUS_SUCCESS;
+} 
+    
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_sp data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ipsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ipsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ipsp_data_get (int asic, 
+                                  BVIEW_BST_INGRESS_PORT_SP_DATA_t *data, 
+                                  BVIEW_TIME_t *time)
+{
+ unsigned int         port =0; 
+ unsigned int         sp =0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+ int         db_index = 0;
+ 
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+
+ /* Loop through all the ports*/
+ BVIEW_BST_PORT_ITER (asic, port)
+ {
+   /* BST_Stat for each of the 4 SPs Shared use-counts 
+    * associated with this Port in units of buffers.
+    */
+   BVIEW_BST_SP_ITER (asic,sp)
+   {
+     BVIEW_OVSDB_BST_GET_DB_INDEX(asic,SB_OVSDB_BST_STAT_ID_PORT_POOL, 
+                                  port, sp, &db_index);
+     data->data[port - 1][sp].umShareBufferCount =
+                           p_cache->cache[asic].iPortSP[db_index].stat;
+   }
+ }
+  
+ /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Ingress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_sp structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if isp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if isp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_isp_data_get (int asic, 
+                                 BVIEW_BST_INGRESS_SP_DATA_t *data, 
+                                 BVIEW_TIME_t *time)
+{
+ int                  sp =0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* BST_Stat for each of the 5 Ingress SPs Shared use-counts in units of buffers*/
+ BVIEW_BST_SP_ITER (asic, sp)
+ {
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic,SB_OVSDB_BST_STAT_ID_ING_POOL,
+                                 0, sp, &db_index);
+   data->data[sp].umShareBufferCount = 
+         p_cache->cache[asic].iSP[db_index].stat;
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+} 
+/*********************************************************************
+* @brief  Obtain Egress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_p_sp data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if epsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if epsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_epsp_data_get (int asic, 
+                                BVIEW_BST_EGRESS_PORT_SP_DATA_t *data, 
+                                BVIEW_TIME_t *time)
+{
+ unsigned int         port  =0;
+ unsigned int         sp =0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* Loop through all the ports*/
+ BVIEW_BST_PORT_ITER (asic, port)
+ {
+   BVIEW_BST_SP_ITER (asic, sp)
+   { 
+     /* Obtain Egress Port + Service Pools Statistics - U cast stats*/
+     BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_EGR_UCAST_PORT_SHARED,
+                                   port, sp, &db_index);
+     data->data[port - 1][sp].ucShareBufferCount =
+             p_cache->cache[asic].ePortSPucShare[db_index].stat;
+
+     /* Obtain Egress Port + Service Pools Statistics - Ucast+Mcast cast stats*/
+     BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_EGR_PORT_SHARED,
+                                   port, sp, &db_index)
+     data->data[port - 1][sp].umShareBufferCount = 
+             p_cache->cache[asic].ePortSPumShare[db_index].stat;
+   }
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_sp data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if esp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if esp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_esp_data_get  (int asic, 
+                               BVIEW_BST_EGRESS_SP_DATA_t *data, 
+                               BVIEW_TIME_t *time)
+{
+ unsigned int         sp =0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* Loop through all the ports*/
+ BVIEW_BST_SP_ITER (asic, sp)
+ {
+   /* BST_Stat for each of the 4 Egress SPs Shared use-counts in units of buffers.
+    * This use-count includes both UC and MC buffers.
+    */
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_EGR_POOL,
+                                 0, sp, &db_index);
+   data->data[sp].umShareBufferCount = 
+                    p_cache->cache[asic].eSPumShare[db_index].stat; 
+   /*BST_Threshold for each of the 4 Egress SP MC Share use-counts in units of buffers.*/
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_EGR_MCAST_POOL,
+                                 0, sp, &db_index);
+   data->data[sp].mcShareBufferCount = 
+                    p_cache->cache[asic].eSPmcShare[db_index].stat;
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_q data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucq_data_get (int asic, 
+                              BVIEW_BST_EGRESS_UC_QUEUE_DATA_t *data, 
+                              BVIEW_TIME_t *time)
+{
+ unsigned int         cosq = 0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+  /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* Iterate COSQ*/
+ BVIEW_BST_UC_QUEUE_ITER (asic, cosq) 
+ {
+   /*BST_Stat for the UC queue total use-counts in units of buffers.*/
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_UCAST,
+                                 0, cosq, &db_index);
+   data->data[cosq].ucBufferCount = 
+                 p_cache->cache[asic].ucQ[db_index].stat;
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+}
+   
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queue Groups Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_qg data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucqg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucqg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucqg_data_get (int asic, 
+                        BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t *data, 
+                        BVIEW_TIME_t *time)
+{
+ unsigned int         cosq = 0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* Loop through all the UC_QUEUE_GROUPS*/
+ BVIEW_BST_UC_QUEUE_GRP_ITER (asic, cosq)
+ {
+   /* BST_Stat for each of the 128 Egress Unicast Queue-Group 
+    * Total use-counts in units of buffers.
+    */
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_UCAST_GROUP,
+                                 0, cosq, &db_index);
+   data->data[cosq].ucBufferCount = 
+            p_cache->cache[asic].eUCqGroup[db_index].stat;
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Egress Multicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_mc_q data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if emcq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if emcq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_emcq_data_get (int asic, 
+                              BVIEW_BST_EGRESS_MC_QUEUE_DATA_t *data, 
+                              BVIEW_TIME_t *time)
+{
+ unsigned int         cosq =0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+ /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* Loop through cos queue max per port*/
+ BVIEW_BST_MC_QUEUE_ITER (asic, cosq)
+ {
+     /*BST_Stat for the MC queue total use-counts in units of buffers.*/
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_MCAST,
+                                 0, cosq, &db_index);
+   data->data[cosq].mcBufferCount = 
+          p_cache->cache[asic].mcQ[db_index].stat;
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Egress CPU Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - CPU queue data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if CPU stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if CPU stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_cpuq_data_get (int asic, 
+                             BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t *data, 
+                             BVIEW_TIME_t *time)
+{
+ unsigned int         cosq = 0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* iterate through Maximum CPU cosqs*/
+ BVIEW_BST_CPU_QUEUE_ITER (asic, cosq)
+ {
+   /*The BST_Threshold for the Egress CPU queues in units of buffers.*/
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_CPU_QUEUE,
+                                 0, cosq, &db_index);
+   data->data[cosq].cpuBufferCount = 
+              p_cache->cache[asic].eCPU[db_index].stat;
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Egress RQE Queues Statistics 
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - RQE data data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if RQE stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if RQE stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_rqeq_data_get (int asic, 
+                                   BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t *data, 
+                                   BVIEW_TIME_t *time) 
+{
+ unsigned int         cosq = 0;
+ int         db_index = 0;
+ BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+ /* Check validity of input data*/
+ BVIEW_BST_INPUT_VALIDATE (asic, data, time);
+
+ /* Update current local time*/
+ sbplugin_ovsdb_system_time_get (time);
+
+ /* Get OVSDB cache*/
+ BVIEW_OVSDB_BST_CACHE_GET (p_cache);
+  /* Acquire read lock*/
+ SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+ /* Loop through all the RQE queues*/
+ BVIEW_BST_RQE_QUEUE_ITER (asic, cosq)
+ {
+   /* BST_Stat for each of the 11 RQE queues total use-counts in units of buffers.*/
+   BVIEW_OVSDB_BST_GET_DB_INDEX (asic, SB_OVSDB_BST_STAT_ID_RQE_QUEUE,
+                                 0 ,cosq, &db_index);
+   data->data[cosq].rqeBufferCount = 
+           p_cache->cache[asic].rqe[db_index].stat;
+ }
+  /* Release lock */
+ SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Device Statistics
+*
+* @param[in]  asic               - unit
+* @param[in]  thres              - Device threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_device_threshold_set (int asic, 
+                                          BVIEW_BST_DEVICE_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS                rv  = BVIEW_STATUS_SUCCESS;
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_DEVICE_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+  rv = bst_ovsdb_threshold_set(asic, 0, 0, SB_OVSDB_BST_STAT_ID_DEVICE, thres->threshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Device Stat:Failed to set Threshold",asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for  
+*           Ingress Port + Priority Groups Statistics
+*
+* @param[in]  asic              - unit
+* @param[in]  port              - port
+* @param[in]  pg                - Priority Group
+* @param[in]  thres             - Threshold structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*                                                             
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ippg_threshold_set (int asic, int port, int pg, 
+                                     BVIEW_BST_INGRESS_PORT_PG_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_IPPG_SHRD_THRESHOLD_CHECK (thres) ||
+      BVIEW_BST_IPPG_HDRM_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+  /* set threshold for shared buffer stats*/
+  rv = bst_ovsdb_threshold_set (asic, port, pg, 
+                                SB_OVSDB_BST_STAT_ID_PRI_GROUP_SHARED, thres->umShareThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Ingress Shared (Port, PG) PG(%d) Port(%d):Failed to set Threshold", asic,pg,port);
+    return BVIEW_STATUS_FAILURE;
+  }
+ /* set threshold for headroom buffer stats*/
+  rv = bst_ovsdb_threshold_set (asic, port, pg, 
+                                SB_OVSDB_BST_STAT_ID_PRI_GROUP_HEADROOM, thres->umHeadroomThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Ingress Headroom (Port, PG) PG(%d) Port(%d):Failed to set Threshold", asic,pg,port);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Ingress Port + Service Pools 
+*           Statistics
+*
+* @param[in] asic                     - unit
+* @param[in] port                     - port
+* @param[in] sp                       - service pool
+* @param[in] thres                    - Threshold data structure
+*                                                    
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ipsp_threshold_set (int asic, int port, int sp, 
+                                      BVIEW_BST_INGRESS_PORT_SP_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_IPSP_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+ 
+  /*Set profile configuration for Ingress Port + Service Pools*/
+  rv = bst_ovsdb_threshold_set (asic, port, sp, 
+                                SB_OVSDB_BST_STAT_ID_PORT_POOL, thres->umShareThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC (%d) Ingress(Port, SP) SP(%d) Port(%d):Failed to set Threshold", asic,sp,port);
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Ingress Service Pools 
+*           Statistics
+*
+* @param[in] asic                       - unit
+* @param[in] sp                         - service pool 
+* @param[in] thres                      - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_isp_threshold_set (int asic, 
+                                     int sp, 
+                                     BVIEW_BST_INGRESS_SP_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_ISP_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+ /* The BST_Threshold for the (Ingress Port, SP) UC plus MC shared use-count.*/
+  rv = bst_ovsdb_threshold_set (asic, 0, sp, 
+                                SB_OVSDB_BST_STAT_ID_ING_POOL, thres->umShareThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Ingress SP(%d):Failed to set Threshold", asic,sp);
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set Profile configuration for Egress Port + Service Pools 
+*           Statistics
+*
+* @param[in] asic                       - unit
+* @param[in] port                       - port
+* @param[in] sp                         - service pool
+* @param[in] thres                      - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_epsp_threshold_set (int asic, 
+                                      int port, int sp, 
+                                      BVIEW_BST_EGRESS_PORT_SP_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;  
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_EPSP_UC_THRESHOLD_CHECK (thres) ||
+      BVIEW_BST_EPSP_UM_THRESHOLD_CHECK (thres) || 
+      BVIEW_BST_EPSP_MC_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+  /* The BST_Threshold for the Egress Per (Port, SP) 
+   * UC shared use-count in units of 8 buffers
+   */
+  rv = bst_ovsdb_threshold_set (asic, port, sp, 
+                          SB_OVSDB_BST_STAT_ID_EGR_UCAST_PORT_SHARED, thres->ucShareThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Egress UC(Port,SP) SP(%d) Port(%d):Failed to set Threshold", asic,sp, port);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+ /* The BST_Threshold for the Egress Per (Port, SP) 
+  * MC/UC+MC shared use-count in units of buffers.
+  */
+  rv = bst_ovsdb_threshold_set (asic, port, sp, 
+                               SB_OVSDB_BST_STAT_ID_EGR_PORT_SHARED, thres->umShareThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Egress UC+MC (Port,SP) SP(%d) Port(%d):Failed to set Threshold", asic,sp, port);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Service Pools Statistics
+*
+* @param[in] asic                        - unit
+* @param[in] sp                          - service pool
+* @param[in] thres                       - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_esp_threshold_set (int asic, 
+                                     int sp, 
+                                     BVIEW_BST_EGRESS_SP_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_E_SP_UM_THRESHOLD_CHECK (thres) || 
+      BVIEW_BST_E_SP_MC_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+  /* BST_Threshold for each of the 4 Egress SPs Shared use-counts in units of buffers.*/
+  rv = bst_ovsdb_threshold_set (asic, 0, sp, SB_OVSDB_BST_STAT_ID_EGR_POOL, thres->umShareThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Egress SP (%d):Failed to set Threshold", asic,sp);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* BST_Threshold for each of the 4 Egress SPs Shared use-counts in units of buffers.*/
+  rv = bst_ovsdb_threshold_set (asic, 0, sp, SB_OVSDB_BST_STAT_ID_EGR_MCAST_POOL, thres->mcShareThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Egress SP (%d):Failed to set Threshold", asic,sp);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Unicast Queues 
+*           Statistics
+*
+* @param[in] asic                        - unit
+* @param[in] ucQueue                     - uc queue
+* @param[in] thres                       - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucq_threshold_set (int asic, 
+                                      int ucQueue, 
+                              BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;
+  int                    port = 0, cosq = 0;
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_E_UC_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+ 
+  /*  The BST_Threshold for the Egress UC Queues.*/ 
+  rv = bst_ovsdb_threshold_set (asic, port, cosq, 
+                                SB_OVSDB_BST_STAT_ID_UCAST, thres->ucBufferThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Ucast Queue (%d):Failed to set Threshold", asic,ucQueue);
+    return BVIEW_STATUS_FAILURE;
+  }
+  
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Unicast Queue Groups 
+*           Statistics 
+*
+* @param[in]asic                          -unit
+* @param[in]ucQueueGrp                    -uc queue group 
+* @param[in]thres                         -Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucqg_threshold_set (int asic, 
+                                       int ucQueueGrp, 
+                                       BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS; 
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL ||
+      BVIEW_BST_E_UC_GRP_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+  /*The BST_Threshold for the Egress UC Queue-Group */
+  rv = bst_ovsdb_threshold_set (asic, 0, ucQueueGrp, 
+                                SB_OVSDB_BST_STAT_ID_UCAST_GROUP, thres->ucBufferThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Ucast Queue Group (%d):Failed to set Threshold", asic,ucQueueGrp);
+    return BVIEW_STATUS_FAILURE;
+  }
+  
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Multicast Queues 
+*           Statistics
+*
+* @param[in] asic                     - unit
+* @param[in] mcQueue                  - mcQueue
+* @param[in] thres                    - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_emcq_threshold_set (int asic, 
+                                      int mcQueue, 
+                                      BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS; 
+  int                    port = 0, cosq = 0;
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_E_MC_THRESHOLD_CHECK (thres) ||
+      BVIEW_BST_E_MC_QUEUE_THRESHOLD_CHECK (thres))
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+  rv = bst_ovsdb_threshold_set (asic, port, cosq, 
+                                SB_OVSDB_BST_STAT_ID_MCAST, thres->mcBufferThreshold);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) Mcast Queue (%d):Failed to set Threshold", asic,mcQueue);
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Egress CPU Queues 
+*           Statistics
+*
+* @param[in] asic                        - unit
+* @param[in] cpuQueue                    - cpuQueue
+* @param[in] thres                       - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_cpuq_threshold_set (int asic, 
+                                      int cpuQueue, 
+                                      BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;
+  unsigned int port = 0;
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_E_CPU_THRESHOLD_CHECK (thres))
+     /* BVIEW_BST_E_CPU_QUEUE_THRESHOLD_CHECK (thres))*/
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+
+  rv = bst_ovsdb_threshold_set (asic, port, cpuQueue, 
+                                SB_OVSDB_BST_STAT_ID_CPU_QUEUE, thres->cpuBufferThreshold);
+  if (SB_OVSDB_RV_ERROR (rv))
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) CPU Queue (%d):Failed to set Threshold", asic,cpuQueue);
+    return BVIEW_STATUS_FAILURE;
+  }
+  
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Egress RQE Queues 
+*           Statistics
+*
+* @param[in]    asic                   - unit
+* @param[in]    rqeQueue               - rqeQueue
+* @param[out]   thres                  - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is succes.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_rqeq_threshold_set (int asic, 
+                                     int rqeQueue, 
+                                     BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_t *thres)
+{
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;
+
+  /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  if (thres == NULL || 
+      BVIEW_BST_E_RQE_THRESHOLD_CHECK (thres)) 
+    /*  BVIEW_BST_E_RQE_QUEUE_THRESHOLD_CHECK (thres))*/
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  /* Get Threshold configuration for RQE queues*/ 
+  rv = bst_ovsdb_threshold_set (asic, 0, rqeQueue, 
+                      SB_OVSDB_BST_STAT_ID_RQE_QUEUE, thres->rqeBufferThreshold);
+  if (SB_OVSDB_RV_ERROR (rv))
+  {
+    SB_OVSDB_DEBUG_PRINT (
+                "BST:ASIC(%d) RQE Queue (%d):Failed to set Threshold", asic,rqeQueue);
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Clear stats
+*           
+* @param[in]   asic                                    - unit
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if clear stats is succes.
+* @retval BVIEW_STATUS_SUCCESS           if clear stats is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_bst_clear_stats(int asic)
+{
+  return BVIEW_STATUS_SUCCESS; 
+}
+
+/*********************************************************************
+* @brief  Restore threshold configuration 
+*
+* @param   asic                                    - unit
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if restore is succes.
+* @retval BVIEW_STATUS_SUCCESS           if restore set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_bst_clear_thresholds  (int asic)
+{
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Register hw trigger callback
+*
+* @param   asic                              - unit
+* @param   callback                          - function to be called 
+*                                              when trigger happens
+* @param   cookie                            - user data
+* 
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if restore is succes.
+* @retval BVIEW_STATUS_SUCCESS           if restore set is failed.
+*
+* @notes    callback will be executed in driver thread so post the data 
+*           to respective task.
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_bst_register_trigger (int asic, 
+                                        BVIEW_BST_TRIGGER_CALLBACK_t callback, 
+                                        void *cookie)
+{
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Get snapshot of all thresholds configured
+*
+*
+* @param  [in]  asic                         - unit
+* @param  [out] data            - Threshold snapshot
+*                                              data structure
+* @param  [out] time                         - Time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if snapshot is succes.
+* @retval BVIEW_STATUS_SUCCESS           if snapshot set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_threshold_get (int asic, 
+                              BVIEW_BST_ASIC_SNAPSHOT_DATA_t *data,
+                              BVIEW_TIME_t *time)
+{
+  unsigned int           port = 0;
+  unsigned int           index =0;
+  BVIEW_STATUS           rv = BVIEW_STATUS_SUCCESS;                   
+
+   /*validate ASIC*/
+  SB_OVSDB_VALID_UNIT_CHECK (asic);
+
+  /* Check validity of input data*/
+  SB_OVSDB_NULLPTR_CHECK (data, BVIEW_STATUS_INVALID_PARAMETER);
+
+   /* Update current local time*/
+  sbplugin_ovsdb_system_time_get (time);
+
+  /* Device wide threshold configuration*/
+  rv = bst_ovsdb_threshold_get(asic, 0, 0, 
+                               SB_OVSDB_BST_STAT_ID_DEVICE, &data->device.bufferCount);
+  if (BVIEW_STATUS_SUCCESS != rv)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Get port based thresholds*/ 
+  BVIEW_BST_PORT_ITER (asic, port)
+  {
+    BVIEW_BST_PG_ITER (asic, index)
+    { 
+      /* Get threshold configuration of The BST_Threshold for the (Ingress Port, PG) 
+       * UC plus MC Shared use-count in units of buffers.
+       */
+      rv = bst_ovsdb_threshold_get (asic, port, index, 
+                                    SB_OVSDB_BST_STAT_ID_PRI_GROUP_SHARED, 
+                                    &data->iPortPg.data[port - 1][index].umShareBufferCount);
+      if (BVIEW_STATUS_SUCCESS != rv)
+      {
+        return BVIEW_STATUS_FAILURE;
+      }
+      /* Get threshold for headroom The BST_Threshold for the (Ingress Port, PG) 
+       * UC plus MC Headroom use-count in units of buffers
+       */
+      rv = bst_ovsdb_threshold_get (asic, port, index, 
+                                    SB_OVSDB_BST_STAT_ID_PRI_GROUP_HEADROOM, 
+                                    &data->iPortPg.data[port - 1][index].umHeadroomBufferCount);
+      if (BVIEW_STATUS_SUCCESS != rv)
+      {
+        return BVIEW_STATUS_FAILURE;
+      }
+    }
+    
+    /*Get threshold configuration for The BST_Threshold for the (Ingress Port, SP) 
+     * UC plus MC shared use-count in units of buffers.
+     */  
+    BVIEW_BST_SP_ITER (asic, index)
+    {
+      rv = bst_ovsdb_threshold_get(asic, port, index, 
+                                   SB_OVSDB_BST_STAT_ID_PORT_POOL,
+                                   &data->iPortSp.data[port - 1][index].umShareBufferCount);
+      if (BVIEW_STATUS_SUCCESS != rv)
+      {
+        return BVIEW_STATUS_FAILURE;
+      }
+    }
+
+    BVIEW_BST_SP_ITER (asic, index)
+    {
+      /* The BST_Threshold for the Egress Per (Port, SP) 
+       * UC shared use-count in units of 8 buffers */
+      rv = bst_ovsdb_threshold_get (asic, port, index, 
+                                    SB_OVSDB_BST_STAT_ID_EGR_UCAST_PORT_SHARED, 
+                                    &data->ePortSp.data[port - 1][index].ucShareBufferCount);
+      if (BVIEW_STATUS_SUCCESS != rv)
+      {
+        return BVIEW_STATUS_FAILURE;
+      }
+
+      /* Get threshold configuration for egress based port shared buffers*/
+      rv = bst_ovsdb_threshold_get (asic, port, index, 
+                                    SB_OVSDB_BST_STAT_ID_EGR_PORT_SHARED, 
+                                    &data->ePortSp.data[port - 1][index].umShareBufferCount);
+      if (BVIEW_STATUS_SUCCESS != rv)
+      {
+        return BVIEW_STATUS_FAILURE;
+      }
+    }
+  }
+ 
+  /* Get threshold configuration for The BST_Threshold for the Egress MC Queues in units of buffers.*/
+  BVIEW_BST_MC_QUEUE_ITER (asic,index)
+  {
+    rv = bst_ovsdb_threshold_get (asic, port, index,
+                                    SB_OVSDB_BST_STAT_ID_MCAST,
+                                    &data->eMcQ.data[index].mcBufferCount);
+    if (SB_OVSDB_RV_ERROR (rv))
+    {
+        return BVIEW_STATUS_FAILURE;
+    }
+    data->eMcQ.data[index].port = 0;
+  }
+    /* Get threshold configuration for The BST_Threshold for the Egress UC Queues in units of 8 buffers.*/
+  BVIEW_BST_UC_QUEUE_ITER (asic,index)
+  {
+    rv = bst_ovsdb_threshold_get (asic, port, index,
+          SB_OVSDB_BST_STAT_ID_UCAST, &data->eUcQ.data[index].ucBufferCount);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+        return BVIEW_STATUS_FAILURE;
+    }
+    data->eUcQ.data[index].port = 0;
+  }
+ 
+  BVIEW_BST_SP_ITER (asic, index)
+  {
+    /*  BST_Threshold for each of the 4 Egress SPs Shared use-counts in units of buffers.*/
+    rv = bst_ovsdb_threshold_get (asic, 0, index, 
+            SB_OVSDB_BST_STAT_ID_EGR_POOL, &data->eSp.data[index].umShareBufferCount);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      return BVIEW_STATUS_FAILURE;
+    }
+
+    /*  BST_Threshold for each of the 4 Egress SPs Shared use-counts in units of buffers.*/
+    rv = bst_ovsdb_threshold_get (asic, 0, index, 
+            SB_OVSDB_BST_STAT_ID_EGR_MCAST_POOL, &data->eSp.data[index].mcShareBufferCount);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      return BVIEW_STATUS_FAILURE;
+    }
+  }
+
+  /* Get threshold configuration for The BST_Threshold for the Ingress 
+   * SP UC plus MC use-count in units of buffers.
+  */
+  BVIEW_BST_SP_ITER (asic, index)
+  {
+    rv = bst_ovsdb_threshold_get (asic, 0, index, 
+              SB_OVSDB_BST_STAT_ID_ING_POOL, &data->iSp.data[index].umShareBufferCount);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      return BVIEW_STATUS_FAILURE;
+    }
+  }
+
+  /* Get thresholds for The BST_Threshold for the Egress CPU queues in units of buffers*/
+  BVIEW_BST_CPU_QUEUE_ITER (asic, index)
+  {
+    rv = bst_ovsdb_threshold_get (asic, port, index, 
+                   SB_OVSDB_BST_STAT_ID_CPU_QUEUE, &data->cpqQ.data[index].cpuBufferCount);
+    if (BVIEW_STATUS_SUCCESS != rv)
+    {
+      return BVIEW_STATUS_FAILURE;
+    }
+  }
+
+  /* Get Thresholds for BST_Threshold for each of the 11 RQE queues 
+   * total use-counts in units of buffers.
+  */
+  BVIEW_BST_RQE_QUEUE_ITER (asic, index)
+  {
+    rv = bst_ovsdb_threshold_get (asic, 0, index, SB_OVSDB_BST_STAT_ID_RQE_QUEUE, 
+                                  &data->rqeQ.data[index].rqeBufferCount);
+    if (SB_OVSDB_RV_ERROR (rv))
+    {
+      return BVIEW_STATUS_FAILURE;
+    }
+  } 
+
+  /* Get Thresholds for BST_Threshold for each of the 128 Egress Unicast queue groups*/
+  BVIEW_BST_UC_QUEUE_GRP_ITER (asic, index)
+  {
+    rv = bst_ovsdb_threshold_get (asic, 0, index, 
+                                 SB_OVSDB_BST_STAT_ID_UCAST_GROUP, &data->eUcQg.data[index].ucBufferCount);
+    if (SB_OVSDB_RV_ERROR (rv))
+    {
+      return BVIEW_STATUS_FAILURE;
+    }
+  }
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain default buffer settings.
+*
+* @param[in]      asic               - unit
+* @param[out]     snapshot           - snapshot data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if snapshot get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if snapshot get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_snapshot_get (int asic,
+                                 BVIEW_BST_ASIC_SNAPSHOT_DATA_t *snapshot)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  /* Check validity of input data*/
+  if (NULL == snapshot)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Obtain Device Statistics */
+  rv = sbplugin_ovsdb_bst_default_device_data_get (asic, &snapshot->device);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Ingress Port + Priority Groups Statistics */
+  rv = sbplugin_ovsdb_bst_default_ippg_data_get (asic, &snapshot->iPortPg);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Obtain Ingress Port + Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_default_ipsp_data_get (asic, &snapshot->iPortSp);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Ingress Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_default_isp_data_get (asic, &snapshot->iSp);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Port + Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_default_epsp_data_get (asic, &snapshot->ePortSp);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Service Pools Statistics */
+  rv = sbplugin_ovsdb_bst_default_esp_data_get (asic, &snapshot->eSp);
+                                                                                
+ if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress Unicast Queues Statistics */
+  rv = sbplugin_ovsdb_bst_default_eucq_data_get (asic, &snapshot->eUcQ);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress Unicast Queue Groups Statistics */
+  rv = sbplugin_ovsdb_bst_default_eucqg_data_get (asic, &snapshot->eUcQg);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress Multicast Queues Statistics */
+  rv = sbplugin_ovsdb_bst_default_emcq_data_get (asic, &snapshot->eMcQ);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress CPU Queues Statistics */
+  rv = sbplugin_ovsdb_bst_default_cpuq_data_get (asic, &snapshot->cpqQ);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Obtain Egress Egress RQE Queues Statistics */
+  rv = sbplugin_ovsdb_bst_default_rqeq_data_get (asic, &snapshot->rqeQ);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain default Device Stat settings
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - Device data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_SUCCESS           if device stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_device_data_get (int asic,
+                                    BVIEW_BST_DEVICE_DATA_t *data)
+{
+
+ /* Check validity of input data*/
+ if (NULL == data)
+   return BVIEW_STATUS_INVALID_PARAMETER;
+
+ /*Get the device stat default values*/
+ data->bufferCount = SB_BRCM_BST_STAT_ID_DEVICE_DEFAULT;
+ return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Priority Groups Statistics default vals
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_pg data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ippg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ippg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_ippg_data_get (int asic,
+                              BVIEW_BST_INGRESS_PORT_PG_DATA_t *data)
+{
+  BVIEW_STATUS  rv    = BVIEW_STATUS_SUCCESS;
+  unsigned int  port  =0;
+  unsigned int  pg    =0;
+
+  /* Check validity of input data*/
+ if (NULL == data)
+   return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Loop through all the ports*/
+  BVIEW_BST_PORT_ITER (asic, port)
+  {
+    /* Loop through all priority groups*/
+    BVIEW_BST_PG_ITER (asic,pg)
+    {
+      /*BST_Stat for each of the (Ingress Port, PG) UC plus MC
+       * Shared use-counts in units of buffers.
+       */
+      data->data[port - 1][pg].umShareBufferCount = SB_BRCM_BST_STAT_ID_PRI_GROUP_SHARED_DEFAULT;
+
+      /* BST_Stat for each of the (Ingress Port, PG) UC plus MC
+       * Headroom use-counts in units of buffers.
+       */
+      data->data[port - 1][pg].umHeadroomBufferCount = SB_BRCM_BST_STAT_ID_PRI_GROUP_HEADROOM_DEFAULT;
+    } /* for (pg = 0; pg < BVI ....*/
+  } /* for (port = 0; port < BVIEW......*/
+  return rv;
+}
+
+
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_sp data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ipsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ipsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_ipsp_data_get (int asic,
+                                  BVIEW_BST_INGRESS_PORT_SP_DATA_t *data)
+{
+  unsigned int port =0;
+  unsigned int sp =0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Loop through all the ports*/
+  BVIEW_BST_PORT_ITER (asic, port)
+  {
+    /* BST_Stat for each of the 4 SPs Shared use-counts
+     * associated with this Port in units of buffers.
+     */
+    BVIEW_BST_SP_ITER (asic, sp)
+    {
+      data->data[port - 1][sp].umShareBufferCount = SB_BRCM_BST_STAT_ID_PORT_POOL_DEFAULT;
+    }
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
+/*********************************************************************
+* @brief  Obtain Ingress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_sp structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if isp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if isp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_isp_data_get (int asic,
+                                 BVIEW_BST_INGRESS_SP_DATA_t *data)
+{
+  int sp = 0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* BST_Stat for each of the 5 Ingress SPs Shared use-counts in units of buffers*/
+  BVIEW_BST_SP_ITER (asic, sp)
+  {
+    data->data[sp].umShareBufferCount = SB_BRCM_BST_STAT_ID_ING_POOL_DEFAULT;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_p_sp data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if epsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if epsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_epsp_data_get (int asic,
+                                BVIEW_BST_EGRESS_PORT_SP_DATA_t *data)
+{
+  unsigned int port  =0;
+  unsigned int sp =0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Loop through all the ports*/
+  BVIEW_BST_PORT_ITER (asic, port)
+  {
+    BVIEW_BST_SP_ITER (asic, sp)
+    {
+      /* Obtain Egress Port + Service Pools Statistics - U cast stats*/
+      data->data[port - 1][sp].ucShareBufferCount = SB_BRCM_BST_STAT_ID_EGR_UCAST_PORT_SHARED_DEFAULT;
+
+      /* Obtain Egress Port + Service Pools Statistics - Ucast+Mcast cast stats*/
+      data->data[port - 1][sp].umShareBufferCount = SB_BRCM_BST_STAT_ID_EGR_PORT_SHARED_DEFAULT;
+    }
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+/*********************************************************************
+* @brief  Obtain Egress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_sp data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if esp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if esp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_esp_data_get  (int asic,
+                               BVIEW_BST_EGRESS_SP_DATA_t *data)
+{
+  unsigned int  sp =0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Loop through all the ports*/
+  BVIEW_BST_SP_ITER (asic, sp)
+  {
+    /* BST_Stat for each of the 4 Egress SPs Shared use-counts in units of buffers.
+     * This use-count includes both UC and MC buffers.
+     */
+    data->data[sp].umShareBufferCount = SB_BRCM_BST_STAT_ID_EGR_POOL_DEFAULT;
+
+    /*BST_Threshold for each of the 4 Egress SP MC Shared use-counts in units of buffers.*/
+    data->data[sp].mcShareBufferCount = SB_BRCM_BST_STAT_ID_EGR_MCAST_POOL_DEFAULT;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_q data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_eucq_data_get (int asic,
+                              BVIEW_BST_EGRESS_UC_QUEUE_DATA_t *data)
+{
+  unsigned int cosq = 0;
+  unsigned int port  =0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  BVIEW_BST_PORT_ITER (asic, port)
+  {
+    /* Iterate COSQ*/
+    BVIEW_BST_ITER (cosq,BVIEW_BST_NUM_COS_PORT)
+    {
+      /*BST_Stat for the UC queue total use-counts in units of buffers.*/
+      data->data[((port - 1) * BVIEW_BST_NUM_COS_PORT) + cosq].ucBufferCount = SB_BRCM_BST_STAT_ID_UCAST_DEFAULT;
+    }
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queue Groups Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_qg data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucqg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucqg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_eucqg_data_get (int asic,
+                        BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t *data)
+{
+  unsigned int cosq = 0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Loop through all the UC_QUEUE_GROUPS*/
+  BVIEW_BST_ITER (cosq, BVIEW_ASIC_MAX_UC_QUEUE_GROUPS)
+  {
+    /* BST_Stat for each of the 128 Egress Unicast Queue-Group
+     * Total use-counts in units of buffers.
+     */
+    data->data[cosq].ucBufferCount = SB_BRCM_BST_STAT_ID_UCAST_GROUP_DEFAULT;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+/*********************************************************************
+* @brief  Obtain Egress Egress Multicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_mc_q data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if emcq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if emcq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_emcq_data_get (int asic,
+                              BVIEW_BST_EGRESS_MC_QUEUE_DATA_t *data)
+{
+  unsigned int  cosq =0;
+  unsigned int port  =0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Loop through all the ports*/
+  BVIEW_BST_PORT_ITER (asic, port)
+  {
+    /* Loop through cos queue max per port*/
+    BVIEW_BST_ITER (cosq, BVIEW_BST_NUM_COS_PORT)
+    {
+      /*BST_Stat for the MC queue total use-counts in units of buffers.*/
+      data->data[((port -1) * BVIEW_BST_NUM_COS_PORT) + cosq].mcBufferCount = SB_BRCM_BST_STAT_ID_MCAST_DEFAULT;
+    }
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
+/*********************************************************************
+* @brief  Obtain Egress Egress CPU Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - CPU queue data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if CPU stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if CPU stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_cpuq_data_get (int asic,
+                             BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t *data)
+{
+  unsigned int cosq = 0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* iterate through Maximum CPU cosqs*/
+  BVIEW_BST_ITER (cosq, BVIEW_ASIC_MAX_CPU_QUEUES)
+  {
+    /*The BST_Threshold for the Egress CPU queues in units of buffers.*/
+    data->data[cosq].cpuBufferCount = SB_BRCM_BST_STAT_ID_CPU_DEFAULT;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
+/*********************************************************************
+* @brief  Obtain Egress Egress RQE Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - RQE data data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if RQE stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if RQE stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_rqeq_data_get (int asic,
+                                   BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t *data)
+{
+  unsigned int cosq = 0;
+
+  /* Check validity of input data*/
+  if (NULL == data)
+    return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Loop through all the RQE queues*/
+  BVIEW_BST_ITER (cosq, BVIEW_ASIC_MAX_RQE_QUEUES)
+  {
+    /* BST_Stat for each of the 11 RQE queues total use-counts in units of buffers.*/
+    data->data[cosq].rqeBufferCount = SB_BRCM_BST_STAT_ID_RQE_QUEUE_DEFAULT;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+                                                                                        
+#if 0
+/*********************************************************************
+* @brief  callback function to process Hw trigers
+*
+*
+* @param  [in]  asic                         - unit
+* @param  [in]  event                        - Event
+* @param  [bid] bid                          - BST stat 
+* @param  [port] Port                        - Port ID
+* @param  [cosq] COSQ                        - cosq
+* @param  [in,out] cookie                    - User data 
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if HW trigger process is success.
+* @retval BVIEW_STATUS_SUCCESS           if failed to handle trigger.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_callback (int asic, SB_OVSDB_SWITCH_EVENT_t event, 
+                       int bid, int port, int cosq, void *cookie)
+{
+  return BVIEW_STATUS_SUCCESS;
+}
+
+#endif
+/*********************************************************************
+* @brief  OVSDB BST feature init
+*
+* @param[in,out]  ovsdbBstFeat     - BST feature data structure
+*
+* @retval   BVIEW_STATUS_SUCCESS if BST feature is
+*                                initialized successfully.
+* @retval   BVIEW_STATUS_FAILURE if initialization is failed.
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_init (BVIEW_SB_BST_FEATURE_t *ovsdbBstFeat)
+{
+  BVIEW_STATUS      rv  = BVIEW_STATUS_SUCCESS;
+
+  /* NULL Pointer check*/
+  SB_OVSDB_NULLPTR_CHECK (ovsdbBstFeat, BVIEW_STATUS_INVALID_PARAMETER);
+
+  /* Initialize BST functions*/
+  ovsdbBstFeat->feature.featureId           = BVIEW_FEATURE_BST;
+  ovsdbBstFeat->feature.supportedAsicMask   = BVIEW_BST_SUPPORT_MASK;
+  ovsdbBstFeat->bst_config_set_cb           = sbplugin_ovsdb_bst_config_set;
+  ovsdbBstFeat->bst_config_get_cb           = sbplugin_ovsdb_bst_config_get;
+  ovsdbBstFeat->bst_snapshot_get_cb         = sbplugin_ovsdb_bst_snapshot_get;
+  ovsdbBstFeat->bst_device_data_get_cb      = sbplugin_ovsdb_bst_device_data_get;
+  ovsdbBstFeat->bst_ippg_data_get_cb        = sbplugin_ovsdb_bst_ippg_data_get;
+  ovsdbBstFeat->bst_ipsp_data_get_cb        = sbplugin_ovsdb_bst_ipsp_data_get;
+  ovsdbBstFeat->bst_isp_data_get_cb         = sbplugin_ovsdb_bst_isp_data_get;
+  ovsdbBstFeat->bst_epsp_data_get_cb        = sbplugin_ovsdb_bst_epsp_data_get;
+  ovsdbBstFeat->bst_esp_data_get_cb         = sbplugin_ovsdb_bst_esp_data_get;
+  ovsdbBstFeat->bst_eucq_data_get_cb        = sbplugin_ovsdb_bst_eucq_data_get;
+  ovsdbBstFeat->bst_eucqg_data_get_cb       = sbplugin_ovsdb_bst_eucqg_data_get;
+  ovsdbBstFeat->bst_emcq_data_get_cb        = sbplugin_ovsdb_bst_emcq_data_get;
+  ovsdbBstFeat->bst_cpuq_data_get_cb        = sbplugin_ovsdb_bst_cpuq_data_get;
+  ovsdbBstFeat->bst_rqeq_data_get_cb        = sbplugin_ovsdb_bst_rqeq_data_get;
+  ovsdbBstFeat->bst_device_threshold_set_cb = sbplugin_ovsdb_bst_device_threshold_set;
+  ovsdbBstFeat->bst_ippg_threshold_set_cb   = sbplugin_ovsdb_bst_ippg_threshold_set;
+  ovsdbBstFeat->bst_ipsp_threshold_set_cb   = sbplugin_ovsdb_bst_ipsp_threshold_set;
+  ovsdbBstFeat->bst_isp_threshold_set_cb    = sbplugin_ovsdb_bst_isp_threshold_set;
+  ovsdbBstFeat->bst_epsp_threshold_set_cb   = sbplugin_ovsdb_bst_epsp_threshold_set;
+  ovsdbBstFeat->bst_esp_threshold_set_cb    = sbplugin_ovsdb_bst_esp_threshold_set;
+  ovsdbBstFeat->bst_eucq_threshold_set_cb   = sbplugin_ovsdb_bst_eucq_threshold_set;
+  ovsdbBstFeat->bst_eucqg_threshold_set_cb  = sbplugin_ovsdb_bst_eucqg_threshold_set;
+  ovsdbBstFeat->bst_emcq_threshold_set_cb   = sbplugin_ovsdb_bst_emcq_threshold_set;
+  ovsdbBstFeat->bst_cpuq_threshold_set_cb   = sbplugin_ovsdb_bst_cpuq_threshold_set;
+  ovsdbBstFeat->bst_rqeq_threshold_set_cb   = sbplugin_ovsdb_bst_rqeq_threshold_set;
+  ovsdbBstFeat->bst_threshold_get_cb        = sbplugin_ovsdb_bst_threshold_get;
+  ovsdbBstFeat->bst_clear_stats_cb          = sbplugin_ovsdb_bst_clear_stats;
+  ovsdbBstFeat->bst_clear_thresholds_cb     = sbplugin_ovsdb_bst_clear_thresholds;
+  ovsdbBstFeat->bst_register_trigger_cb     = sbplugin_ovsdb_bst_register_trigger;
+  ovsdbBstFeat->bst_default_snapshot_get_cb = sbplugin_ovsdb_bst_default_snapshot_get;
+
+  if ((rv = sbplugin_ovsdb_bst_infra_init ())!= BVIEW_STATUS_SUCCESS)
+  {
+    return rv;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
diff --git a/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_cache.c b/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_cache.c
new file mode 100755
index 0000000..f2d17a4
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_cache.c
@@ -0,0 +1,325 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <pthread.h>
+#include "sbplugin.h"
+#include "sbplugin_ovsdb.h"
+#include "sbplugin_bst_map.h"
+#include "sbplugin_bst_ovsdb.h"
+#include "sbplugin_bst_cache.h"
+
+
+/* BST cache for config, stats and thresholds */
+static BVIEW_OVSDB_BST_DATA_t  bst_ovsdb_cache; 
+
+/* BST BID table parameters */ 
+extern BVIEW_BST_OVSDB_BID_PARAMS_t  bid_tab_params[SB_OVSDB_BST_STAT_ID_MAX_COUNT];
+
+
+/*********************************************************************
+* @brief   Initialise BST OVSDB cache
+*
+* @param[in]   @none 
+* @param[out]  @none 
+*
+* @retval BVIEW_STATUS_FAILURE   Failed to initialise BST ovsdb cache
+* @retval BVIEW_STATUS_SUCCESS   Successfully initialised BST ovsdb cache
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_init()
+{
+  /* Initialize Read Write lock with default attributes */
+  if (pthread_rwlock_init (&bst_ovsdb_cache.lock, NULL) != 0)
+  {
+    SB_OVSDB_LOG (BVIEW_LOG_ERROR, 
+	        "Failed to create RW lock with deafault attributes\n")
+            
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Set BST configuration in ovsdb cache
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   config   -  Pointer to BST configuration.
+
+* @param[out]  @none 
+*
+* @retval BVIEW_STATUS_FAILURE  Failed to set bst configuration in ovsdb cache         
+* @retval BVIEW_STATUS_SUCCESS  Successfully set bst cofiguration in cache
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_bst_config_set(int asic, 
+                                            BVIEW_OVSDB_CONFIG_DATA_t *config)
+{
+
+  SB_OVSDB_VALID_UNIT_CHECK(asic);
+  /* Check for NULL pointer */
+  SB_OVSDB_NULLPTR_CHECK(config, BVIEW_STATUS_INVALID_PARAMETER);
+  /* Acquire write lock*/
+  SB_OVSDB_RWLOCK_WR_LOCK(bst_ovsdb_cache.lock);  
+
+  /* Set bst mode in cache */
+  bst_ovsdb_cache.config_data.bst_enable = config->bst_enable;  
+  bst_ovsdb_cache.config_data.bst_tracking_mode = config->bst_tracking_mode;
+  bst_ovsdb_cache.config_data.periodic_collection = config->periodic_collection;  
+  bst_ovsdb_cache.config_data.collection_interval = config->collection_interval;
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(bst_ovsdb_cache.lock);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Get BST configuration from ovsdb cache
+*
+* @param[in]   asic     -  asic number.   
+* @param[out]  config   -  Pointer to BST configuration data.
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER  Invalid input parameter(s)         
+* @retval BVIEW_STATUS_SUCCESS            Successfully obtained bst 
+*                                         cofiguration from cache
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_bst_config_get(int asic, 
+                                            BVIEW_OVSDB_CONFIG_DATA_t *config)
+{
+
+  SB_OVSDB_VALID_UNIT_CHECK(asic);
+  /* Check for NULL pointer */
+  SB_OVSDB_NULLPTR_CHECK(config, BVIEW_STATUS_INVALID_PARAMETER);
+  /* Acquire write lock*/
+  SB_OVSDB_RWLOCK_RD_LOCK(bst_ovsdb_cache.lock);  
+
+  /* Get mode from cache */
+  config->bst_enable = bst_ovsdb_cache.config_data.bst_enable;
+  config->bst_tracking_mode = bst_ovsdb_cache.config_data.bst_tracking_mode;
+  config->periodic_collection  = bst_ovsdb_cache.config_data.periodic_collection;
+  config->collection_interval  = bst_ovsdb_cache.config_data.collection_interval;
+
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(bst_ovsdb_cache.lock);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief    Get row from ovsdb-key  <realm>/<name>/<index1>/<index2> 
+*           
+*
+* @param[in]   asic      -  asic number   
+* @param[in]   ovsdb_key -  ovsdb bufmon table's name/key entry     
+* @param[out]  p_row     -  Pointer to the row    
+
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to get row from ovsdb key  
+* @retval BVIEW_STATUS_SUCCESS       
+*                                   
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_row_get (int asic, char *ovsdb_key,
+                                      BVIEW_OVSDB_BID_INFO_t **p_row)
+{
+  char src_string[1024] = {0};
+  char delim[2] = "/";
+  char *realm   = NULL;
+  char *name    = NULL;
+  char *index1   = NULL;
+  char *index2   = NULL;
+  char *final_token = NULL;
+  int num_of_entries = sizeof(bid_tab_params)/sizeof(BVIEW_BST_OVSDB_BID_PARAMS_t);
+  int  bid = 0;
+  int index =0;
+  BVIEW_OVSDB_BID_INFO_t   *p_base = NULL;
+
+  /* Check for NULL pointer */
+  SB_OVSDB_NULLPTR_CHECK(p_row, BVIEW_STATUS_INVALID_PARAMETER);
+
+  strcpy(src_string, ovsdb_key);
+
+  /* ovsdb_key string is of the format <realm>/<name>/<index1>/<index2> */
+  /* Get realm */
+  realm = strtok(src_string, delim);
+  /* Get name */
+  name = strtok(NULL, delim);
+  /* Get  index1*/
+  index1 = strtok(NULL, delim);
+  /* Get  index2*/
+  index2 = strtok(NULL, delim);
+  if (realm == NULL || name == NULL ||
+      index1 == NULL || index2 == NULL)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  final_token = strtok(NULL, delim);
+  if (final_token != NULL)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  for (bid = 0; bid < num_of_entries; bid++)
+  {
+    if (strcmp(bid_tab_params[bid].realm_name, realm) == 0)
+    {
+      if (strcmp(bid_tab_params[bid].counter_name, name) == 0)
+      {
+        break;
+      }
+    }
+  }
+
+  /* Not able to find out correct bid entry for realm/name combination */
+  if (bid == num_of_entries)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* If it is double indexed then port is @first index */
+  if (bid_tab_params[bid].is_double_indexed == true)
+  {
+    index = ((atoi(index1) -1) * bid_tab_params[bid].num_of_columns) + atoi(index2);
+  }
+  else
+  {
+    /* Device */
+    if (bid_tab_params[bid].is_indexed == false)
+    {
+      index = 0;
+    }
+    else
+    {
+      index = atoi(index1);
+    }
+  }
+
+  /* Validate the index */
+  if (index >= bid_tab_params[bid].size)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  p_base = BVIEW_OVSDB_BID_BASE_ADDR (bid, &bst_ovsdb_cache.cache[asic]);
+  /* Get pointer to the entry */
+  *p_row =  p_base + index;
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief    Update the stat/threshold of row with key 'ovsdb_key'. 
+*           
+*
+* @param[in]   asic      -  asic number   
+* @param[in]   ovsdb_key -  ovsdb bufmon table's name/key entry     
+* @param[out]  p_row     -  Pointer to the row    
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to get the row for ovsdb_key.
+* @retval BVIEW_STATUS_SUCCESS      updated cache successfully. 
+*                                   
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS    bst_ovsdb_row_update (int asic, char *ovsdb_key,
+                                      BVIEW_OVSDB_BID_INFO_t *p_row)
+{
+  BVIEW_OVSDB_BID_INFO_t   *p_db_row = NULL;
+
+  SB_OVSDB_NULLPTR_CHECK (p_row, BVIEW_STATUS_INVALID_PARAMETER);
+
+  /* Get exact row of ovsdb_key*/
+  if (BVIEW_STATUS_SUCCESS !=  bst_ovsdb_cache_row_get (asic, 
+                                                        ovsdb_key,
+                                                        &p_db_row))
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire write lock*/
+  SB_OVSDB_RWLOCK_WR_LOCK(bst_ovsdb_cache.lock);
+
+  /* Update the cache*/
+  if (p_db_row)
+  {
+    p_db_row->stat      = p_row->stat;
+    p_db_row->threshold = p_row->threshold;
+  }
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(bst_ovsdb_cache.lock);
+
+  return BVIEW_STATUS_SUCCESS;
+}  
+ 
+/*********************************************************************
+* @brief   Get the pointer to BST data
+*
+* @retval  Pointer to BVIEW_OVSDB_BST_CACHE_t
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_OVSDB_BST_DATA_t  *bst_ovsdb_cache_get ()
+{
+  return (BVIEW_OVSDB_BST_DATA_t *) &bst_ovsdb_cache;
+}
+
+/*********************************************************************
+* @brief   Dumps BST ovsdb cache. 
+*          Non zero Stats and thresholds are dumped
+*
+* @retval BVIEW_STATUS_FAILURE      
+* @retval BVIEW_STATUS_SUCCESS      
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_cache_dump(int asic)
+{
+ 
+  SB_OVSDB_VALID_UNIT_CHECK(asic);
+  
+  /* Acquire read lock*/
+  SB_OVSDB_RWLOCK_RD_LOCK(bst_ovsdb_cache.lock);  
+
+  printf ("-----------BST OVSDB CACHE DUMP--------------\n\n");
+ 
+  printf ("BST enable = %s\n", 
+            (bst_ovsdb_cache.config_data.bst_enable? "true": "false"));
+  printf ("BST tracking mode = %d\n", bst_ovsdb_cache.config_data.bst_tracking_mode);
+ 
+  
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(bst_ovsdb_cache.lock);
+   return BVIEW_STATUS_SUCCESS;
+}
diff --git a/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_ovsdb.c b/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_ovsdb.c
new file mode 100755
index 0000000..0f5413e
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/bst/sbplugin_bst_ovsdb.c
@@ -0,0 +1,528 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+***************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <pthread.h>
+#include "sbplugin.h"
+#include "sbplugin_ovsdb.h"
+#include "sbplugin_bst_map.h"
+#include "sbplugin_bst_ovsdb.h"
+#include "sbplugin_bst_cache.h"
+#include "ovsdb_bst_ctl.h"
+
+
+
+/* Table to hold the different parameters of BID */ 
+BVIEW_BST_OVSDB_BID_PARAMS_t  bid_tab_params[SB_OVSDB_BST_STAT_ID_MAX_COUNT] = 
+                              {
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_DEVICE, 
+                                  .realm_name = "device",
+                                  .counter_name  = "data",
+                                  .is_indexed = false,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_DEVICE_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_DEVICE_COLUMNS,
+                                  .size = SB_OVSDB_BST_DEVICE_DB_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, device)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_EGR_POOL, 
+                                  .realm_name = "egress-service-pool",
+                                  .counter_name  = "um-share-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_EGR_POOL_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_EGR_POOL_COLUMNS,
+                                  .size = SB_OVSDB_E_SP_UM_SHARE_STAT_SIZE, 
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, eSPumShare)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_EGR_MCAST_POOL,
+                                  .realm_name = "egress-service-pool",
+                                  .counter_name  = "mc-share-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_EGR_MCAST_POOL_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_EGR_MCAST_POOL_COLUMNS,
+
+                                  .size = SB_OVSDB_E_SP_MC_SHARE_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, eSPmcShare)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_ING_POOL, 
+                                  .realm_name = "ingress-service-pool",
+                                  .counter_name  = "um-share-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_ING_POOL_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_ING_POOL_COLUMNS,
+                                  .size = SB_OVSDB_I_SP_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, iSP)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_PORT_POOL,
+                                  .realm_name = "ingress-port-service-pool",
+                                  .counter_name  = "um-share-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = true,
+                                  .num_of_rows = SB_OVSDB_BST_PORT_POOL_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_PORT_POOL_COLUMNS,
+                                  .size = SB_OVSDB_I_P_SP_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, iPortSP)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_PRI_GROUP_SHARED,
+                                  .realm_name = "ingress-port-priority-group",
+                                  .counter_name  = "um-share-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = true,
+                                  .num_of_rows = SB_OVSDB_BST_PRI_GROUP_SHARED_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_PRI_GROUP_SHARED_COLUMNS,
+                                  .size = SB_OVSDB_PG_SHARED_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, iPGShared)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_PRI_GROUP_HEADROOM,
+                                  .realm_name = "ingress-port-priority-group",
+                                  .counter_name  = "um-headroom-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = true,
+                                  .num_of_rows = SB_OVSDB_BST_PRI_GROUP_HEADROOM_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_PRI_GROUP_HEADROOM_COLUMNS,
+                                  .size = SB_OVSDB_PG_HEADROOM_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, iPGHeadroom)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_UCAST, 
+                                  .realm_name = "egress-uc-queue",
+                                  .counter_name  = "uc-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_UCAST_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_UCAST_COLUMNS,
+                                  .size = SB_OVSDB_E_UC_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, ucQ)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_MCAST, 
+                                  .realm_name = "egress-mc-queue",
+                                  .counter_name  = "mc-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_MCAST_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_MCAST_COLUMNS,
+                                  .size = SB_OVSDB_E_MC_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, mcQ)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_EGR_UCAST_PORT_SHARED,
+                                  .realm_name = "egress-port-service-pool",
+                                  .counter_name  = "uc-share-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = true,
+                                  .num_of_rows = SB_OVSDB_BST_EGR_UCAST_PORT_SHARED_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_EGR_UCAST_PORT_SHARED_COLUMNS,
+                                  .size = SB_OVSDB_E_P_SP_UC_SHARE_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, ePortSPucShare)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_EGR_PORT_SHARED,
+                                  .realm_name = "egress-port-service-pool",
+                                  .counter_name  = "um-share-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = true,
+                                  .num_of_rows = SB_OVSDB_BST_EGR_PORT_SHARED_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_EGR_PORT_SHARED_COLUMNS,
+                                  .size = SB_OVSDB_E_P_SP_UM_SHARE_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, ePortSPumShare)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_RQE_QUEUE,
+                                  .realm_name = "egress-rqe-queue",
+                                  .counter_name  = "rqe-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_RQE_QUEUE_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_RQE_QUEUE_COLUMNS,
+                                  .size = SB_OVSDB_E_RQE_QUEUE_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, rqe)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_RQE_POOL,
+                                  .realm_name = "egress-rqe-queue",
+                                  .counter_name  = "rqe-queue-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_RQE_POOL_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_RQE_POOL_COLUMNS,
+                                  .size = SB_OVSDB_E_RQE_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, rqeQueueEntries)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_UCAST_GROUP,
+                                  .realm_name = "egress-uc-queue-group",
+                                  .counter_name  = "uc-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_UCAST_GROUP_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_UCAST_GROUP_COLUMNS,
+                                  .size = SB_OVSBD_E_UC_Q_GROUP_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, eUCqGroup)
+                                },
+                                {
+                                  .bid = SB_OVSDB_BST_STAT_ID_CPU_QUEUE, 
+                                  .realm_name = "egress-cpu-queue",
+                                  .counter_name  = "cpu-buffer-count",
+                                  .is_indexed = true,
+                                  .is_double_indexed = false,
+                                  .num_of_rows = SB_OVSDB_BST_CPU_QUEUE_ROWS,
+                                  .num_of_columns = SB_OVSDB_BST_CPU_QUEUE_COLUMNS,
+                                  .size = SB_OVSDB_E_CPU_STAT_SIZE,
+                                  .offset = offsetof (BVIEW_OVSDB_BST_STAT_DB_t, eCPU)
+                                },
+                              };         
+
+  
+/*********************************************************************
+* @brief   Resolve ovsdb cache index using bid table
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   bid      -  bid number   
+* @param[in]   port     -  port number   
+* @param[in]   index    -  Queue index/Priority group Index/Service Pool   
+* @param[out]  db_index -  Index in bid stat/threshold array   
+
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to get db index from given params 
+* @retval BVIEW_STATUS_SUCCESS      db_index is successfully calculated
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_resolve_index(int asic, int bid, int port, 
+                                     int index, int *db_index)
+{
+  /* Validate BID*/
+  SB_OVSDB_BST_STAT_ID_CHECK (bid);
+  if (bid_tab_params[bid].is_double_indexed == true)
+  {
+    *db_index = (((port - 1) * bid_tab_params[bid].num_of_columns) + index); 
+  }
+  else
+  {
+    *db_index = (index);
+  }
+
+  if (*db_index >= bid_tab_params[bid].size)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  return BVIEW_STATUS_SUCCESS;
+}
+
+
+/*********************************************************************
+* @brief   Convert bid, port, index to name in bufmon table format
+*           <realm>/<name>/<index1>/<index2> 
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   bid      -  bid number   
+* @param[in]   port     -  port number   
+* @param[out]  ovsdb_key  -  ovsdb bufmon table's name entry     
+* @param[in]   length_of_key -length of the buffer that ovsdb_key points to   
+
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to prepare ovsdb key from given params 
+* @retval BVIEW_STATUS_SUCCESS      ovsdb_key is successfully prepared 
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_bid_port_index_to_ovsdb_key(int asic, int bid,
+                             int port, int index,  
+                             char *ovsdb_key, int length_of_key)
+{
+  char src_string[1024] = {0};
+  char delim[2] = "/";
+  char port_str[16] = {0};
+  char index_str[16] = {0};
+  int src_str_empty_size;
+
+  src_str_empty_size = (sizeof(src_string) - 1);
+ 
+  /* Validate BID*/
+  SB_OVSDB_BST_STAT_ID_CHECK (bid);
+ 
+  /* ovsdb_key string is of the format <realm>/<name>/<index1>/<index2> */ 
+  strncat(src_string, bid_tab_params[bid].realm_name, src_str_empty_size);
+
+  src_str_empty_size -= strlen(src_string);
+  if (src_str_empty_size < 2)
+  {
+   SB_OVSDB_DEBUG_PRINT("Not enough memory in source string");
+  }
+
+  
+  strcat(src_string, delim);
+  strncat(src_string, bid_tab_params[bid].counter_name, src_str_empty_size);
+  src_str_empty_size -= strlen(src_string);
+  if (src_str_empty_size < 2)
+  {
+   SB_OVSDB_DEBUG_PRINT("Not enough memory in source string");
+  }
+
+  strcat(src_string, delim);
+  if (bid_tab_params[bid].is_indexed == true)
+  {
+    if (bid_tab_params[bid].is_double_indexed == true) 
+    {
+      sprintf(port_str, "%d", port);
+
+      strncat(src_string, port_str, src_str_empty_size);
+      src_str_empty_size -= strlen(src_string);
+      if (src_str_empty_size < 2)
+      {
+        SB_OVSDB_DEBUG_PRINT("Not enough memory in source string");
+      }
+    }
+ 
+
+    sprintf(index_str, "%d", index);
+    strcat(src_string, delim);
+    strncat(src_string, index_str, src_str_empty_size);
+    src_str_empty_size -= strlen(src_string);
+    if (src_str_empty_size < 2)
+    {
+      SB_OVSDB_DEBUG_PRINT("Not enough memory in source string");
+    }
+    
+    if (bid_tab_params[bid].is_double_indexed == false)
+    {
+      strcat(src_string, delim);
+      strncat(src_string, "NONE", src_str_empty_size);
+      src_str_empty_size -= strlen(src_string);
+      if (src_str_empty_size < 2)
+      {
+        SB_OVSDB_DEBUG_PRINT("Not enpough memory in source string");
+      }
+    }
+  }
+  else
+  {
+    strncat(src_string, "NONE/NONE", src_str_empty_size);
+    src_str_empty_size -= strlen(src_string);
+    if (src_str_empty_size < 2)
+    {
+      SB_OVSDB_DEBUG_PRINT("Not enough memory in source string");
+    }
+  }
+  
+  if (length_of_key <= strlen(src_string))
+  {
+    SB_OVSDB_DEBUG_PRINT("Not enough memory in source string");
+    return BVIEW_STATUS_FAILURE;
+  }
+  strcpy (ovsdb_key, src_string);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Get threshold from BST ovsdb DB
+*
+* @param[in]   asic     -  asic number
+* @param[in]   port     -  port number
+* @param[in]   index    -  Queue index
+* @param[in]   bid      -  bid number
+* @param[out]  p_threshold   -  bst threshold pointer
+
+*
+* @retval BVIEW_STATUS_FAILURE      Threshold get is failed
+* @retval BVIEW_STATUS_SUCCESS      Threshold get is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+
+BVIEW_STATUS bst_ovsdb_threshold_get(int asic, int port, int index,
+                                     int bid, uint64_t *p_threshold)
+{
+  BVIEW_STATUS rv;
+  int db_index;
+  BVIEW_OVSDB_BID_INFO_t     *p_row = NULL;
+  BVIEW_OVSDB_BID_INFO_t     *p_base = NULL;
+  BVIEW_OVSDB_BST_DATA_t     *p_cache = NULL;
+
+  SB_OVSDB_NULLPTR_CHECK (p_threshold, BVIEW_STATUS_INVALID_PARAMETER);
+
+  if ((rv = bst_ovsdb_resolve_index(asic, bid, port, index, &db_index))
+                                               != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to resolve db_index\n");
+    return rv;
+  }
+
+  p_cache = bst_ovsdb_cache_get();
+  if (!p_cache)
+  {
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire read lock*/
+  SB_OVSDB_RWLOCK_RD_LOCK(p_cache->lock);
+
+  p_base =  BVIEW_OVSDB_BID_BASE_ADDR (bid, &p_cache->cache[asic]);
+
+  p_row = p_base + db_index;
+  if (p_row)
+  {
+    *p_threshold= p_row->threshold;
+  }
+  /* Release lock */
+  SB_OVSDB_RWLOCK_UNLOCK(p_cache->lock);
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Set threshold in BST ovsdb DB
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   port     -  port number   
+* @param[in]   index    -  Queue index   
+* @param[in]   bid      -  bid number   
+* @param[out]  threshold   -  bst threshold 
+
+*
+* @retval BVIEW_STATUS_FAILURE      Threshold set is failed
+* @retval BVIEW_STATUS_SUCCESS      Threshold set is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_threshold_set(int asic, int port, int index,
+                                     int bid, uint64_t threshold)
+{
+  BVIEW_STATUS rv;
+  int db_index;
+
+  if ((rv = bst_ovsdb_resolve_index(asic, bid, port, index, &db_index))
+                                               != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to resolve db_index\n");
+    return rv;
+  }
+
+  rv = bst_ovsdb_threshold_commit (asic, port, index, bid, threshold);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to commit threshold (port (%d) index (%d) bid(%d))\n",
+                              port, index, bid);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+    
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Get BST Config BST ovsdb DB
+*
+* @param[in]   asic     -  asic number   
+* @param[out]  enable   -  Pointer to BST configuration Data.
+
+*
+* @retval BVIEW_STATUS_FAILURE           Config get is failed
+* @retval BVIEW_STATUS_SUCCESS           Config get is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_bst_config_get(int asic, 
+                                      BVIEW_OVSDB_CONFIG_DATA_t *config)
+{
+  BVIEW_STATUS rv;
+     
+  /* Get mode from cache */  
+  rv = bst_ovsdb_cache_bst_config_get(asic, config);
+
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to set bst mode\n");
+    return rv;
+  }
+  return rv;
+}
+
+
+
+/*********************************************************************
+* @brief   Set BST Config BST ovsdb DB
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   config   -  Pointer to BST configuration Data.
+
+*
+* @retval BVIEW_STATUS_FAILURE           Config set is failed
+* @retval BVIEW_STATUS_SUCCESS           Config set is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_bst_config_set(int asic, 
+                                      BVIEW_OVSDB_CONFIG_DATA_t *config)
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+   
+  rv = bst_ovsdb_bst_config_commit (asic, config);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to commit bst mode\n");
+    return rv;
+  }
+  return rv;
+}
+
+
+
+/*********************************************************************
+* @brief   Dumps BST BID table parameter. 
+*
+* @retval none      
+*
+*
+* @notes    none
+*********************************************************************/
+void bst_ovsdb_dump_bid_tab_params()
+{
+  int index = 0;
+
+  printf ("--------BID table params------\n"); 
+  for (index = 0; index < SB_OVSDB_BST_STAT_ID_MAX_COUNT; index ++)
+  {
+    printf("Table index = %d\n", index);
+    printf("BID = %d\n", bid_tab_params[index].bid);
+    printf("Realm = %s\n", bid_tab_params[index].realm_name);
+    printf("Counter name= %s\n", bid_tab_params[index].counter_name);
+    printf("Is indexed = %s\n", (bid_tab_params[index].is_indexed?"true":"false")); 
+    printf("Is Double indexed = %s\n", (bid_tab_params[index].is_double_indexed?"true":"false")); 
+  }
+}
+
diff --git a/src/sb_plugin/sb_ovsdb/include/sbplugin_bst.h b/src/sb_plugin/sb_ovsdb/include/sbplugin_bst.h
new file mode 100755
index 0000000..c356895
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/include/sbplugin_bst.h
@@ -0,0 +1,828 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_BST_H
+#define INCLUDE_SBPLUGIN_BST_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "broadview.h"
+#include "sbfeature_bst.h"
+#include "sbplugin_bst_map.h"
+
+
+/** BST feature support ASIC's Mask*/
+#define  BVIEW_BST_SUPPORT_MASK    (BVIEW_ASIC_TYPE_TD2 | BVIEW_ASIC_TYPE_TH)
+
+/** Maximum number of COS Queue per port*/
+#define  BVIEW_BST_NUM_COS_PORT    8
+
+/* Check _asic (unit) is valid along with _data & _time for NULL pointer */
+#define  BVIEW_BST_INPUT_VALIDATE(_asic,_data,_time)                   \
+                            if (((_data) == NULL) || ((_time) == NULL) ||  \
+                                (SB_OVSDB_RV_ERROR(SB_OVSDB_API_UNIT_CHECK(_asic))))              \
+                            {                                                                     \
+                               SB_OVSDB_DEBUG_PRINT ("Invalid input data ASIC %d", _asic );       \
+                              return BVIEW_STATUS_INVALID_PARAMETER;                              \
+                            }                                          
+
+/* Check _asic (unit) is valid along with _data NULL pointer check*/
+#define  BVIEW_BST_INPUT_VALID_CHECK(_asic,_data)                      \
+                            if (((_data) == NULL) ||                     \
+                                (SB_OVSDB_RV_ERROR(SB_OVSDB_API_UNIT_CHECK(_asic))))              \
+                            {                                                                     \
+                               SB_OVSDB_DEBUG_PRINT ("Invalid input data ASIC %d", _asic );       \
+                              return BVIEW_STATUS_INVALID_PARAMETER;                              \
+                            }
+
+/* Macro to iterate 'n'  times*/
+#define BVIEW_BST_ITER(_index,_n)                              \
+              for ((_index) = 0; (_index) < (_n); (_index)++)
+
+
+/*********************************************************************
+* @brief  OVSDB South Bound BST feature init
+*
+* @param[in,out]  ovsdbBstFeat     - BST feature data structure
+*
+* @retval   BVIEW_STATUS_SUCCESS if BST feature is
+*                                initialized successfully.
+* @retval   BVIEW_STATUS_FAILURE if initialization is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_init (BVIEW_SB_BST_FEATURE_t *ovsdbBstFeat);
+
+/*********************************************************************
+* @brief  BST feature configuration set function
+*
+* @param[in]   asic                  - unit
+* @param[in]   data                  - BST config structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if config set is failed.
+* @retval BVIEW_STATUS_SUCCESS           if config set is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_config_set (int asic, BVIEW_BST_CONFIG_t *data);
+
+/*********************************************************************
+* @brief  Get BST configuration 
+*
+* @param[in]   asic                  - unit
+* @param[out]  data                  - BST config structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if config get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if config get is success.
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_config_get (int asic, BVIEW_BST_CONFIG_t *data);
+
+/*********************************************************************
+* @brief  Obtain Complete ASIC Statistics Report
+*
+* @param[in]      asic               - unit
+* @param[out]     snapshot           - snapshot data structure
+* @param[out]     time               - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if snapshot get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if snapshot get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_snapshot_get (int asic, 
+                                 BVIEW_BST_ASIC_SNAPSHOT_DATA_t *snapshot, 
+                                 BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Device Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - Device data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if device stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if device stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_device_data_get (int asic, 
+                                    BVIEW_BST_DEVICE_DATA_t *data, 
+                                    BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Priority Groups Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_pg data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ippg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ippg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ippg_data_get (int asic, 
+                              BVIEW_BST_INGRESS_PORT_PG_DATA_t *data, 
+                              BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_sp data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ipsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ipsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ipsp_data_get (int asic, 
+                                  BVIEW_BST_INGRESS_PORT_SP_DATA_t *data, 
+                                  BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Ingress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_sp structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if isp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if isp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_isp_data_get (int asic, 
+                                 BVIEW_BST_INGRESS_SP_DATA_t *data, 
+                                 BVIEW_TIME_t *time);
+ 
+/*********************************************************************
+* @brief  Obtain Egress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_p_sp data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if epsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if epsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_epsp_data_get (int asic, 
+                                BVIEW_BST_EGRESS_PORT_SP_DATA_t *data, 
+                                BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Egress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_sp data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if esp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if esp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_esp_data_get  (int asic, 
+                               BVIEW_BST_EGRESS_SP_DATA_t *data, 
+                               BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_q data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucq_data_get (int asic, 
+                              BVIEW_BST_EGRESS_UC_QUEUE_DATA_t *data, 
+                              BVIEW_TIME_t *time);
+   
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queue Groups Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_qg data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucqg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucqg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucqg_data_get (int asic, 
+                        BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t *data, 
+                        BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Egress Egress Multicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_mc_q data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if emcq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if emcq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_emcq_data_get (int asic, 
+                              BVIEW_BST_EGRESS_MC_QUEUE_DATA_t *data, 
+                              BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Egress Egress CPU Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - CPU queue data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if CPU stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if CPU stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_cpuq_data_get (int asic, 
+                             BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t *data, 
+                             BVIEW_TIME_t *time);
+
+/*********************************************************************
+* @brief  Obtain Egress Egress RQE Queues Statistics 
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - RQE data data structure
+* @param[out]  time             - time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if RQE stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if RQE stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_rqeq_data_get (int asic, 
+                                   BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t *data, 
+                                   BVIEW_TIME_t *time); 
+
+/*********************************************************************
+* @brief  Set threshold configuration for Device Statistics
+*
+* @param[in]  asic               - unit
+* @param[in]  thres              - Device threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_device_threshold_set (int asic, BVIEW_BST_DEVICE_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for  
+*           Ingress Port + Priority Groups Statistics
+*
+* @param[in]  asic              - unit
+* @param[in]  port              - port
+* @param[in]  pg                - Priority Group
+* @param[in]  thres             - Threshold structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*                                                             
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ippg_threshold_set (int asic, int port, int pg, 
+                                     BVIEW_BST_INGRESS_PORT_PG_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Ingress Port + Service Pools 
+*           Statistics
+*
+* @param[in] asic                     - unit
+* @param[in] port                     - port
+* @param[in] sp                       - service pool
+* @param[in] thres                    - Threshold data structure
+*                                                    
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_ipsp_threshold_set (int asic, int port, int sp, 
+                                      BVIEW_BST_INGRESS_PORT_SP_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Ingress Service Pools 
+*           Statistics
+*
+* @param[in] asic                       - unit
+* @param[in] sp                         - service pool 
+* @param[in] thres                      - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_isp_threshold_set (int asic, 
+                                     int sp, 
+                                     BVIEW_BST_INGRESS_SP_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set Profile configuration for Egress Port + Service Pools 
+*           Statistics
+*
+* @param[in] asic                       - unit
+* @param[in] port                       - port
+* @param[in] sp                         - service pool
+* @param[in] thres                      - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_epsp_threshold_set (int asic, 
+                                      int port, int sp, 
+                                      BVIEW_BST_EGRESS_PORT_SP_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Egress Service Pools Statistics
+*
+* @param[in] asic                        - unit
+* @param[in] sp                          - service pool
+* @param[in] thres                       - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_esp_threshold_set (int asic, 
+                                     int sp, 
+                                     BVIEW_BST_EGRESS_SP_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Egress Unicast Queues 
+*           Statistics
+*
+* @param[in] asic                        - unit
+* @param[in] ucQueue                     - uc queue
+* @param[in] thres                       - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucq_threshold_set (int asic, 
+                                      int ucQueue, 
+                              BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Egress Unicast Queue Groups 
+*           Statistics 
+*
+* @param[in]asic                          -unit
+* @param[in]ucQueueGrp                    -uc queue group 
+* @param[in]thres                         -Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_eucqg_threshold_set (int asic, 
+                                       int ucQueueGrp, 
+                                       BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Egress Multicast Queues 
+*           Statistics
+*
+* @param[in] asic                     - unit
+* @param[in] mcQueue                  - mcQueue
+* @param[in] thres                    - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_emcq_threshold_set (int asic, 
+                                      int mcQueue, 
+                                      BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Egress Egress CPU Queues 
+*           Statistics
+*
+* @param[in] asic                        - unit
+* @param[in] cpuQueue                    - cpuQueue
+* @param[in] thres                       - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_cpuq_threshold_set (int asic, 
+                                      int cpuQueue, 
+                                      BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Set threshold configuration for Egress Egress RQE Queues 
+*           Statistics
+*
+* @param[in]    asic                   - unit
+* @param[in]    rqeQueue               - rqeQueue
+* @param[out]   thres                  - Threshold data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if threshold set is success.
+* @retval BVIEW_STATUS_SUCCESS           if threshold set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_rqeq_threshold_set (int asic, 
+                                     int rqeQueue, 
+                                     BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_t *thres);
+
+/*********************************************************************
+* @brief  Clear stats
+*           
+* @param[in]   asic                            - unit
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if clear stats is success.
+* @retval BVIEW_STATUS_SUCCESS           if clear stats is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_bst_clear_stats (int asic);
+
+/*********************************************************************
+* @brief  Restore threshold configuration 
+*
+* @param   asic                              - unit
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if restore is success.
+* @retval BVIEW_STATUS_SUCCESS           if restore set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_bst_clear_thresholds  (int asic);
+
+/*********************************************************************
+* @brief  Register hw trigger callback
+*
+* @param   asic                              - unit
+* @param   callback                          - function to be called 
+*                                              when trigger happens
+* @param   cookie                            - user data
+* 
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if restore is success.
+* @retval BVIEW_STATUS_SUCCESS           if restore set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_bst_register_trigger (int asic, 
+                                        BVIEW_BST_TRIGGER_CALLBACK_t callback, 
+                                        void *cookie);
+
+/*********************************************************************
+* @brief  Get snapshot of all thresholds configured
+*
+*
+* @param  [in]  asic                         - unit
+* @param  [out] thresholdSnapshot            - Threshold snapshot
+*                                              data structure
+* @param  [out] time                         - Time
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if snapshot is success.
+* @retval BVIEW_STATUS_SUCCESS           if snapshot set is failed.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_threshold_get (int asic, 
+                              BVIEW_BST_ASIC_SNAPSHOT_DATA_t *thresholdSnapshot,
+                              BVIEW_TIME_t * time);
+
+/*********************************************************************
+* @brief  Obtain default buffer settings.
+*
+* @param[in]      asic               - unit
+* @param[out]     snapshot           - snapshot data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if snapshot get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if snapshot get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_snapshot_get (int asic,
+                                 BVIEW_BST_ASIC_SNAPSHOT_DATA_t *snapshot);
+
+
+/*********************************************************************
+* @brief  Obtain default Device Stat settings
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - Device data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_SUCCESS           if device stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_device_data_get (int asic,
+                                    BVIEW_BST_DEVICE_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Ingress Port + Priority Groups Statistics default vals
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_pg data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ippg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ippg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_ippg_data_get (int asic,
+                              BVIEW_BST_INGRESS_PORT_PG_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Ingress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_p_sp data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if ipsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if ipsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_ipsp_data_get (int asic,
+                                  BVIEW_BST_INGRESS_PORT_SP_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Ingress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - i_sp structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if isp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if isp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_isp_data_get (int asic,
+                                 BVIEW_BST_INGRESS_SP_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Egress Port + Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_p_sp data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if epsp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if epsp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_epsp_data_get (int asic,
+                                BVIEW_BST_EGRESS_PORT_SP_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Egress Service Pools Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_sp data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if esp stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if esp stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_esp_data_get  (int asic,
+                               BVIEW_BST_EGRESS_SP_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_q data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_eucq_data_get (int asic,
+                              BVIEW_BST_EGRESS_UC_QUEUE_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Egress Egress Unicast Queue Groups Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_uc_qg data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if eucqg stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if eucqg stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_eucqg_data_get (int asic,
+                        BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Egress Egress Multicast Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - e_mc_q data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if emcq stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if emcq stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_emcq_data_get (int asic,
+                              BVIEW_BST_EGRESS_MC_QUEUE_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Egress Egress CPU Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - CPU queue data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if CPU stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if CPU stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_cpuq_data_get (int asic,
+                             BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t *data);
+/*********************************************************************
+* @brief  Obtain Egress Egress RQE Queues Statistics
+*
+* @param[in]   asic             - unit
+* @param[out]  data             - RQE data data structure
+*
+* @retval BVIEW_STATUS_INVALID_PARAMETER if input data is invalid.
+* @retval BVIEW_STATUS_FAILURE           if RQE stat get is failed.
+* @retval BVIEW_STATUS_SUCCESS           if RQE stat get is success.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_bst_default_rqeq_data_get (int asic,
+                                   BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t *data);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_SBPLUGIN_COMMON_BST_H */
+  
+
+
diff --git a/src/sb_plugin/sb_ovsdb/include/sbplugin_bst_map.h b/src/sb_plugin/sb_ovsdb/include/sbplugin_bst_map.h
new file mode 100755
index 0000000..58c0823
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/include/sbplugin_bst_map.h
@@ -0,0 +1,131 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_BST_MAP_H
+#define INCLUDE_SBPLUGIN_BST_MAP_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "sbplugin.h"
+#include "sbplugin_system.h"
+#include "sbplugin_system_map.h"
+#include "openapps_log_api.h"
+#include "sbplugin_ovsdb.h"
+
+
+
+#define SB_OVSDB_BST_STAT_ID_DEVICE                    0
+#define SB_OVSDB_BST_STAT_ID_EGR_POOL                  1 
+#define SB_OVSDB_BST_STAT_ID_EGR_MCAST_POOL            2 
+#define SB_OVSDB_BST_STAT_ID_ING_POOL                  3
+#define SB_OVSDB_BST_STAT_ID_PORT_POOL                 4
+#define SB_OVSDB_BST_STAT_ID_PRI_GROUP_SHARED          5
+#define SB_OVSDB_BST_STAT_ID_PRI_GROUP_HEADROOM        6
+#define SB_OVSDB_BST_STAT_ID_UCAST                     7
+#define SB_OVSDB_BST_STAT_ID_MCAST                     8
+#define SB_OVSDB_BST_STAT_ID_EGR_UCAST_PORT_SHARED     9
+#define SB_OVSDB_BST_STAT_ID_EGR_PORT_SHARED           10
+#define SB_OVSDB_BST_STAT_ID_RQE_QUEUE                 11
+#define SB_OVSDB_BST_STAT_ID_RQE_POOL                  12
+#define SB_OVSDB_BST_STAT_ID_UCAST_GROUP               13
+#define SB_OVSDB_BST_STAT_ID_CPU_QUEUE                 14
+#define SB_OVSDB_BST_STAT_ID_MAX_COUNT                 15
+
+
+#define SB_OVSDB_BST_DEVICE_ROWS                   (1)
+#define SB_OVSDB_BST_DEVICE_COLUMNS                (1) 
+#define SB_OVSDB_BST_DEVICE_DB_SIZE                (1)
+
+#define SB_OVSDB_BST_EGR_POOL_ROWS                 (1)
+#define SB_OVSDB_BST_EGR_POOL_COLUMNS              (BVIEW_ASIC_MAX_SERVICE_POOLS)
+#define SB_OVSDB_E_SP_UM_SHARE_STAT_SIZE           (BVIEW_ASIC_MAX_SERVICE_POOLS)
+
+#define SB_OVSDB_BST_EGR_MCAST_POOL_ROWS           (1)
+#define SB_OVSDB_BST_EGR_MCAST_POOL_COLUMNS        (BVIEW_ASIC_MAX_SERVICE_POOLS)
+#define SB_OVSDB_E_SP_MC_SHARE_STAT_SIZE           (BVIEW_ASIC_MAX_SERVICE_POOLS)
+
+#define SB_OVSDB_BST_ING_POOL_ROWS                 (1)
+#define SB_OVSDB_BST_ING_POOL_COLUMNS              (BVIEW_ASIC_MAX_INGRESS_SERVICE_POOLS)
+#define SB_OVSDB_I_SP_STAT_SIZE                    (BVIEW_ASIC_MAX_INGRESS_SERVICE_POOLS)
+
+#define SB_OVSDB_BST_PORT_POOL_ROWS                (BVIEW_ASIC_MAX_PORTS)
+#define SB_OVSDB_BST_PORT_POOL_COLUMNS             (BVIEW_ASIC_MAX_INGRESS_SERVICE_POOLS)
+#define SB_OVSDB_I_P_SP_STAT_SIZE                  (BVIEW_ASIC_MAX_PORTS * \
+                                                    BVIEW_ASIC_MAX_INGRESS_SERVICE_POOLS)
+
+#define SB_OVSDB_BST_PRI_GROUP_SHARED_ROWS         (BVIEW_ASIC_MAX_PORTS)
+#define SB_OVSDB_BST_PRI_GROUP_SHARED_COLUMNS      (BVIEW_ASIC_MAX_PRIORITY_GROUPS)
+#define SB_OVSDB_PG_SHARED_SIZE                    (BVIEW_ASIC_MAX_PORTS * \
+                                                    BVIEW_ASIC_MAX_PRIORITY_GROUPS)
+
+#define SB_OVSDB_BST_PRI_GROUP_HEADROOM_ROWS       (BVIEW_ASIC_MAX_PORTS)
+#define SB_OVSDB_BST_PRI_GROUP_HEADROOM_COLUMNS    (BVIEW_ASIC_MAX_PRIORITY_GROUPS)
+#define SB_OVSDB_PG_HEADROOM_SIZE                  (BVIEW_ASIC_MAX_PORTS * \
+                                                    BVIEW_ASIC_MAX_PRIORITY_GROUPS)
+
+#define SB_OVSDB_BST_UCAST_ROWS                    (1)
+#define SB_OVSDB_BST_UCAST_COLUMNS                 (BVIEW_ASIC_MAX_UC_QUEUES)
+#define SB_OVSDB_E_UC_STAT_SIZE                    (BVIEW_ASIC_MAX_UC_QUEUES)
+
+#define SB_OVSDB_BST_MCAST_ROWS                    (1)
+#define SB_OVSDB_BST_MCAST_COLUMNS                 (BVIEW_ASIC_MAX_MC_QUEUES)
+#define SB_OVSDB_E_MC_STAT_SIZE                    (BVIEW_ASIC_MAX_MC_QUEUES)
+
+#define SB_OVSDB_BST_EGR_UCAST_PORT_SHARED_ROWS    (BVIEW_ASIC_MAX_PORTS) 
+#define SB_OVSDB_BST_EGR_UCAST_PORT_SHARED_COLUMNS (BVIEW_ASIC_MAX_SERVICE_POOLS)
+#define SB_OVSDB_E_P_SP_UC_SHARE_STAT_SIZE         (BVIEW_ASIC_MAX_PORTS * \
+                                                    BVIEW_ASIC_MAX_SERVICE_POOLS)
+
+#define SB_OVSDB_BST_EGR_PORT_SHARED_ROWS          (BVIEW_ASIC_MAX_PORTS)
+#define SB_OVSDB_BST_EGR_PORT_SHARED_COLUMNS       (BVIEW_ASIC_MAX_SERVICE_POOLS)
+#define SB_OVSDB_E_P_SP_UM_SHARE_STAT_SIZE         (BVIEW_ASIC_MAX_PORTS * \
+                                                    BVIEW_ASIC_MAX_SERVICE_POOLS)
+
+#define SB_OVSDB_BST_RQE_QUEUE_ROWS                (1)
+#define SB_OVSDB_BST_RQE_QUEUE_COLUMNS             (BVIEW_ASIC_MAX_RQE_QUEUES)
+#define SB_OVSDB_E_RQE_QUEUE_STAT_SIZE             (BVIEW_ASIC_MAX_RQE_QUEUES)
+
+#define SB_OVSDB_BST_RQE_POOL_ROWS                 (1)
+#define SB_OVSDB_BST_RQE_POOL_COLUMNS              (BVIEW_ASIC_MAX_RQE_QUEUES)
+#define SB_OVSDB_E_RQE_STAT_SIZE                   (BVIEW_ASIC_MAX_RQE_QUEUES)
+
+#define SB_OVSDB_BST_UCAST_GROUP_ROWS              (1)
+#define SB_OVSDB_BST_UCAST_GROUP_COLUMNS           (BVIEW_ASIC_MAX_UC_QUEUE_GROUPS)
+#define SB_OVSBD_E_UC_Q_GROUP_STAT_SIZE            (BVIEW_ASIC_MAX_UC_QUEUE_GROUPS)
+
+#define SB_OVSDB_BST_CPU_QUEUE_ROWS                (1)
+#define SB_OVSDB_BST_CPU_QUEUE_COLUMNS             (BVIEW_ASIC_MAX_CPU_QUEUES)
+#define SB_OVSDB_E_CPU_STAT_SIZE                   (BVIEW_ASIC_MAX_CPU_QUEUES)
+
+#define SB_OVSDB_BST_STAT_ID_CHECK(_bid)                                   \
+                   if (_bid >= SB_OVSDB_BST_STAT_ID_MAX_COUNT)             \
+                   {                                                       \
+                     SB_OVSDB_DEBUG_PRINT("BID value %d is greater than"   \
+                       "max supported BID %d\n",                           \
+                       (_bid), SB_OVSDB_BST_STAT_ID_MAX_COUNT);            \
+                     return (BVIEW_STATUS_FAILURE);                        \
+                   }
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* INCLUDE_SBPLUGIN_BST_MAP_H */
diff --git a/src/sb_plugin/sb_ovsdb/include/sbplugin_bst_ovsdb.h b/src/sb_plugin/sb_ovsdb/include/sbplugin_bst_ovsdb.h
new file mode 100755
index 0000000..5b20074
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/include/sbplugin_bst_ovsdb.h
@@ -0,0 +1,197 @@
+/*****************************************************************************
+ *
+ * (C) Copyright Broadcom Corporation 2015
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ *
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_BST_OVSDB_H
+#define INCLUDE_SBPLUGIN_BST_OVSDB_H
+
+#include "broadview.h"
+#include "sbplugin.h"
+#include "sbplugin_bst_map.h"
+#include "sbplugin_bst_cache.h"
+
+/* Structure to bid information */
+typedef struct _bst_ovsdb_bid_params_
+{
+  int      bid;                 /* bid number */
+  char     *realm_name;         /* Realm name */
+  char     *counter_name;       /* counter name */
+  bool     is_indexed;          /* Is it asingle indexed array */
+  bool     is_double_indexed;   /* BID table is double indexed/not */
+  int      num_of_rows;         /* Number of rows*/
+  int      num_of_columns;      /* Number of columns*/
+  int      size;                /* size of database for BID */
+  size_t   offset;              /* offset to BID database */
+} BVIEW_BST_OVSDB_BID_PARAMS_t;
+
+
+/* Get base address of Database for BID */
+#define   BVIEW_OVSDB_BID_BASE_ADDR(_bid, _p)  (BVIEW_OVSDB_BID_INFO_t *)((char *) _p + \
+                                                 bid_tab_params[_bid].offset);
+
+
+/* Macro to acquire read lock */
+#define SB_OVSDB_RWLOCK_RD_LOCK(lock)                             \
+           if (pthread_rwlock_rdlock(&lock) != 0)                    \
+           {                                                         \
+               SB_OVSDB_DEBUG_PRINT("Failed to take "                \
+                                 "read write lock for read\n" );     \
+               return BVIEW_STATUS_FAILURE;                          \
+           } 
+
+
+/* Macro to acquire write lock */
+#define SB_OVSDB_RWLOCK_WR_LOCK(lock)                             \
+           if (pthread_rwlock_wrlock(&lock) != 0)                    \
+           {                                                         \
+               SB_OVSDB_DEBUG_PRINT("Failed to take "                \
+                                 "read write lock for write\n" );    \
+               return BVIEW_STATUS_FAILURE;                          \
+           } 
+
+/* Macro to release RW lock */
+#define SB_OVSDB_RWLOCK_UNLOCK(lock)                              \
+           if (pthread_rwlock_unlock(&lock) != 0)                    \
+           {                                                         \
+               SB_OVSDB_DEBUG_PRINT("Failed to release "             \
+                                 "read write lock \n" );             \
+           } 
+
+
+/*********************************************************************
+* @brief   Convert bid, port, index to name in bufmon table format
+*           <realm>/<name>/<index1>/<index2>
+*
+* @param[in]   asic     -  asic number
+* @param[in]   bid      -  bid number
+* @param[in]   port     -  port number
+* @param[out]  ovsdb_key  -  ovsdb bufmon table's name entry
+* @param[in]   length_of_key -length of the buffer that ovsdb_key points to
+
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to prepare ovsdb key from given params
+* @retval BVIEW_STATUS_SUCCESS      ovsdb_key is successfully prepared
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_bid_port_index_to_ovsdb_key(int asic, int bid,
+                             int port, int index,
+                             char *ovsdb_key, int length_of_key);
+
+/*********************************************************************
+* @brief   Get threshold from BST ovsdb DB
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   port     -  port number   
+* @param[in]   index    -  Queue index   
+* @param[in]   bid      -  bid number   
+* @param[out]  p_threshold   -  bst threshold pointer
+
+*
+* @retval BVIEW_STATUS_FAILURE      Threshold get is failed
+* @retval BVIEW_STATUS_SUCCESS      Threshold get is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_threshold_get(int asic, int port, int index,
+                                     int bid, uint64_t *p_threshold);
+
+
+/*********************************************************************
+* @brief   Set threshold in BST ovsdb DB
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   port     -  port number   
+* @param[in]   index    -  Queue index   
+* @param[in]   bid      -  bid number   
+* @param[out]  threshold   -  bst threshold 
+
+*
+* @retval BVIEW_STATUS_FAILURE      Threshold set is failed
+* @retval BVIEW_STATUS_SUCCESS      Threshold set is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_threshold_set(int asic, int port, int index,
+                                     int bid, uint64_t threshold);
+
+/*********************************************************************
+* @brief   Get BST Config BST ovsdb DB
+*
+* @param[in]   asic     -  asic number   
+* @param[out]  enable   -  Pointer to BST configuration Data.
+
+*
+* @retval BVIEW_STATUS_FAILURE           Config get is failed
+* @retval BVIEW_STATUS_SUCCESS           Config get is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_bst_config_get(int asic,
+                                      BVIEW_OVSDB_CONFIG_DATA_t *config);
+
+/*********************************************************************
+* @brief   Set BST Config BST ovsdb DB
+*
+* @param[in]   asic     -  asic number   
+* @param[in]   config   -  Pointer to BST configuration Data.
+
+*
+* @retval BVIEW_STATUS_FAILURE           Config set is failed
+* @retval BVIEW_STATUS_SUCCESS           Config set is successfull
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_bst_config_set(int asic,
+                                      BVIEW_OVSDB_CONFIG_DATA_t *config);
+
+
+/*********************************************************************
+* @brief   Resolve ovsdb cache index using bid table
+*
+* @param[in]   asic     -  asic number
+* @param[in]   bid      -  bid number
+* @param[in]   port     -  port number
+* @param[in]   index    -  Queue index/Priority group Index/Service Pool
+* @param[out]  db_index -  Index in bid stat/threshold array
+
+*
+* @retval BVIEW_STATUS_FAILURE      Failed to get db index from given params
+* @retval BVIEW_STATUS_SUCCESS      db_index is successfully calculated
+*
+*
+* @notes    none
+*********************************************************************/
+BVIEW_STATUS bst_ovsdb_resolve_index(int asic, int bid, int port,
+                                     int index, int *db_index);
+
+/*********************************************************************
+* @brief   Dumps BST BID table parameter. 
+*
+* @retval none      
+*
+*
+* @notes    none
+*********************************************************************/
+void bst_ovsdb_dump_bid_tab_params();
+
+#endif
diff --git a/src/sb_plugin/sb_ovsdb/include/sbplugin_ovsdb.h b/src/sb_plugin/sb_ovsdb/include/sbplugin_ovsdb.h
new file mode 100755
index 0000000..04f2431
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/include/sbplugin_ovsdb.h
@@ -0,0 +1,74 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_OVSDB_H
+#define INCLUDE_SBPLUGIN_OVSDB_H
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#include "sbplugin.h"
+#include "sbplugin_bst.h"
+#include "sbplugin_system.h"
+#include "sbplugin_system_map.h"
+#include "sb_redirector_api.h"
+#include "openapps_log_api.h"
+
+
+/* NULL Pointer Check*/
+#define  SB_OVSDB_NULLPTR_CHECK(_p,_rv)         \
+                if ((_p) == NULL)               \
+                {                               \
+                  return (_rv);                 \
+                }
+
+/* Flag to enable/disable debug */
+extern int sbOvsdbDebugFlag;
+
+#define SB_OVSDB_RV_ERROR(_rv)     ((_rv) != BVIEW_STATUS_SUCCESS)
+
+/* Macro to print the OVSDB plug-in debug information */
+#define SB_OVSDB_DEBUG_PRINT(format, args...)                                   \
+                       if (sbOvsdbDebugFlag)                                    \
+                       {                                                        \
+                         printf ("(%s:%d) "format, __FILE__, __LINE__,##args);  \
+                       }
+
+
+#define SB_OVSDB_LOG(severity,format, args...)               \
+                        {                                   \
+                          log_post(severity,format, ##args);\
+                        }
+
+#define SB_OVSDB_API_UNIT_CHECK(_unit)                                           \
+                        (sbplugin_ovsdb_valid_unit_check(_unit))
+
+#define SB_OVSDB_VALID_UNIT_CHECK(_asic)                                         \
+                         if (SB_OVSDB_RV_ERROR(SB_OVSDB_API_UNIT_CHECK(_asic)))  \
+                         {                                                       \
+                           return BVIEW_STATUS_INVALID_PARAMETER;                \
+                         }
+              
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* INCLUDE_SBPLUGIN_OVSDB_H */
+
diff --git a/src/sb_plugin/sb_ovsdb/include/sbplugin_system_map.h b/src/sb_plugin/sb_ovsdb/include/sbplugin_system_map.h
new file mode 100755
index 0000000..ce04557
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/include/sbplugin_system_map.h
@@ -0,0 +1,252 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_SYSTEM_MAP_H
+#define INCLUDE_SBPLUGIN_SYSTEM_MAP_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "sbplugin.h"
+#include "sbplugin_ovsdb.h"
+
+#define  SBPLUGIN_NETWORK_OS   "ovsdb"
+ 
+/* SYSTEM feature supported ASIC's Mask.*/
+#define  BVIEW_SYSTEM_SUPPORT_MASK   (BVIEW_ASIC_TYPE_ALL)
+
+#define BVIEW_TD2_NUM_UC_QUEUE        2960
+#define BVIEW_TD2_NUM_UC_QUEUE_GRP    128
+#define BVIEW_TD2_NUM_MC_QUEUE        1040
+#define BVIEW_TD2_NUM_SP              4
+#define BVIEW_TD2_NUM_COMMON_SP       1
+#define BVIEW_TD2_NUM_RQE             11
+#define BVIEW_TD2_NUM_RQE_POOL        4
+#define BVIEW_TD2_NUM_PG              8
+#define BVIEW_TD2_1588_SUPPORT        1
+#define BVIEW_TD2_CPU_COSQ            8
+#define BVIEW_TD2_CELL_TO_BYTE        208
+
+#define    BVIEW_OVSDB_PORT_GET(_port)   \
+               (_port = _port);
+
+
+/* Get OVSDB asic number from Application ASIC number.*/
+#define    BVIEW_OVSDB_ASIC_GET(_asic) \
+               ((_asic) = asicMap[_asic]);
+
+/* Get Applciation ASIC number from OVSDB ASIC number*/
+#define    BVIEW_OVSDB_APP_ASIC_GET(_asic) \
+               ((_asic) = asicAppMap[_asic]);
+
+extern BVIEW_ASIC_t                 asicDb[];
+
+/*********************************************************************
+* @brief  OVSDB South Bound - SYSTEM feature init
+*
+* @param[in,out]   ovsdbSystemFeat   -  system data structure
+*
+* @returns BVIEW_STATUS_SUCCESS  if intialization is success
+*          BVIEW_STATUS_FAILURE  if intialization is fail
+*
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_init (BVIEW_SB_SYSTEM_FEATURE_t *ovsdbSystemFeat);
+
+/*********************************************************************
+* @brief  Get the system name
+*
+* @param[out] buffer                         - buffer
+* @param[in]  length                         - length of the buffer
+*
+* @retval  BVIEW_STATUS_SUCCESS            if Name get is success.
+* @retval  BVIEW_STATUS_FAILURE            if Name get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_system_name_get (char *buffer, int length);
+
+/*********************************************************************
+* @brief  Get the MAC address of the system
+*
+* @param[out] buffer                         - buffer
+* @param[in]  length                         - length of the buffer
+*
+* @retval  BVIEW_STATUS_SUCCESS            if MAC get is success.
+* @retval  BVIEW_STATUS_FAILURE            if MAC get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get MAC address of the service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_system_mac_get (unsigned char *buffer, 
+                                           int length);
+
+/*********************************************************************
+* @brief  Get the IP address of system
+*
+* @param[out] buffer                         - buffer
+* @param[in]  length                         - length of the buffer
+*
+* @retval  BVIEW_STATUS_SUCCESS            if IP get is success.
+* @retval  BVIEW_STATUS_FAILURE            if IP get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get IP address of service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_ipv4_get (unsigned char *buffer, 
+                                           int length);
+
+/*********************************************************************
+* @brief  Get Current local time. 
+*
+* @param[out] tm                          - Pointer to tm structure
+*
+* @retval  BVIEW_STATUS_SUCCESS            if time get is success.
+* @retval  BVIEW_STATUS_FAILURE            if time get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get IP address of service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_time_get (time_t *time);
+
+/*********************************************************************
+* @brief  Translate ASIC String notation to ASIC Number.
+*
+* @param[in]  src                         - ASIC ID String
+* @param[out] asic                        - ASIC Number
+*
+* @retval  BVIEW_STATUS_SUCCESS            if ASIC Translation is success.
+* @retval  BVIEW_STATUS_FAILURE            if ASIC Translation is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get IP address of service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_asic_translate_from_notation (char *src, 
+                                                               int *asic);
+
+/*********************************************************************
+* @brief  Translate Port String notation to Port Number.
+*
+* @param[in]   src                         - Port ID String
+* @param[out]  port                        - PortId
+*
+* @retval  BVIEW_STATUS_SUCCESS            if Port Tranlate is success.
+* @retval  BVIEW_STATUS_FAILURE            if Port  is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_port_translate_from_notation (char *src,
+                                                               int *port);
+
+/*********************************************************************
+* @brief  Translate ASIC number to ASIC string notation.
+*
+* @param[in]   asic                         - ASIC ID
+* @param[out]  dst                          - ASIC ID String
+*
+* @retval  BVIEW_STATUS_SUCCESS            if ASIC ID Tranlate is success.
+* @retval  BVIEW_STATUS_FAILURE            if ASIC ID Tranlate is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_asic_translate_to_notation (int asic,
+                                                             char *dst);
+
+/*********************************************************************
+* @brief   Translate port number to port string notation.
+*
+* @param[in]   port                         - Port Number
+* @param[in]   asic                         - ASIC
+* @param[out]  dst                          - ASIC String
+*
+* @retval  BVIEW_STATUS_SUCCESS            if Port Tranlate is success.
+* @retval  BVIEW_STATUS_FAILURE            if Port Tranlate is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get IP address of service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_port_translate_to_notation (int asic,
+                                                            int port,
+                                                            char *dst);
+
+/*********************************************************************
+* @brief   Verify whether a given unit number is valid or not.
+*
+* @param[in]   unit                     -  unit number
+*
+* @retval  BVIEW_STATUS_SUCCESS            if unit number is valid
+* @retval  BVIEW_STATUS_FAILURE            if unit number is invalid
+*
+* @notes
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_valid_unit_check(unsigned int unit);
+
+/*********************************************************************
+* @brief       Get Network OS
+*
+* @param[out]  buffer                 Pointer to network OS String
+* @param[in]   length                 length of the buffer
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure
+*                                     Failed to get network os
+*
+* @retval   BVIEW_STATUS_SUCCESS      Network OS is successfully
+*                                     queried
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_system_network_os_get (uint8_t *buffer, int length);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* INCLUDE_SBPLUGIN_SYSTEM_MAP_H */
+
diff --git a/src/sb_plugin/sb_ovsdb/ovsdb_config.cfg b/src/sb_plugin/sb_ovsdb/ovsdb_config.cfg
new file mode 100755
index 0000000..66b8be2
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/ovsdb_config.cfg
@@ -0,0 +1,2 @@
+#ovsdb_socket can also be tcp:IP:Port for TCP connection 
+ovsdb_socket=unix:/var/run/openvswitch/db.sock
diff --git a/src/sb_plugin/sb_ovsdb/sbplugin_init.c b/src/sb_plugin/sb_ovsdb/sbplugin_init.c
new file mode 100755
index 0000000..5d38c0c
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/sbplugin_init.c
@@ -0,0 +1,87 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include "sbplugin.h"
+#include "sbplugin_bst.h"
+#include "sbplugin_system.h"
+#include "sbplugin_system_map.h"
+#include "sbplugin_ovsdb.h"
+#include "sb_redirector_api.h"
+
+/* BST feature data structure*/
+static BVIEW_SB_BST_FEATURE_t       ovsdbBstFeat;
+/* SYSTEM feature data structure*/
+static BVIEW_SB_SYSTEM_FEATURE_t    ovsdbSystemFeat;
+/* SB Plugin data structure*/
+static BVIEW_SB_PLUGIN_t sbPlugin;
+
+/* Flag to enable/disable debug */
+int sbOvsdbDebugFlag = false;
+
+/*********************************************************************
+* @brief    OVSDB South bound plugin init
+*
+* @retval   BVIEW_STATUS_SUCCESS if BST feature is
+*                                initialized successfully.
+* @retval   BVIEW_STATUS_FAILURE if initialization fails.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_common_init ()
+{
+  BVIEW_STATUS      rv = BVIEW_STATUS_SUCCESS;
+  unsigned int      featureIndex = 0;
+
+  sbPlugin.numSupportedFeatures = 0;
+  
+  /* Init SYSTEM feature*/
+  rv = sbplugin_ovsdb_system_init (&ovsdbSystemFeat);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to Register OVSDB plugin");
+    return rv;
+  }
+  sbPlugin.featureList[featureIndex] = (BVIEW_SB_FEATURE_t *)&ovsdbSystemFeat;
+  sbPlugin.numSupportedFeatures++;
+  featureIndex++;
+
+  /* Init BST feature*/  
+  rv = sbplugin_ovsdb_bst_init (&ovsdbBstFeat);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to Intialize OVSDB BST feature");
+    return rv;
+  }
+  sbPlugin.featureList[featureIndex] = (BVIEW_SB_FEATURE_t *)&ovsdbBstFeat;
+  sbPlugin.numSupportedFeatures++;
+  ovsdbSystemFeat.featureMask |= BVIEW_FEATURE_BST; 
+  featureIndex++;
+
+  /* Register OVSDB plugin to the sb-redirector*/
+  rv = sb_plugin_register (sbPlugin);
+  if (rv != BVIEW_STATUS_SUCCESS)
+  {
+    SB_OVSDB_DEBUG_PRINT ("Failed to Register OVSDB plugin");
+    return rv;
+  }
+  
+  return rv;
+}
+  
diff --git a/src/sb_plugin/sb_ovsdb/system/sbplugin_system.c b/src/sb_plugin/sb_ovsdb/system/sbplugin_system.c
new file mode 100755
index 0000000..6c2b114
--- /dev/null
+++ b/src/sb_plugin/sb_ovsdb/system/sbplugin_system.c
@@ -0,0 +1,482 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <inttypes.h>
+#include <time.h>  
+#include <unistd.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include "sbplugin.h"
+#include "sbplugin_system.h"
+#include "sbplugin_ovsdb.h"
+#include "sbplugin_system_map.h"
+
+/* Array to hold ASIC properties data based for Maximum platforms*/
+BVIEW_ASIC_t                 asicDb[BVIEW_MAX_ASICS_ON_A_PLATFORM];
+
+/* Intialize ASIC number Mapping. The Index to table is Applcation ASIC number
+ * Application asic numbering starts with '1', so to avoid for loop to get uint
+ * the index to the table is Application asic number.
+ */
+
+int  asicMap[BVIEW_MAX_ASICS_ON_A_PLATFORM+1] =
+                    /* asic */
+                    /* -------- */
+                    {  -1     ,
+                        0     };
+int  asicAppMap[BVIEW_MAX_ASICS_ON_A_PLATFORM] = {1};
+
+/*********************************************************************
+* @brief   Get the chip type
+*
+* @param[in]   unit              - unit
+* @param[out]  asicType          - ASIC type
+*
+* @retval BVIEW_STATUS_SUCCESS            if chip get is success.
+* @retval BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+static BVIEW_STATUS sbplugin_ovsdb_system_util_chip_type_get (unsigned int unit,
+                                       BVIEW_ASIC_TYPE *asicType)
+{
+  *asicType = BVIEW_ASIC_TYPE_TD2;
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Init TD2 scaling parametrs.
+*
+* @param [in,out]  asic               - ASIC specific info data
+*
+* @retval BVIEW_STATUS_SUCCESS            if init is success.
+* @retval BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+static BVIEW_STATUS sbplugin_ovsdb_system_util_td2_init (BVIEW_ASIC_t *asic)
+{
+  if (asic == NULL)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  asic->scalingParams.numUnicastQueues = BVIEW_TD2_NUM_UC_QUEUE;
+  asic->scalingParams.numUnicastQueueGroups = BVIEW_TD2_NUM_UC_QUEUE_GRP;
+  asic->scalingParams.numMulticastQueues = BVIEW_TD2_NUM_MC_QUEUE;
+  asic->scalingParams.numServicePools = BVIEW_TD2_NUM_SP;
+  asic->scalingParams.numCommonPools = BVIEW_TD2_NUM_COMMON_SP;
+  asic->scalingParams.numCpuQueues = BVIEW_TD2_CPU_COSQ;
+  asic->scalingParams.numRqeQueues = BVIEW_TD2_NUM_RQE;
+  asic->scalingParams.numRqeQueuePools = BVIEW_TD2_NUM_RQE_POOL;
+  asic->scalingParams.numPriorityGroups = BVIEW_TD2_NUM_PG;
+  asic->scalingParams.cellToByteConv = BVIEW_TD2_CELL_TO_BYTE;
+
+  asic->scalingParams.support1588 = BVIEW_TD2_1588_SUPPORT;
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  SYSTEM feature init
+*
+* @param[in,out]   ovsdbSystemFeat   -  system data structure
+*
+* @returns BVIEW_STATUS_SUCCESS  if intialization is success
+*          BVIEW_STATUS_FAILURE  if intialization is fail
+*
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_init (BVIEW_SB_SYSTEM_FEATURE_t    *ovsdbSystemFeat)
+{
+  unsigned int     num_front_panel_ports = 0;
+  unsigned int     index = 0;
+  unsigned int     unit = 0;
+  unsigned int     num_ports = 100;
+  unsigned int     max_units = 0;
+
+  if (ovsdbSystemFeat == NULL)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  memset (ovsdbSystemFeat, 0x00, sizeof (BVIEW_SB_SYSTEM_FEATURE_t));
+  ovsdbSystemFeat->feature.featureId           = BVIEW_FEATURE_SYSTEM;
+  ovsdbSystemFeat->feature.supportedAsicMask   = BVIEW_SYSTEM_SUPPORT_MASK;
+  ovsdbSystemFeat->numSupportedAsics = 0;
+
+  max_units  =1;
+
+  /* Find out the attached ASIC and fill scaling parametrs*/
+  for (unit = 0; unit < max_units; unit++)
+  {
+    ovsdbSystemFeat->numSupportedAsics++;
+    num_front_panel_ports = num_ports;
+    asicDb[index].scalingParams.numPorts  = num_front_panel_ports;
+
+    asicDb[index].unit = unit;
+    sbplugin_ovsdb_system_util_chip_type_get (unit, &asicDb[index].asicType);
+
+    /* Based on the CHIP call appropriate init function*/
+    if (BVIEW_ASIC_TYPE_TD2 == asicDb[index].asicType || 
+        BVIEW_ASIC_TYPE_TH  == asicDb[index].asicType)
+    {
+      sbplugin_ovsdb_system_util_td2_init (&asicDb[index]);
+    }
+      
+    ovsdbSystemFeat->asicList[index] = &asicDb[index];
+    index++;
+  }    
+  ovsdbSystemFeat->system_name_get_cb     = sbplugin_ovsdb_system_name_get;
+  ovsdbSystemFeat->system_mac_get_cb      = sbplugin_ovsdb_system_mac_get;
+  ovsdbSystemFeat->system_ip4_get_cb      = sbplugin_ovsdb_system_ipv4_get;
+  ovsdbSystemFeat->system_time_get_cb     = sbplugin_ovsdb_system_time_get;
+  ovsdbSystemFeat->system_asic_translate_from_notation_cb      = sbplugin_ovsdb_system_asic_translate_from_notation;
+  ovsdbSystemFeat->system_port_translate_from_notation_cb      = sbplugin_ovsdb_system_port_translate_from_notation;
+  ovsdbSystemFeat->system_asic_translate_to_notation_cb        = sbplugin_ovsdb_system_asic_translate_to_notation;
+  ovsdbSystemFeat->system_port_translate_to_notation_cb        = sbplugin_ovsdb_system_port_translate_to_notation;
+  ovsdbSystemFeat->system_network_os_get_cb                    = sbplugin_ovsdb_system_network_os_get;
+
+  return BVIEW_STATUS_SUCCESS;
+} 
+
+/*********************************************************************
+* @brief  Get the system name
+*
+* @param[out] buffer                         - buffer
+* @param[in]  length                         - length of the buffer
+*
+* @retval  BVIEW_STATUS_SUCCESS            if Name get is success.
+* @retval  BVIEW_STATUS_FAILURE            if Name get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_system_name_get (char *buffer, int length)
+{
+  if (buffer == NULL)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  strncpy (buffer, "OVSDB-PLUGIN", length);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Get the MAC address of the system
+*
+* @param[out] buffer                         - buffer
+* @param[in]  length                         - length of the buffer
+*
+* @retval  BVIEW_STATUS_SUCCESS            if MAC get is success.
+* @retval  BVIEW_STATUS_FAILURE            if MAC get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get MAC address of the service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_system_mac_get (unsigned char *buffer, 
+                                           int length)
+{
+  int fd;
+  struct ifreq ifr;
+  BVIEW_STATUS  rv = BVIEW_STATUS_FAILURE;
+
+  if (buffer == NULL)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  }
+
+  fd = socket(AF_INET, SOCK_DGRAM, 0);
+
+  if (fd > -1)
+  {
+    ifr.ifr_addr.sa_family = AF_INET;
+    snprintf(ifr.ifr_name, IFNAMSIZ-1, "%s", "eth0");
+
+    if (ioctl(fd, SIOCGIFHWADDR, &ifr) != -1)
+    {
+      memcpy(buffer, ifr.ifr_hwaddr.sa_data, length);
+      rv = BVIEW_STATUS_SUCCESS;
+    }
+    close(fd);
+  }
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Get the IP address of system
+*
+* @param[out] buffer                         - buffer
+* @param[in]  length                         - length of the buffer
+*
+* @retval  BVIEW_STATUS_SUCCESS            if IP get is success.
+* @retval  BVIEW_STATUS_FAILURE            if IP get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get IP address of service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_ipv4_get (unsigned char *buffer, 
+                                           int length)
+{
+  int fd;
+  struct ifreq ifr;
+  BVIEW_STATUS  rv  = BVIEW_STATUS_FAILURE;
+
+  if (buffer == NULL)
+  {
+    return BVIEW_STATUS_INVALID_PARAMETER;
+  } 
+  fd = socket(AF_INET, SOCK_DGRAM, 0);
+
+  if (fd > -1)
+  {
+    /* Get an IPv4 IP address */
+    ifr.ifr_addr.sa_family = AF_INET;
+
+    /* IP address attached to "eth0" */
+    strncpy(ifr.ifr_name, "eth0", IFNAMSIZ-1);
+    if (ioctl(fd, SIOCGIFADDR, &ifr) != -1)
+    {
+      memcpy (buffer, &((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr, length); 
+      rv = BVIEW_STATUS_SUCCESS;
+    }
+    close(fd);
+  }
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Get Current local time.
+*
+* @param[out] tm                          - Pointer to tm structure
+*
+* @retval  BVIEW_STATUS_SUCCESS            if time get is success.
+* @retval  BVIEW_STATUS_FAILURE            if time get is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes    Get IP address of service port.
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_system_time_get (time_t *ptime)
+{
+  /* NULL pointer check*/
+  SB_OVSDB_NULLPTR_CHECK (ptime, BVIEW_STATUS_INVALID_PARAMETER);
+
+  time (ptime);
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Translate ASIC String notation to ASIC Number.
+*
+* @param[in]  src                         - ASIC ID String
+* @param[out] asic                        - ASIC Number
+*
+* @retval  BVIEW_STATUS_SUCCESS            if ASIC Translation is success.
+* @retval  BVIEW_STATUS_FAILURE            if ASIC Translation is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes   
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_asic_translate_from_notation (char *src, 
+                                                               int *asic) 
+{
+  SB_OVSDB_NULLPTR_CHECK (src, BVIEW_STATUS_INVALID_PARAMETER);
+  SB_OVSDB_NULLPTR_CHECK (asic, BVIEW_STATUS_INVALID_PARAMETER);
+
+  /* Convert to Interger*/
+  *asic = atoi(src);
+ 
+  if (*asic > (BVIEW_MAX_ASICS_ON_A_PLATFORM))
+     return BVIEW_STATUS_INVALID_PARAMETER;
+ 
+  /* Get OVSDB ASIC ID from mapping table*/
+  BVIEW_OVSDB_ASIC_GET (*asic)
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Translate Port String notation to Port Number.
+*
+* @param[in]   src                         - Port ID String
+* @param[out]  port                        - PortId
+*
+* @retval  BVIEW_STATUS_SUCCESS            if Port Tranlate is success.
+* @retval  BVIEW_STATUS_FAILURE            if Port  is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes  
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_port_translate_from_notation (char *src, 
+                                                               int *port) 
+{
+  SB_OVSDB_NULLPTR_CHECK (src, BVIEW_STATUS_INVALID_PARAMETER);
+  SB_OVSDB_NULLPTR_CHECK (port, BVIEW_STATUS_INVALID_PARAMETER);
+  
+  /* Convert to Interger*/
+  *port = atoi(src); 
+  
+  /* Get OVSDB port*/
+  BVIEW_OVSDB_PORT_GET (*port);
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief  Translate ASIC number to ASIC string notation.
+*
+* @param[in]   asic                         - ASIC ID
+* @param[out]  dst                          - ASIC ID String
+*
+* @retval  BVIEW_STATUS_SUCCESS            if ASIC ID Tranlate is success.
+* @retval  BVIEW_STATUS_FAILURE            if ASIC ID Tranlate is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes 
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_asic_translate_to_notation (int asic, 
+                                                             char *dst) 
+{
+  SB_OVSDB_NULLPTR_CHECK (dst, BVIEW_STATUS_INVALID_PARAMETER);
+
+  if (asic >= (BVIEW_MAX_ASICS_ON_A_PLATFORM))
+     return BVIEW_STATUS_INVALID_PARAMETER;
+
+  /* Get OVSDB ASIC ID from mapping table*/
+  BVIEW_OVSDB_APP_ASIC_GET (asic)
+  
+  /* Convert to String*/
+  sprintf(dst, "%d", asic); 
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Translate port number to port string notation.
+*
+* @param[in]   asic                         - ASIC 
+* @param[in]   port                         - Port Number
+* @param[out]  dst                          - ASIC String
+*
+* @retval  BVIEW_STATUS_SUCCESS            if Port Tranlate is success.
+* @retval  BVIEW_STATUS_FAILURE            if Port Tranlate is failed.
+* @retval  BVIEW_STATUS_INVALID_PARAMETER  if input parameter is invalid.
+*
+* @notes  
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_system_port_translate_to_notation (int asic, 
+                                                             int port, 
+                                                             char *dst) 
+{
+  SB_OVSDB_NULLPTR_CHECK (dst, BVIEW_STATUS_INVALID_PARAMETER);
+   
+  /* Get OVSDB port*/
+  BVIEW_OVSDB_PORT_GET (port);
+  
+  /* Convert to String*/
+  sprintf(dst, "%d", port); 
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief   Verify whether a given unit number is valid or not.
+*
+* @param[in]   unit                     -  unit number
+*
+* @retval  BVIEW_STATUS_SUCCESS            if it is a valid unit 
+* @retval  BVIEW_STATUS_FAILURE            if it is not a valid unit
+*
+* @notes  
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbplugin_ovsdb_valid_unit_check(unsigned int unit)
+{
+  int index = 0;
+  BVIEW_STATUS rv = BVIEW_STATUS_FAILURE; 
+ 
+  for (index = 0; index < BVIEW_MAX_ASICS_ON_A_PLATFORM; index++)
+  {
+     if (asicDb[index].unit == unit)
+     {
+       rv = BVIEW_STATUS_SUCCESS;
+       break;
+     }
+  }
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get Network OS
+*
+* @param[out]  buffer                 Pointer to network OS String
+* @param[in]   length                 length of the buffer
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure
+*                                     Failed to get network os
+*
+* @retval   BVIEW_STATUS_SUCCESS      Network OS is successfully
+*                                     queried
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS  sbplugin_ovsdb_system_network_os_get (uint8_t *buffer, int length)
+{
+  SB_OVSDB_NULLPTR_CHECK (buffer, BVIEW_STATUS_INVALID_PARAMETER);
+
+  memcpy (buffer, SBPLUGIN_NETWORK_OS, length);
+  return BVIEW_STATUS_SUCCESS;
+}
+
diff --git a/src/sb_plugin/sb_redirector/Makefile b/src/sb_plugin/sb_redirector/Makefile
new file mode 100755
index 0000000..712be52
--- /dev/null
+++ b/src/sb_plugin/sb_redirector/Makefile
@@ -0,0 +1,35 @@
+MODULE := sbredirector
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+
+# NOOP - no-operation, used to suppress "Nothing to do for ..." messages.
+NOOP  ?= @:
+
+CFLAGS += -Wall -g -I./include -I../include -I../../public 
+
+export OUT_SBREDIRECTOR=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_SBREDIRECTOR=$(MODULE).a
+
+OBJECTS_SBREDIRECTOR := $(patsubst %.c,%.o,$(wildcard *.c))
+
+$(OUT_SBREDIRECTOR)/%.o : %.c
+	@mkdir -p $(OUT_SBREDIRECTOR) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_SBREDIRECTOR)/$(LIBS_SBREDIRECTOR): $(patsubst %,$(OUT_SBREDIRECTOR)/%,$(subst :, ,$(OBJECTS_SBREDIRECTOR))) 
+	@cd $(OUT_SBREDIRECTOR) && $(AR) rvs $(MODULE).a $(OBJECTS_SBREDIRECTOR)  
+
+#default target
+$(MODULE) all: $(OUT_SBREDIRECTOR)/$(LIBS_SBREDIRECTOR) 
+	$(NOOP)
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_SBREDIRECTOR)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_SBREDIRECTOR=$(OUT_SBREDIRECTOR)"
+	@echo "LIBS_SBREDIRECTOR=$(LIBS_SBREDIRECTOR)"
diff --git a/src/sb_plugin/sb_redirector/include/sbplugin_redirect.h b/src/sb_plugin/sb_redirector/include/sbplugin_redirect.h
new file mode 100755
index 0000000..6ada01c
--- /dev/null
+++ b/src/sb_plugin/sb_redirector/include/sbplugin_redirect.h
@@ -0,0 +1,150 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#ifndef INCLUDE_SBPLUGIN_REDIRECT_H
+#define INCLUDE_SBPLUGIN_REDIRECT_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <pthread.h>
+#include "sbplugin.h"
+#include "openapps_log_api.h"
+
+
+/** South bound plug-in redirect plugin list */
+typedef  struct {
+    /** Indicates whether this redirect plugin entry is free or not */
+    bool isInUse;
+    /** South bound plugin data*/ 
+    BVIEW_SB_PLUGIN_t  sbPlugin;
+} BVIEW_SB_REDIRECT_PLUGIN_t;
+
+/** List of South bound plugin data */
+extern BVIEW_SB_REDIRECT_PLUGIN_t sbRedirectPluginList[];
+
+/** Read-Write lock for South bound plug-in redirector */
+extern pthread_rwlock_t sbRedirectRWLock;
+
+/** South bound plug-in redirector debug flag */
+extern int  sbRedirectDebugFlag;
+
+/** Macro to print the South bound plug-in debug information */
+#define SB_REDIRECT_DEBUG_PRINT(severity,format, args...)           \
+                                if (sbRedirectDebugFlag)            \
+                                {                                   \
+                                  log_post(severity,format, ##args);\
+                                }
+
+/* Macro to acquire read lock */
+#define SB_REDIRECT_RWLOCK_RD_LOCK(lock)                             \
+           if (pthread_rwlock_rdlock(&lock) != 0)                    \
+           {                                                         \
+               SB_REDIRECT_DEBUG_PRINT(BVIEW_LOG_ERROR,              \
+			   "(%s:%d) Failed to take Module manager"               \
+               "read write lock for read\n", __FILE__, __LINE__);    \
+               return BVIEW_STATUS_FAILURE;                          \
+           } 
+
+
+/* Macro to acquire write lock */
+#define SB_REDIRECT_RWLOCK_WR_LOCK(lock)                             \
+           if (pthread_rwlock_wrlock(&lock) != 0)                    \
+           {                                                         \
+               SB_REDIRECT_DEBUG_PRINT(BVIEW_LOG_ERROR,              \
+			   "(%s:%d) Failed to take Module manager"               \
+               "read write lock for write\n", __FILE__, __LINE__);   \
+               return BVIEW_STATUS_FAILURE;                          \
+           } 
+
+/* Macro to release RW lock */
+#define SB_REDIRECT_RWLOCK_UNLOCK(lock)                              \
+           if (pthread_rwlock_unlock(&lock) != 0)                    \
+           {                                                         \
+               SB_REDIRECT_DEBUG_PRINT(BVIEW_LOG_ERROR,              \
+			   "(%s:%d) Failed to release Module manager"            \
+               "read write lock          \n", __FILE__, __LINE__);   \
+           } 
+
+
+
+/*********************************************************************
+* @brief   Get Function list for a particular feature based on Silicon type.
+*          A function list is selected in the following order.
+*          1. If an exact match for a silicon is found then that function list 
+*                                                                  is returned.
+*          2. Else return a function list that has support for 
+*                                             all silicon types.
+*                               
+*
+* @param[in]  asicType            Asic type
+* @param[in]  featureId           Feature ID
+*
+* @retval   NULL                   if function fails
+* @retval   FunctionListPtr        Function list that matches with 
+*                                            the silicon type(/all) 
+*
+*
+* @notes    none
+*
+***************************************************************************************/
+extern void *sb_redirect_feature_handle_get(BVIEW_ASIC_TYPE asicType, BVIEW_FEATURE_ID featureId);
+
+/*********************************************************************
+* @brief       Get asic capabilities of a silicon
+*
+* @param[in]  asicType        Asic type
+* @param[out] asicCapPtr      Asic capabilities pointer
+*
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     Asic capabilities for a particular 
+*                                                         asic not found
+*
+* @retval   BVIEW_STATUS_SUCCESS      Asic capabilities are present 
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS  sb_redirect_asic_capabilities_get(BVIEW_ASIC_TYPE asicType, 
+                                                BVIEW_ASIC_CAPABILITIES_t **asicCapPtr);
+ 
+/*********************************************************************
+* @brief       Set debug flag value for south bound plug-in redirector 
+*
+* @param[in]   val       Value
+*                                                                
+*
+* @retval   none
+*
+* @notes    none
+*
+*********************************************************************/
+void sb_redirect_debug_set(int val);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* INCLUDE_SBPLUGIN_REDIRECT_H */
diff --git a/src/sb_plugin/sb_redirector/sbplugin_redirect_bst.c b/src/sb_plugin/sb_redirector/sbplugin_redirect_bst.c
new file mode 100755
index 0000000..316042d
--- /dev/null
+++ b/src/sb_plugin/sb_redirector/sbplugin_redirect_bst.c
@@ -0,0 +1,1967 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include "sbplugin_redirect.h"
+#include "sbfeature_bst.h"
+#include "sbplugin_redirect_system.h"
+
+/*********************************************************************
+* @brief       Get BST configuration
+*
+* @param[in]    asic                  Unit number
+* @param[out]   config                BST config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST config get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST config get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_config_get (int asic, BVIEW_BST_CONFIG_t * config)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }       
+  else if (bstFeaturePtr->bst_config_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {  
+    rv = bstFeaturePtr->bst_config_get_cb (asic, config);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Set BST configuration
+*
+* @param[in]    asic                  Unit number
+* @param[in]    config                BST config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST config set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST config set functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_config_set (int asic, BVIEW_BST_CONFIG_t * config)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }     
+  else if (bstFeaturePtr->bst_config_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  { 
+    rv = bstFeaturePtr->bst_config_set_cb (asic, config);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get BST snapshot
+*
+* @param[in]     asic                  Unit number
+* @param[out]    snapshot              BST snapshot
+* @param[out]    time                  Time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST snapshot get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST snapshot get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_snapshot_get (int asic,
+                                     BVIEW_BST_ASIC_SNAPSHOT_DATA_t * snapshot,
+                                     BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }  
+  else if (bstFeaturePtr->bst_snapshot_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  { 
+    rv = bstFeaturePtr->bst_snapshot_get_cb (asic, snapshot, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Device Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             Device data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Device stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Device stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_device_data_get (int asic,
+                                        BVIEW_BST_DEVICE_DATA_t * data,
+                                        BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }  
+  else if (bstFeaturePtr->bst_device_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  { 
+    rv = bstFeaturePtr->bst_device_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Priority Groups Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              i_p_pg data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Priority Groups 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Priority Groups 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_ippg_data_get (int asic,
+                                      BVIEW_BST_INGRESS_PORT_PG_DATA_t * data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }  
+  else if (bstFeaturePtr->bst_ippg_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {
+    rv = bstFeaturePtr->bst_ippg_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Ingress Port + Service Pools Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             i_p_sp data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_ipsp_data_get (int asic,
+                                      BVIEW_BST_INGRESS_PORT_SP_DATA_t * data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  } 
+  else if (bstFeaturePtr->bst_ipsp_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_ipsp_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Ingress Service Pools Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              i_sp structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_isp_data_get (int asic,
+                                     BVIEW_BST_INGRESS_SP_DATA_t * data,
+                                     BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  } 
+  else if (bstFeaturePtr->bst_isp_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_isp_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Port + Service Pools Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              e_p_sp data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Port + Service Pools
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Port + Service Pools
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_epsp_data_get (int asic,
+                                      BVIEW_BST_EGRESS_PORT_SP_DATA_t * data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }  
+  else if (bstFeaturePtr->bst_epsp_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_epsp_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Service Pools Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              e_sp data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Service Pools
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Service Pools
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_esp_data_get (int asic,
+                                     BVIEW_BST_EGRESS_SP_DATA_t * data,
+                                     BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  } 
+  else if (bstFeaturePtr->bst_esp_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_esp_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Unicast Queues Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             Egress Unicast Queue data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queues
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queues
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_eucq_data_get (int asic,
+                                      BVIEW_BST_EGRESS_UC_QUEUE_DATA_t * data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else if (bstFeaturePtr->bst_eucq_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_eucq_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Unicast Queue Groups Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              Egress Unicast Queue Groups data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queue Groups
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queue Groups
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_eucqg_data_get (int asic,
+                                       BVIEW_BST_EGRESS_UC_QUEUEGROUPS_DATA_t *
+                                       data, BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_eucqg_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_eucqg_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress Multicast Queues Statistics
+*
+* @param[in]    asic             unit
+* @param[out]   data             Egress Multicast Queue data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Multicast Queues
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Multicast Queues
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_emcq_data_get (int asic,
+                                      BVIEW_BST_EGRESS_MC_QUEUE_DATA_t * data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_emcq_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_emcq_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress CPU Queues Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              Egress CPU Queue data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress CPU Queues
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress CPU Queues
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_cpuq_data_get (int asic,
+                                      BVIEW_BST_EGRESS_CPU_QUEUE_DATA_t * data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_cpuq_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_cpuq_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Egress RQE Queues Statistics
+*
+* @param[in]    asic              unit
+* @param[out]   data              Egress RQE Queue data structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress RQE Queues 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress RQE Queues 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_rqeq_data_get (int asic,
+                                      BVIEW_BST_EGRESS_RQE_QUEUE_DATA_t * data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_rqeq_data_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_rqeq_data_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Clear BST stats of a particular unit
+*
+* @param[in]    asic            unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Successfully cleared BST stats 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Clear BST stats functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_clear_stats (int asic)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_clear_stats_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_clear_stats_cb (asic);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Device Statistics
+*
+* @param[in]   asic                unit
+* @param[in]   thres               threshold
+* 
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Device Statistics 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Device Statistics 
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_device_threshold_set (int asic,
+                                             BVIEW_BST_DEVICE_THRESHOLD_t *threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_device_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_device_threshold_set_cb (asic, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for
+*           Ingress Port + Priority Groups Statistics
+*
+* @param[in]   asic               unit
+* @param[in]   port               port
+* @param[in]   pg                 Priority Group
+* @param[out]  thres              Threshold structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Priority Groups 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Priority Groups
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_ippg_threshold_set (int asic, int port, int pg,
+                                           BVIEW_BST_INGRESS_PORT_PG_THRESHOLD_t  *threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_ippg_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_ippg_threshold_set_cb (asic, port, pg, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Ingress Port + Service Pools
+*           Statistics
+*
+* @param[in]  asic                                    unit
+* @param[in]  port                                    port
+* @param[in]  sp                                      service pool
+* @param[in]  thres                                   threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Service Pools 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_ipsp_threshold_set (int asic, int port, int sp,
+                                           BVIEW_BST_INGRESS_PORT_SP_THRESHOLD_t * threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_ipsp_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_ipsp_threshold_set_cb (asic, port, sp, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Ingress Service Pools
+*           Statistics
+*
+* @param[in]  asic                               unit
+* @param[in]  sp                                 service pool
+* @param[in]  thres                              threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Service Pools 
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_isp_threshold_set (int asic, int sp,
+                                          BVIEW_BST_INGRESS_SP_THRESHOLD_t *threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_isp_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_isp_threshold_set_cb (asic, sp, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set Profile configuration for Egress Port + Service Pools
+*           Statistics
+*
+* @param[in]  asic                                  unit
+* @param[in]  port                                  port
+* @param[in]  sp                                    service pool
+* @param[in]  thres                                 threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Port + Service Pools
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Port + Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_epsp_threshold_set (int asic, int port, int sp,
+                                           BVIEW_BST_EGRESS_PORT_SP_THRESHOLD_t *threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_epsp_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_epsp_threshold_set_cb (asic, port, sp, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Service Pools Statistics
+*
+* @param[in]  asic                                unit
+* @param[in]  sp                                  service pool
+* @param[in]  thres                               threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Service Pools
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Service Pools
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_esp_threshold_set (int asic, int sp,
+                                          BVIEW_BST_EGRESS_SP_THRESHOLD_t *threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_esp_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_esp_threshold_set_cb (asic, sp, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Unicast Queues
+*           Statistics
+*
+* @param[in]  asic                            unit
+* @param[in]  ucQueue                         uc queue
+* @param[in]  thres                           threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_eucq_threshold_set (int asic, int ucQueue,
+                                           BVIEW_BST_EGRESS_UC_QUEUE_THRESHOLD_t *threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_eucq_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_eucq_threshold_set_cb (asic, ucQueue, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Unicast Queue Groups
+*           Statistics
+*
+* @param[in] asic                                      unit
+* @param[in] ucQueueGrp                                uc queue group
+* @param[in] thres                                     threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Unicast Queue Groups
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Unicast Queue Groups
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_eucqg_threshold_set (int asic, int ucQueueGrp,
+                                            BVIEW_BST_EGRESS_UC_QUEUEGROUPS_THRESHOLD_t
+                                            * threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_eucqg_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv =
+      bstFeaturePtr->bst_eucqg_threshold_set_cb (asic, ucQueueGrp, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress Multicast Queues
+*           Statistics
+*
+* @param[in]  asic                                   - unit
+* @param[in]  mcQueue                                - mcQueue
+* @param[in]  thres                                  - threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress Multicast Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress Multicast Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_emcq_threshold_set (int asic, int mcQueue,
+                                           BVIEW_BST_EGRESS_MC_QUEUE_THRESHOLD_t
+                                           * threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_emcq_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_emcq_threshold_set_cb (asic, mcQueue, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress CPU Queues
+*           Statistics
+*
+* @param[in]  asic                                    unit
+* @param[in]  cpuQueue                                cpuQueue
+* @param[in]  thres                                   threshold
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress CPU Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress CPU Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_cpuq_threshold_set (int asic, int cpuQueue,
+                                           BVIEW_BST_EGRESS_CPU_QUEUE_THRESHOLD_t
+                                           * threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_cpuq_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_cpuq_threshold_set_cb (asic, cpuQueue, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Set profile configuration for Egress RQE Queues
+*           Statistics
+*
+* @param[in]     asic                    unit
+* @param[in]     rqeQueue                rqeQueue
+* @param[out]    thres                   Threshold data structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Egress RQE Queues
+*                                     threshold set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Egress RQE Queues
+*                                     threshold set functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_rqeq_threshold_set (int asic, int rqeQueue,
+                                           BVIEW_BST_EGRESS_RQE_QUEUE_THRESHOLD_t
+                                           * threshold)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_rqeq_threshold_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_rqeq_threshold_set_cb (asic, rqeQueue, threshold);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Get snapshot of all thresholds configured
+*
+*
+* @param[in]   asic                          unit
+* @param[out]  thresholdSnapshot             threshold snapshot
+* @param[out]  time                          time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Snapshot get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Snapshot get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_threshold_get (int asic,
+                                      BVIEW_BST_ASIC_SNAPSHOT_DATA_t *thresholdSnapshot,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_threshold_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_threshold_get_cb (asic, thresholdSnapshot, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Restore threshold configuration to defaults
+*
+*
+* @param[in] asic                        unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Resetting threshold to default is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Clear threshold functionality is 
+*                                     not supported on this unit
+*
+*
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_clear_thresholds (int asic)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                
+  else if (bstFeaturePtr->bst_clear_thresholds_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_clear_thresholds_cb (asic);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Register hw trigger callback
+*
+*
+* @param[in] asic                  unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Callback is successfully registered 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Trigger callback registration is not supported 
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_register_trigger (int asic,
+                                         BVIEW_BST_TRIGGER_CALLBACK_t callback,
+                                         void *cookie)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else if (bstFeaturePtr->bst_register_trigger_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = bstFeaturePtr->bst_register_trigger_cb (asic, callback, cookie);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+
+/*********************************************************************
+* @brief       Get BST default buffer values 
+*
+* @param[in]     asic                  Unit number
+* @param[out]    snapshot              BST snapshot
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     BST feature is not present or
+*                                     BST south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      BST snapshot get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  BST snapshot get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_bst_default_snapshot_get (int asic,
+                                     BVIEW_BST_ASIC_SNAPSHOT_DATA_t * snapshot)
+{
+  BVIEW_SB_BST_FEATURE_t *bstFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  bstFeaturePtr =
+    (BVIEW_SB_BST_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_BST);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (bstFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }  
+  else if (bstFeaturePtr->bst_default_snapshot_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  { 
+    rv = bstFeaturePtr->bst_default_snapshot_get_cb (asic, snapshot);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+
diff --git a/src/sb_plugin/sb_redirector/sbplugin_redirect_core.c b/src/sb_plugin/sb_redirector/sbplugin_redirect_core.c
new file mode 100755
index 0000000..1e495c4
--- /dev/null
+++ b/src/sb_plugin/sb_redirector/sbplugin_redirect_core.c
@@ -0,0 +1,390 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include <pthread.h>
+#include "sbplugin_redirect.h"
+#include "sbplugin_system.h"
+
+/* sbRedirectPluginList holds the south bound plug-ins that are registered with
+   redirector
+ */
+BVIEW_SB_REDIRECT_PLUGIN_t sbRedirectPluginList[BVIEW_MAX_SUPPORTED_SB_PLUGINS];
+
+/* Read-Write lock for south bound plug-in redirector local data */
+pthread_rwlock_t sbRedirectRWLock;
+
+/* Debug flag                    */
+int sbRedirectDebugFlag = 0;
+
+/*********************************************************************
+* @brief       Initialize South bound redirector's local data with defaults
+*
+* @retval   BVIEW_STATUS_FAILURE   if failed to initialize read-write lock
+*
+* @retval   BVIEW_STATUS_SUCCESS   All the data structures are sucessfully 
+*                                  initialized
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sb_redirector_init ()
+{
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  /* clear sbRedirectPluginList */
+  memset (sbRedirectPluginList, 0x00, sizeof (sbRedirectPluginList));
+  /* Initialize Read Write lock with default attributes */
+  if (pthread_rwlock_init (&sbRedirectRWLock, NULL) != 0)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to create read write lock with deafault attributes\n",
+                             __FILE__, __LINE__);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  return rv;
+}
+
+/*********************************************************************
+* @brief   Get Function list for a particular feature based on Silicon type.
+*          A function list is selected in the following order.
+*          1. If an exact match for a silicon is found then that function list 
+*                                                                  is returned.
+*          2. Else return a function list that has support for 
+*                                             all silicon types.
+*                               
+*
+* @param[in]  asicType            Asic type
+* @param[in]  featureId           Feature ID
+*
+* @retval   NULL                   if function fails
+* @retval   FunctionListPtr        Function list that matches with 
+*                                            the silicon type(/all) 
+*
+*
+* @notes    none
+*
+***************************************************************************************/
+void *sb_redirect_feature_handle_get (BVIEW_ASIC_TYPE asicType,
+                                      BVIEW_FEATURE_ID featureId)
+{
+  unsigned int sbPluginIndex = 0;
+  unsigned int featureListIndex = 0;
+  BVIEW_SB_PLUGIN_t *sbPluginPtr = NULL;
+  BVIEW_SB_FEATURE_t *featurePtr = NULL;
+  BVIEW_SB_FEATURE_t *featurePtrOut = NULL;
+  bool asicEntryFound = false;
+  bool allAsicEntryFound = false;
+
+  /* Acquire Read lock */
+  if (pthread_rwlock_rdlock (&sbRedirectRWLock) != 0)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to take SB redirect read write lock for read\n",
+                             __FILE__, __LINE__);
+    return NULL;
+  }
+
+  /* Loop through the plug-in list */
+  for (sbPluginIndex = 0;
+       sbPluginIndex < (sizeof (sbRedirectPluginList) / sizeof (sbRedirectPluginList[0]))
+       && (asicEntryFound == false); sbPluginIndex++)
+  {                             /* Check for in use entry */
+    if (sbRedirectPluginList[sbPluginIndex].isInUse == true)
+    {
+      sbPluginPtr = &sbRedirectPluginList[sbPluginIndex].sbPlugin;
+      /* Loop through the list of features */
+      for (featureListIndex = 0;
+           (featureListIndex < sbPluginPtr->numSupportedFeatures)
+           && (asicEntryFound == false); featureListIndex++)
+      {
+        featurePtr = sbPluginPtr->featureList[featureListIndex];
+        if (featurePtr == NULL)
+        {
+          continue;
+        }
+        /* Check for feature ID */
+        if (featurePtr->featureId == featureId)
+        {
+          /* Corresponding asic entry for the feature is found */
+          if ((featurePtr->supportedAsicMask == BVIEW_ASIC_TYPE_ALL)
+              && (allAsicEntryFound == false))
+          {
+            featurePtrOut = featurePtr;
+            allAsicEntryFound = true;
+          }
+          else if (((featurePtr->supportedAsicMask & asicType) == asicType)
+                   && (asicEntryFound == false))
+          { 
+	        /* All asic entry is found */
+            featurePtrOut = featurePtr;
+            asicEntryFound = true;
+          }
+        }
+      } /* End of for (featureListIndex = 0; .... */
+    }  /* End of if (sbRedirectPluginList[sb..... */
+  }   /* End of for (sbPluginIndex = 0; (sb..... */
+
+  /* Entry is found */
+  if ((asicEntryFound == true) || (allAsicEntryFound == true))
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_INFO,
+                             "(%s:%d) SB plugin entry is found for feature %d silicon %d\n",
+                             __FILE__, __LINE__, featureId, asicType);
+  }
+  else
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to find SB plugin entry for feature %d, silicon %d\n",
+                             __FILE__, __LINE__, featureId, asicType);
+  }
+  /* Release the read lock */
+  if (pthread_rwlock_unlock (&sbRedirectRWLock) != 0)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to release SB redirect read write lock after read\n",
+                             __FILE__, __LINE__);
+  }
+
+  return (void *) featurePtrOut;
+}
+
+/*********************************************************************
+* @brief       Get asic capabilities of a silicon
+*
+* @param[in]  asicType        Asic type
+* @param[out] asicCapPtr      Asic capabilities pointer
+*
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     Asic capabilities for a particular 
+*                                                         asic not found
+*
+* @retval   BVIEW_STATUS_SUCCESS      Asic capabilities are present 
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sb_redirect_asic_capabilities_get (BVIEW_ASIC_TYPE asicType,
+                                                BVIEW_ASIC_CAPABILITIES_t **asicCapPtr)
+{
+  unsigned int asicListIndex = 0;
+  BVIEW_ASIC_t *asicListPtr = NULL;
+  bool asicEntryFound = false;
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  /* Acquire Read Lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+
+  /* Get system feature's south bound plug-in pointer */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Check for NULL */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+    /* Loop through the asics list in system south bound plug-in */
+    for (asicListIndex = 0;
+         (asicListIndex < systemFeaturePtr->numSupportedAsics)
+         && (asicEntryFound == false); asicListIndex++)
+    {
+      asicListPtr = systemFeaturePtr->asicList[asicListIndex];
+      /* Validate asicListPtr */
+      if (asicListPtr == NULL)
+      {
+        /* Go to next entry */
+        continue;
+      }
+      /* Check for asic type */
+      if (asicListPtr->asicType == asicType)
+      {
+        /* Correct entry found */
+        *asicCapPtr = &(asicListPtr->scalingParams);
+        asicEntryFound = true;
+      }
+    } /* End of for (featureListIndex = 0; .... */
+
+    /* Asic entry is found */
+    if (asicEntryFound == true)
+    {
+      SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_INFO,
+                               "(%s:%d) Asic Cap entry is found for silicon %d\n",
+                               __FILE__, __LINE__, asicType);
+      rv = BVIEW_STATUS_SUCCESS;
+    }
+    else
+    {
+      SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                               "(%s:%d) Failed to find Asic Cap entry for silicon %d\n",
+                               __FILE__, __LINE__, asicType);
+      rv = BVIEW_STATUS_FAILURE;
+    }
+  }
+  /* Release the read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Validate a south bound plug-in w.r.t to max supported 
+*                 features  in a plug-in, and w.r.t to max supported 
+*                 units on a system   
+*
+* @param[in]  sbPlugin        South bound plug-in
+*
+*
+* @retval   BVIEW_STATUS_FAILURE   Validation fails w.r.t max supported
+*                                  features or max supported units on a system
+*
+* @retval   BVIEW_STATUS_SUCCESS   sb plug-in has valid content
+*
+*
+* @notes    none
+*
+*********************************************************************/
+static BVIEW_STATUS sb_plugin_validate (BVIEW_SB_PLUGIN_t sbPlugin)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  unsigned int featureListIndex = 0;
+  BVIEW_SB_FEATURE_t *featurePtr = NULL;
+
+  /* Check for the supported number of features limit */
+  if (sbPlugin.numSupportedFeatures > BVIEW_SBPLUGIN_MAX_FEATURES)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Number of supported features %d in SB plugin are more than"
+                             " max supported limit BVIEW_SBPLUGIN_MAX_FEATURES=%d\n",
+                             __FILE__, __LINE__, sbPlugin.numSupportedFeatures,
+                             BVIEW_SBPLUGIN_MAX_FEATURES);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  for (featureListIndex = 0; (featureListIndex < sbPlugin.numSupportedFeatures);
+       (featureListIndex++))
+  {
+    featurePtr = sbPlugin.featureList[featureListIndex];
+    if (featurePtr == NULL)
+    {
+      continue;
+    }
+    /* Check for feature ID */
+    if (featurePtr->featureId == BVIEW_FEATURE_SYSTEM)
+    {
+      systemFeaturePtr = (BVIEW_SB_SYSTEM_FEATURE_t *) featurePtr;
+      /* Check with max supported units on a platform */
+      if (systemFeaturePtr->numSupportedAsics > BVIEW_MAX_ASICS_ON_A_PLATFORM)
+      {
+        SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                                 "(%s:%d) Number of asics supported %d in System plugin are "
+                                 "more than max supported limit BVIEW_MAX_ASICS_ON_A_PLATFORM = %d\n",
+                                 __FILE__, __LINE__,
+                                 systemFeaturePtr->numSupportedAsics,
+                                 BVIEW_MAX_ASICS_ON_A_PLATFORM);
+        return BVIEW_STATUS_FAILURE;
+      }
+    }
+  }                             /* End of for (featureListIndex = 0; .... */
+
+  return BVIEW_STATUS_SUCCESS;
+}
+
+/*********************************************************************
+* @brief       Register a south bound plug-in with
+*                               south bound redirector
+*
+* @param[in]  sbPlugin        South bound plug-in
+*
+*
+* @retval   BVIEW_STATUS_FAILURE   When validation of sb plug-in fails or
+*                                  Lock acquistion fails 
+*
+* @retval   BVIEW_STATUS_TABLE_FULL  Number of plug-ins already registered 
+*                                    are BVIEW_MAX_SUPPORTED_SB_PLUGINS.
+*
+* @retval   BVIEW_STATUS_SUCCESS    Successfully registered sb plug-in with 
+*                                    sb redirector
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sb_plugin_register (BVIEW_SB_PLUGIN_t sbPlugin)
+{
+  unsigned int sbPluginIndex = 0;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  /* Validate SB plug-in */
+  if (sb_plugin_validate (sbPlugin) == BVIEW_STATUS_FAILURE)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) SB plug-in validation failed\n", __FILE__,
+                             __LINE__);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire write lock */
+  SB_REDIRECT_RWLOCK_WR_LOCK (sbRedirectRWLock);
+
+  /* Loop through the south bound plug-in list to find out free entry */
+  for (sbPluginIndex = 0; (sbPluginIndex < BVIEW_MAX_SUPPORTED_SB_PLUGINS);
+       sbPluginIndex++)
+  {
+    if (sbRedirectPluginList[sbPluginIndex].isInUse == false)
+    {                           /* Found free entry */
+      sbRedirectPluginList[sbPluginIndex].sbPlugin = sbPlugin;
+      sbRedirectPluginList[sbPluginIndex].isInUse = true;
+      SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_INFO,
+                               "(%s:%d) Free SB plugin entry is at index %d \n",
+                               __FILE__, __LINE__, sbPluginIndex);
+      break;
+    }
+  }
+  /* Failed to find Free entry */
+  if (sbPluginIndex == BVIEW_MAX_SUPPORTED_SB_PLUGINS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to find Free SB plugin entry \n",
+                             __FILE__, __LINE__);
+    rv = BVIEW_STATUS_TABLE_FULL;
+  }
+  /* Release write lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Set debug flag value for south bound plug-in redirector
+*
+* @param[in]   val       Value
+*
+*
+* @retval   none
+*
+* @notes    none
+*
+*********************************************************************/
+void sb_redirect_debug_set (int val)
+{
+  sbRedirectDebugFlag = val;
+}
diff --git a/src/sb_plugin/sb_redirector/sbplugin_redirect_packet_trace.c b/src/sb_plugin/sb_redirector/sbplugin_redirect_packet_trace.c
new file mode 100755
index 0000000..60a7f49
--- /dev/null
+++ b/src/sb_plugin/sb_redirector/sbplugin_redirect_packet_trace.c
@@ -0,0 +1,462 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include "sbplugin_redirect.h"
+#include "sbfeature_packet_trace.h"
+#include "sbplugin_redirect_system.h"
+
+/*********************************************************************
+* @brief       Get Packet Trace configuration
+*
+* @param[in]    asic                  Unit number
+* @param[out]   config                Packet Trace config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Packet Trace config get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Packet Trace config get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_drop_reason_config_get_cb (int asic, 
+                                BVIEW_PT_DROP_REASON_CONFIG_t * config)
+{
+  BVIEW_SB_PT_FEATURE_t *ptFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  ptFeaturePtr =
+    (BVIEW_SB_PT_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_PACKET_TRACE);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (ptFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }       
+  else if (ptFeaturePtr->pt_drop_reason_config_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {  
+    rv = ptFeaturePtr->pt_drop_reason_config_get_cb (asic, config);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Set Packet Trace configuration Paramters.
+*
+* @param[in]    asic                  Unit number
+* @param[in]    config                Packet Trace config structure
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Packet Trace config set is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Packet Trace config set functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_drop_reason_config_set (int asic, 
+                                 BVIEW_PT_DROP_REASON_CONFIG_t *config)
+{
+  BVIEW_SB_PT_FEATURE_t *ptFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  ptFeaturePtr =
+    (BVIEW_SB_PT_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_PACKET_TRACE);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (ptFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }     
+  else if (ptFeaturePtr->pt_drop_reason_config_set_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  { 
+    rv = ptFeaturePtr->pt_drop_reason_config_set_cb (asic, config);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Get Mask of ASIC Configurable drop reasons.
+*
+* @param[in]    asic             unit
+* @param[out]   mask             Mask of drop reasons
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Device stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Device stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_asic_supported_drop_reason_get_cb (int asic,
+                                     BVIEW_PT_DROP_REASON_MASK_t *mask)
+{
+  BVIEW_SB_PT_FEATURE_t *ptFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  ptFeaturePtr =
+    (BVIEW_SB_PT_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_PACKET_TRACE);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (ptFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }  
+  else if (ptFeaturePtr->pt_supported_drop_reason_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  { 
+    rv = ptFeaturePtr->pt_supported_drop_reason_get_cb (asic, mask);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Trace Profile for a given packet.
+*
+* @param[in]    asic              unit
+* @param[out]   traceProfile      Trace Profile Data Struture             
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Priority Groups 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Priority Groups 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_trace_profile_get_cb (int asic,  int  port,
+                                      BVIEW_PT_PACKET_t *packet,
+                                      BVIEW_PT_TRACE_PROFILE_t *traceProfile,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_PT_FEATURE_t *ptFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  ptFeaturePtr =
+    (BVIEW_SB_PT_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_PACKET_TRACE);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (ptFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }  
+  else if (ptFeaturePtr->pt_trace_profile_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {
+    rv = ptFeaturePtr->pt_trace_profile_get_cb (asic, port, packet, traceProfile, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Obtain Drop Counter Report for all Drop Reasons.
+*
+* @param[in]    asic             unit
+* @param[out]   data             i_p_sp data structure
+* @param[out]   time             time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Port + Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Port + Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_drop_counter_get_cb (int asic,
+                                      BVIEW_PT_DROP_COUNTER_REPORT_t *data,
+                                      BVIEW_TIME_t * time)
+{
+  BVIEW_SB_PT_FEATURE_t *ptFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  ptFeaturePtr =
+    (BVIEW_SB_PT_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_PACKET_TRACE);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (ptFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  } 
+  else if (ptFeaturePtr->pt_drop_counter_get_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = ptFeaturePtr->pt_drop_counter_get_cb (asic, data, time);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Clear all configured Drop Reasons.
+*
+* @param[in]    asic              unit
+* @param[out]   data              i_sp structure
+* @param[out]   time              time
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Ingress Service Pools 
+*                                     stat get is successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Ingress Service Pools 
+*                                     stat get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_clear_drop_reason_cb (int asic)
+{
+  BVIEW_SB_PT_FEATURE_t *ptFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  ptFeaturePtr =
+    (BVIEW_SB_PT_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_PACKET_TRACE);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (ptFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  } 
+  else if (ptFeaturePtr->pt_clear_drop_reason_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = ptFeaturePtr->pt_clear_drop_reason_cb (asic);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief  Register hw trigger callback
+*
+*
+* @param[in] asic                  unit
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Not able to get asic type of this unit or
+*                                     Packet Trace feature is not present or
+*                                     Packet Trace south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      Callback is successfully registered 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  Trigger callback registration is not supported 
+*
+*
+* @notes    none
+*
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_pt_register_trigger_cb (int asic,
+                                         BVIEW_PT_TRIGGER_CALLBACK_t callback,
+                                         void *cookie)
+{
+  BVIEW_SB_PT_FEATURE_t *ptFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get best matching south bound feature functions based on Asic type */
+  ptFeaturePtr =
+    (BVIEW_SB_PT_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                               BVIEW_FEATURE_PACKET_TRACE);
+  /* Validate feature pointer and south bound handler. 
+   * Call south bound handler                        */    
+  if (ptFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else if (ptFeaturePtr->pt_register_trigger_cb == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = ptFeaturePtr->pt_register_trigger_cb (asic, callback, cookie);
+  }
+  /* Release read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
diff --git a/src/sb_plugin/sb_redirector/sbplugin_redirect_system.c b/src/sb_plugin/sb_redirector/sbplugin_redirect_system.c
new file mode 100755
index 0000000..fb9dec0
--- /dev/null
+++ b/src/sb_plugin/sb_redirector/sbplugin_redirect_system.c
@@ -0,0 +1,1275 @@
+/*****************************************************************************
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ***************************************************************************/
+
+#include "sbplugin_redirect.h"
+#include "sbplugin_system.h"
+
+/*********************************************************************
+* @brief       Get number of units in the system
+*
+* @param[out]  unitNum            Numbers of units
+*
+* @retval   BVIEW_STATUS_FAILURE   When lock acquistion fails or
+*                                  System feature is not avaialable or
+*                                  The number of units is '0'
+*
+* @retval   BVIEW_STATUS_SUCCESS   Read number of units from system feature
+*                                  handler sucessfully
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_num_units_get (int *unitNum)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+
+  /* Get system south bound plug-in based on Asic type */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate System feature pointer and the data in the system feature */ 
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else if ((systemFeaturePtr->numSupportedAsics) == 0)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    /* Get number of units in the system */
+    *unitNum = systemFeaturePtr->numSupportedAsics;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get asic type of a  unit
+*
+* @param[int]  asic        Unit number
+* @param[out]  asicType    Asic type of unit
+*
+* @retval   BVIEW_STATUS_FAILURE   When lock acquistion fails or
+*                                  System feature is not avaialable or
+*                                  The number of units is '0' or 
+*                                  unit entry is not found
+*
+* @retval   BVIEW_STATUS_SUCCESS   Able to convert unit number to asic type
+*                                  sucessfully
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_unit_to_asic_type_get (int asic,
+                                                 BVIEW_ASIC_TYPE * asicType)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_t *asicInfoPtr = NULL;
+  int asicListIndex = 0;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in based on Asic type */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *)
+    sb_redirect_feature_handle_get (BVIEW_ASIC_TYPE_ALL, BVIEW_FEATURE_SYSTEM);
+
+  /* Validate System feature pointer and the data in the system feature */ 
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else if ((systemFeaturePtr->numSupportedAsics) == 0)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+    /* Loop through asic list in the system plug-in */
+    for (asicListIndex = 0; asicListIndex < systemFeaturePtr->numSupportedAsics;
+         asicListIndex++)
+    {
+      asicInfoPtr = systemFeaturePtr->asicList[asicListIndex];
+      if ((asicInfoPtr != NULL) && (asicInfoPtr->unit == asic))
+      {
+        /* Get asic type */
+        *asicType = asicInfoPtr->asicType;
+        break;
+      }
+    }
+    /* Failed to find the correct entry */
+    if (asicListIndex == systemFeaturePtr->numSupportedAsics)
+    {
+      rv = BVIEW_STATUS_FAILURE;
+    }
+    else
+    {
+      rv = BVIEW_STATUS_SUCCESS;
+    }
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get system name
+*
+* @param[out]  buffer        System name
+* @param[in]   length        Buffer length
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_name_get (char *buffer, int length)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate system feature pointer and south bound handler.
+   * Call south bound handler                               */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                              
+  else if ((systemFeaturePtr->system_name_get_cb) == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = systemFeaturePtr->system_name_get_cb (buffer, length);
+  }
+  /* Release read-lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get system MAC address
+*
+* @param[out]  buffer        System MAC address
+* @param[in]   length        Buffer length
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for mac get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System mac get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_mac_get (uint8_t * buffer, int length)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate system feature pointer and south bound handler.
+   * Call south bound handler                               */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                              
+  else if ((systemFeaturePtr->system_mac_get_cb) == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = systemFeaturePtr->system_mac_get_cb (buffer, length);
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get system IPv4 address
+*
+* @param[out]  buffer        IPv4 address
+* @param[in]   length        Buffer length
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for ipv4 get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System  ipv4 get functionality is 
+*                                     not supported on this unit
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_ip4_get (uint8_t * buffer, int length)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate system feature pointer and south bound handler.
+   * Call south bound handler                               */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                              
+  else if ((systemFeaturePtr->system_ip4_get_cb) == NULL)
+  {
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = systemFeaturePtr->system_ip4_get_cb (buffer, length);
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get system asic number from notational asic number
+*                                  representation - string form
+*
+* @param[in]   src           Asic number in notational(string) form
+* @param[out]  asic        System asic number 
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_translate_from_notation(char *src, int *asic)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate system feature pointer and south bound handler.
+   * Call south bound handler                               */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                              
+  else if ((systemFeaturePtr->system_asic_translate_from_notation_cb) == NULL)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                           "(%s:%d) System feature does not support"
+                           "system_asic_translate_from_notation call back\n",
+                           __FILE__, __LINE__);
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = systemFeaturePtr->system_asic_translate_from_notation_cb(src, asic);
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_DEBUG,
+                    "(%s:%d) After calling "
+                    "system_asic_translate_from_notation call back"
+                    " src=%s, asic = %d, rv = %d\n",
+                     __FILE__, __LINE__,src, *asic, rv);
+  }
+  /* Release read-lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get asic number in notational representation(string) 
+*                from system asic number
+*
+* @param[in]  asic        System asic number 
+* @param[out] dst         Asic number in notational(string) form
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_translate_to_notation(int asic, char *dst)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate system feature pointer and south bound handler.
+   * Call south bound handler                               */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                              
+  else if ((systemFeaturePtr->system_asic_translate_to_notation_cb) == NULL)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                           "(%s:%d) System feature does not support"
+                           "system_asic_translate_to_notation call back\n",
+                           __FILE__, __LINE__);
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    dst[0] = 0;
+    rv = systemFeaturePtr->system_asic_translate_to_notation_cb(asic, dst);
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_DEBUG,
+                    "(%s:%d) After calling "
+                    "system_asic_translate_to_notation call back"
+                    " asic = %d, dst = %s, rv = %d\n",
+                     __FILE__, __LINE__,asic, dst, rv);
+  }
+  /* Release read-lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get system port number from notational port number
+*                                  representation - string form
+*
+* @param[in]   src         Port number in notational(string) form
+* @param[out]  port        System port number 
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_port_translate_from_notation(char *src, int *port)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate system feature pointer and south bound handler.
+   * Call south bound handler                               */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                              
+  else if ((systemFeaturePtr->system_port_translate_from_notation_cb) == NULL)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                           "(%s:%d) System feature does not support"
+                           "system_port_translate_from_notation call back\n",
+                           __FILE__, __LINE__);
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    rv = systemFeaturePtr->system_port_translate_from_notation_cb(src, port);
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_DEBUG,
+                    "(%s:%d) After calling "
+                    "system_port_translate_from_notation call back"
+                    " src=%s, port = %d, rv = %d\n",
+                     __FILE__, __LINE__,src, *port, rv);
+  }
+  /* Release read-lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get port number in notational representation(string) 
+*                from system port number and asic number
+*
+* @param[in]  asic        System asic number 
+* @param[in]  port        System port number 
+* @param[out] dst         Port number in notational(string) form
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     System feature is not present or
+*                                     System south bound function has returned failure
+*
+* @retval   BVIEW_STATUS_SUCCESS      System south bound function for name get is
+*                                     successful 
+*
+* @retval   BVIEW_STATUS_UNSUPPORTED  System name get functionality is 
+*                                     not supported on this unit
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_port_translate_to_notation(int asic, int port, char *dst)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get system south bound plug-in */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate system feature pointer and south bound handler.
+   * Call south bound handler                               */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }                              
+  else if ((systemFeaturePtr->system_port_translate_to_notation_cb) == NULL)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                           "(%s:%d) System feature does not support"
+                           "system_port_translate_to_notation call back\n",
+                           __FILE__, __LINE__);
+    rv = BVIEW_STATUS_UNSUPPORTED;
+  }
+  else
+  {                              
+    dst[0] = 0;
+    rv = systemFeaturePtr->system_port_translate_to_notation_cb(asic, port, dst);
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_DEBUG,
+                    "(%s:%d) After calling "
+                    "system_port_translate_to_notation call back"
+                    " asic = %d, port = %d, dst = %s, rv = %d\n",
+                     __FILE__, __LINE__,asic, port, dst, rv);
+  }
+  /* Release read-lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+/*********************************************************************
+* @brief       Get asic capabilites of a unit
+*
+* @param[in]   asic          Unit number
+* @param[out]  asicCapPtr    Pointer to asic capabilities  
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Found asic capabilities
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_capabilities_get (int asic, 
+                                          BVIEW_ASIC_CAPABILITIES_t *asicCapPtr)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtrLocal = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtrLocal) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_INFO,
+                             "(%s:%d) Found Asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    *asicCapPtr = *asicCapPtrLocal;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of ports in a unit
+*
+* @param[in]   asic          Unit number
+* @param[out]  numPorts      Number of ports
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of ports is successful
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_ports_get (int asic, int *numPorts)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+	/* Get number of ports on the silicon */
+    *numPorts = asicCapPtr->numPorts;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of unicast queues in a unit
+*
+* @param[in]   asic                  Unit number
+* @param[out]  numUnicastQueues      Number of Unicast queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of unicast queues is successful
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_ucq_get (int asic, int *numUnicastQueues)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    /* Get number of unicast queues */
+    *numUnicastQueues = asicCapPtr->numUnicastQueues;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of unicast queue groups in a unit
+*
+* @param[in]   asic                    Unit number
+* @param[out]  numUnicastQueueGroups   Number of Unicast queue groups
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of unicast queue groups 
+*                                     is successful
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_ucqg_get (int asic,
+                                             int *numUnicastQueueGroups)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+    /* Get number of Unicast queue groups */
+    *numUnicastQueueGroups = asicCapPtr->numUnicastQueueGroups;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of multicast queues in a unit
+*
+* @param[in]   asic                    Unit number
+* @param[out]  numMulticastQueueGroups   Number of Multicast queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of multicast queues 
+*                                     is successful
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_mcq_get (int asic, int *numMulticastQueues)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+    /* Get number of multi cast queues */
+    *numMulticastQueues = asicCapPtr->numMulticastQueues;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of service pools in a unit
+*
+* @param[in]   asic                    Unit number
+* @param[out]  numServicePools         Number of Service pools
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of service pools 
+*                                     is successful
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_sp_get (int asic, int *numServicePools)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+	/* Get number of service pools */
+    *numServicePools = asicCapPtr->numServicePools;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of common pools in a unit
+*
+* @param[in]   asic                  Unit number
+* @param[out]  numCommonPools        Number of common pools
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of common pools 
+*                                     is successful
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_cp_get (int asic, int *numCommonPools)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+	/* Get Number of common pools */
+    *numCommonPools = asicCapPtr->numCommonPools;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of cpu queues in a unit
+*
+* @param[in]   asic                Unit number
+* @param[out]  numCpuQueues        Number of cpu queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of cpu queues 
+*                                     is successful
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_cpuq_get (int asic, int *numCpuQueues)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    /* Get number of CPU queues */
+    *numCpuQueues = asicCapPtr->numCpuQueues;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of RQE queues in a unit
+*
+* @param[in]   asic                Unit number
+* @param[out]  numRqeQueues        Number of RQE queues
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of RQE queues 
+*                                     is successful
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_rqeq_get (int asic, int *numRqeQueues)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    /* Get number of RQE queues  */
+    *numRqeQueues = asicCapPtr->numRqeQueues;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of RQE queue pools in a unit
+*
+* @param[in]   asic                Unit number
+* @param[out]  numRqeQueuePools    Number of RQE queue pools
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of RQE queue pools
+*                                     is successful
+*
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_rqeqp_get (int asic, int *numRqeQueuePools)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    /* Get number of RQE queue pools */
+    *numRqeQueuePools = asicCapPtr->numRqeQueuePools;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get number of priority groups in a unit
+*
+* @param[in]   asic                 Unit number
+* @param[out]  numPriorityGroups    Number of priority groups
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Get number of priority groups
+*                                     is successful
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_num_pg_get (int asic, int *numPriorityGroups)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /* Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  { 
+    /* get number of priority groups */
+    *numPriorityGroups = asicCapPtr->numPriorityGroups;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get whether a unit supports 1588 or not
+*
+* @param[in]   asic                 Unit number
+* @param[out]  support1588          Support for 1588
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or 
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Unit's capability for 1588 is successfully 
+*                                     queried
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS sbapi_system_asic_support_1588_get (int asic, bool * support1588)
+{
+  BVIEW_ASIC_TYPE asicType;
+  BVIEW_ASIC_CAPABILITIES_t *asicCapPtr = NULL;
+  BVIEW_STATUS rv;
+
+  /*  Get asic type of the unit */
+  if (sbapi_system_unit_to_asic_type_get (asic, &asicType) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic type for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    return BVIEW_STATUS_FAILURE;
+  }
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+  /* Get asic capabilities based on asic type */
+  if (sb_redirect_asic_capabilities_get (asicType, &asicCapPtr) !=
+      BVIEW_STATUS_SUCCESS)
+  {
+    SB_REDIRECT_DEBUG_PRINT (BVIEW_LOG_ERROR,
+                             "(%s:%d) Failed to get asic capabilities for unit %d \n",
+                             __FILE__, __LINE__, asic);
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+	/* Get support for 1588 */
+    *support1588 = asicCapPtr->support1588;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get Supported Feature Mask
+*
+* @param[out]  featureMask            Supported Feature Mask
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure or
+*                                     Failed to get asic type from unit or
+*                                     Failed to get asic capabilites for this unit
+*
+* @retval   BVIEW_STATUS_SUCCESS      Supported Feature Mask is successfully 
+*                                     queried
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_feature_mask_get (int *featureMask)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+
+  /* Get system south bound plug-in based on Asic type */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate System feature pointer and the data in the system feature */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else if ((systemFeaturePtr->numSupportedAsics) == 0)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+    /* Get number of units in the system */
+    *featureMask = systemFeaturePtr->featureMask;
+    rv = BVIEW_STATUS_SUCCESS;
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
+/*********************************************************************
+* @brief       Get Network OS
+*
+* @param[out]  buffer                 Pointer to network OS String
+* @param[in]   length                 length of the buffer
+*
+* @retval   BVIEW_STATUS_FAILURE      Due to lock acquistion failure
+*                                     Failed to get network os
+*
+* @retval   BVIEW_STATUS_SUCCESS      Network OS is successfully
+*                                     queried
+*
+* @notes    none
+*
+*********************************************************************/
+BVIEW_STATUS  sbapi_system_network_os_get (uint8_t *buffer, int length)
+{
+  BVIEW_SB_SYSTEM_FEATURE_t *systemFeaturePtr = NULL;
+  BVIEW_STATUS rv = BVIEW_STATUS_SUCCESS;
+  BVIEW_ASIC_TYPE asicType = BVIEW_ASIC_TYPE_ALL;
+
+  /* Acquire Read lock */
+  SB_REDIRECT_RWLOCK_RD_LOCK (sbRedirectRWLock);
+
+  /* Get system south bound plug-in based on Asic type */
+  systemFeaturePtr =
+    (BVIEW_SB_SYSTEM_FEATURE_t *) sb_redirect_feature_handle_get (asicType,
+                                                                  BVIEW_FEATURE_SYSTEM);
+  /* Validate System feature pointer and the data in the system feature */
+  if (systemFeaturePtr == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else if ((systemFeaturePtr->system_network_os_get_cb) == NULL)
+  {
+    rv = BVIEW_STATUS_FAILURE;
+  }
+  else
+  {
+    /* Get number of units in the system */
+    rv = systemFeaturePtr->system_network_os_get_cb (buffer, length);
+  }
+  /* Release Read lock */
+  SB_REDIRECT_RWLOCK_UNLOCK (sbRedirectRWLock);
+  return rv;
+}
+
diff --git a/tests/BST_Feature_test.md b/tests/BST_Feature_test.md
new file mode 100755
index 0000000..c4c12b8
--- /dev/null
+++ b/tests/BST_Feature_test.md
@@ -0,0 +1,362 @@
+# ops-broadview Test Cases
+
+
+[TOC]
+
+##  Test get_bst_feature API ##
+### Objective ###
+Verify that the get_bst_feature API call yields 200 OK and the JSON response yields an expected parameter list defined in the associated testCaseJsonStrings.ini file.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call get_bst_feature API through REST with the following JSON data to POST to the BroadViewAgent.
+
+ -      {"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the following parameters present in the JSON response.
+ -      stat-units-in-cells,collection-interval,async-full-reports,send-async-reports,send-snapshot-on-trigger,trigger-rate-limit,trigger-rate-limit-interval,stats-in-percentage,bst-enable
+ 
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+ 
+
+## Test get_bst_tracking API  ##
+### Objective ###
+Verify that the get_bst_tracking API call yields 200 OK and the JSON response yields expected parameter list defined in the associated testCaseJsonStrings.ini file.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call get_bst_tracking API through REST with the following JSON data to POST to the BroadViewAgent.
+ -     {"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the following parameters present in the JSON response.
+ -     track-peak-stats,track-ingress-port-priority-group,track-ingress-port-service-pool,track-ingress-service-pool,track-egress-port-service-pool,track-egress-service-pool,track-egress-uc-queue,track-egress-uc-queue-group,track-egress-mc-queue,track-egress-cpu-queue,track-egress-rqe-queue,track-device
+  
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+
+ 
+# Test get_bst_thresholds API  ##
+### Objective ###
+Verify that the get_bst_threshold REST API call with the user configurable parameters yields 200 OK and receives an associated realm and it's data in the JSON response.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent. Set include-ingress-port-priority-group to 1 in the params section.
+ -     {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the parameter set in the input JSON request received a realm and data in the JSON response. 
+2. Repeat step no 1 by resetting the param set in step 1 to 0 and setting the next parameter in the params list to 1 and posting the request. The verification criteria is same as step 1.
+ 
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+
+# Test get_bst_report API  ##
+### Objective ###
+Verify that the get_bst_report REST API call with the user configurable parameters yields 200 OK and receives an associated realm and it's data in the JSON response.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call get_bst_report API through REST with the following JSON data to POST to the BroadViewAgent. Set include-ingress-port-priority-group to 1 in the params section.
+ -     {"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the parameter set in the input JSON request received a realm and data in the JSON response. 
+2. Repeat step no 1 by resetting the param set in step 1 to 0 and setting the next parameter in the params list to 1 and posting the request. The verification criteria is same as step 1.
+ 
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+ 
+# Test clear_bst_statistics API  ##
+### Objective ###
+Verify that the clear_bst_statistics REST API call yields 200 OK.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call clear_bst_statistrics API through REST with the following JSON data to POST to the BroadViewAgent. 
+ -     {"jsonrpc": "2.0", "method": "clear-bst-statistics", "params": { }, "id": 1, "asic-id":"1"} 
+ - Verify 200 OK is received from the agent.
+
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+
+
+# Test clear_bst_thresholds API  ##
+### Objective ###
+Verify that the clear_bst_thresholds REST API call yields 200 OK.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call clear_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent.
+ -     {"jsonrpc": "2.0", "method": "clear-bst-statistics", "params": { }, "id": 1, "asic-id":"1"} 
+ - Verify 200 OK is received from the agent.
+
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+ 
+# Test configure_bst_feature API  ##
+### Objective ###
+Verify that the configure_bst_feature REST API call with the user configurable parameters yields 200 OK and reflects the associated configuration in the JSON response.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call configure_bst_feature API through REST with the following JSON data to POST to the BroadViewAgent. Keep all parameters to 0 values, except trigger-rate-limit and trigger-rate-limit-interval.
+      {"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0, "stats-in-percentage": 0}}
+ - Verify 200 OK is received from the agent.
+
+2. Call get_bst_feature API through REST with the following JSON data
+ -      {"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the following parameters present in the JSON response.
+ -      stat-units-in-cells,collection-interval,async-full-reports,send-async-reports,send-snapshot-on-trigger,trigger-rate-limit,trigger-rate-limit-interval,stats-in-percentage,bst-enable
+ - Verify that the JSON response has the correct configuration reflected as per step 1.
+3. Repeat step 1 and step 2 for configuring other parameters from the params section. The verification crieteria is same.
+
+
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+
+# Test configure_bst_tracking API  ##
+### Objective ###
+Verify that the configure_bst_tracking REST API call with the user configurable parameters yields 200 OK and reflects the associated configuration in the JSON response.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call configure_bst_tracking API through REST with the following JSON data to POST to the BroadViewAgent. Keep all parameters to 0 values.
+ -     {"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+ - Verify 200 OK is received from the agent.
+
+2. Call get_bst_tracking API through REST with the following JSON data
+ -      {"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the following parameters present in the JSON response.
+ -     track-peak-stats,track-ingress-port-priority-group,track-ingress-port-service-pool,track-ingress-service-pool,track-egress-port-service-pool,track-egress-service-pool,track-egress-uc-queue,track-egress-uc-queue-group,track-egress-mc-queue,track-egress-cpu-queue,track-egress-rqe-queue,track-device 
+ - Verify that the JSON response has the correct configuration reflected as per step 1.
+3. Repeat step 1 and step 2 for configuring other parameters from the params section. The verification crieteria is same.
+
+
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
+
+# Test configure_bst_thresholds API  ##
+### Objective ###
+Verify that the configure_bst_thresholds REST API call with the user configurable parameters yields 200 OK and reflects the associated configuration in the JSON response.
+### Requirements ###
+ - Virtual Mininet Test Setup
+ - serverSetupDetails.ini -- specify if the target switch_type is genericx86-64 or as5712 (default is genericx86-64). 
+ - If target switch type is as5712, user needs to specify the IP of the management interface of the switch and the port on which the BroadViewAgent service is running.
+ - If test is executed on the target=as5712, user needs to manually start the BroadViewAgent service on the switch.
+ - testCaseJsonStrings.ini -- Contains the JSON strings need to be posted to the BroadViewAgent through REST API for each step
+#### Topology Diagram ####
+```
+[h1]<-->[s1]
+```
+### Description ###
+1. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "ingress-port-priority-group".
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "ingress-port-priority-group", "port": "1", "priority-group": 1, "um-share-threshold": 10, "um-headroom-threshold": 10  }, "id": 1, "asic-id":"1"} 
+  - Verify 200 OK is received from the agent.
+ 
+2. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-ingress-port-priority-group"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+3. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "ingress-port-service-pool".
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "ingress-port-service-pool", "port": "1", "service-pool": 1, "um-share-threshold": 10 }, "id": 1, "asic-id":"1"
+  - Verify 200 OK is received from the agent.
+
+4. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-ingress-port-service-pool"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 1, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+5. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "ingress-service-pool".
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "ingress-service-pool", "service-pool": 1, "um-share-threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+6. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-ingress-service-pool"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 1, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+ 
+7. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "egress-port-service-pool"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-port-service-pool", "port": "1", "service-pool": 1, "uc-share-threshold": 10, "um-share-threshold": 10, "mc-share-threshold": 10, "mc-share-queue-entries-threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+8. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-egress-port-service-pool"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 1, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+9. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "egress-service-pool"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-service-pool", "service-pool": 1, "um-share-threshold": 10, "mc-share-threshold": 10, "mc-share-queue-entries-threshold": 10  }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+10. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-egress-service-pool"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 1, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+11. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "egress-uc-queue"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-uc-queue", "queue": 1, "uc-threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+12. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-egress-uc-queue"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 1, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+13. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "egress-uc-queue-group"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-uc-queue-group", "queue-group": 1, "uc-threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+14. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-egress-uc-queue-group"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 1, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+15. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "egress-mc-queue"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-mc-queue", "queue": 1, "mc-threshold": 10, "mc-queue-entries-threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+16. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-egress-mc-queue"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 1, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+17. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "egress-cpu-queue"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-cpu-queue", "queue": 1, "cpu-threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+18. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-egress-cpu-queue"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 1, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+ 
+19. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "egress-rqe-queue"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-rqe-queue", "queue": 1, "rqe-threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+20. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-egress-rqe-queue"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 1, "include-device": 0 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+
+21. Call configure_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param realm "device"
+  -     {"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "device", "threshold": 10 }, "id": 1, "asic-id":"1"}
+  - Verify 200 OK is received from the agent.
+
+22. Call get_bst_thresholds API through REST with the following JSON data to POST to the BroadViewAgent for the param "include-device"
+ -      {"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 1 }, "id": 1, "asic-id":"1"}
+ - Verify 200 OK status code is received from the agent.
+ - Verify the response JSON is received with out any errors.
+ - Verify the realm and its associated data is present on the JSON response.
+ 
+### Test Result Criteria ###
+#### Test Pass Criteria ####
+All verifications pass.
+#### Test Fail Criteria ####
+One or more verifications fail.
diff --git a/tests/BstRestService.py b/tests/BstRestService.py
new file mode 100644
index 0000000..d9d1de4
--- /dev/null
+++ b/tests/BstRestService.py
@@ -0,0 +1,265 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import json
+import bstRest as rest
+import urllib2
+import sys
+
+
+class BstRestService(object):
+
+    def __init__(self, switch_ip='localhost',port='8080'):
+        self.url = 'http://'+switch_ip+':'+port+'/broadview/bst/'
+        self.verbose = False
+
+    def setVerbose(self):
+        '''
+        setVerbose:
+        API to set verbosity level for the session.
+        No Arguments, sets self.verbose.
+        '''
+        self.verbose = True
+
+    def clearVerbose(self):
+        '''
+        clearVerbose:
+        API to clear verbosity level for the session.
+        No Arguments, clears self.verbose.
+        '''
+        self.verbose = False
+
+    def setURL(self, url):
+        '''
+        setURL:
+        API to set base URL for the controller.
+        No Arguments, sets self.url.
+        '''
+        self.url = url
+
+    def getURL(self):
+        '''
+        getURL:
+        API to get base URL for the controller.
+        No Arguments, gets self.url.
+        '''
+        return self.url
+
+    def getResponse(self):
+        '''
+        getResponse:
+        API to make REST GET request.
+        Takes URL, returns (code, value) pair.
+            code: HTTP response code or 555 (for other errors) or Invalid when server not reachable
+            value: JSON response object of error string.
+        '''
+        
+        methodUrl = self.url
+
+        if self.verbose:
+            print 'Req URL: ', self.url
+        res = rest.get(methodUrl, self.verbose)
+        if isinstance(res["response"], urllib2.URLError):
+            return (555, res.reason)
+        else:
+            try:
+                return (res["response"].status, res["data"])
+            except Exception as e:
+                if hasattr(res["response"],"status") and hasattr(res["response"],"reason"):
+                    return (res["response"].status, res["response"].reason)
+                else:
+                    return "INVALID",str(e)
+
+    def postResponse(self, data):
+        '''
+        postResponse:
+        API to make REST POST request.
+        Takes URL, and data (generally a json string).
+        Returns (code, value) pair.
+            code: HTTP response code or 555 (for other errors) or Invalid when server not reachable
+            value: JSON response object of error string.
+        '''
+        
+        broadViewMethod = json.loads(data)[u'method']
+        methodUrl = self.url+broadViewMethod+'/'
+
+        if self.verbose:
+            print 'Req URL: ', methodUrl
+        res = rest.post(methodUrl, data, self.verbose)
+        if isinstance(res, urllib2.URLError):
+            return (555, res.reason)
+        else:
+            try:
+                return (res["response"].status, res["data"])
+            except Exception as e:
+                if hasattr(res["response"],"status") and hasattr(res["response"],"reason"):
+                    return (res["response"].status, res["response"].reason)
+                else:
+                    return "INVALID",str(e)
+
+    def putResponse(self, data):
+        '''
+        putResponse:
+        API to make REST PUT request.
+        Takes URL, and data (generally a json string).
+        Returns (code, value) pair.
+            code: HTTP response code or 555 (for other errors) or Invalid when server not reachable
+            value: JSON response object of error string.
+        '''
+        
+        broadViewMethod = json.loads(data)[u'method']
+        methodUrl = self.url+broadViewMethod+'/'
+
+        if self.verbose:
+            print 'Req URL: ', methodUrl
+        res = rest.put(methodUrl, data, self.verbose)
+        if isinstance(res, urllib2.URLError):
+            return (555, res.reason)
+        else:
+            try:
+                return (res["response"].status, res["data"])
+            except Exception as e:
+                if hasattr(res["response"],"status") and hasattr(res["response"],"reason"):
+                    return (res["response"].status, res["response"].reason)
+                else:
+                    return "INVALID",str(e)
+
+    def deleteResponse(self, data):
+        '''
+        daleteResponse:
+        API to make REST DELETE request.
+        Takes URL, and data (generally a json string on None).
+        Returns (code, value) pair.
+            code: HTTP response code or 555 (for other errors) or Invalid when server not reachable
+            value: JSON response object of error string.
+        '''
+        
+        broadViewMethod = json.loads(data)[u'method']
+        methodUrl = self.url+broadViewMethod+'/'
+
+        if self.verbose:
+            print 'Req URL: ', methodUrl
+        res = rest.delete(methodUrl, data,self.verbose)
+        if isinstance(res, urllib2.URLError):
+            return (555, res.reason)
+        else:
+            try:
+                return (res["response"].status, res["data"])
+            except Exception as e:
+                if hasattr(res["response"],"status") and hasattr(res["response"],"reason"):
+                    return (res["response"].status, res["response"].reason)
+                else:
+                    return "INVALID",str(e)
+
+    @staticmethod
+    def jsonData(data,padding=0):
+        """ prints json response in human readable format """
+        jstr = data
+        for ele in jstr.keys():
+            val = str(jstr[ele])
+            if isinstance(jstr[ele],dict) or isinstance(jstr[ele], list):
+                val = ""
+    
+            print(" " * padding + "   %-35s       :    %-20s"%(ele, val))
+            if isinstance(jstr[ele],dict):
+                subDict = jstr[ele]
+                BstRestService.jsonData(subDict,padding+5)
+    
+            if isinstance(jstr[ele],list):
+                for li in jstr[ele]:
+                    if isinstance(li,dict):
+                        BstRestService.jsonData(li,padding+5)
+                    else:
+                        print(" " * (padding+5) + "   %-35s"%(str(li)))
+
+    @staticmethod
+    def flattenJson(d, result=None):
+        """ flattens the given json into single key value pair """
+        if result is None:
+            result = {}
+        for key in d:
+            value = d[key]
+            if isinstance(value, dict):
+                value1 = {}
+                for keyIn in value:
+                    value1[".".join([key,keyIn])]=value[keyIn]
+                BstRestService.flattenJson(value1, result)
+            elif isinstance(value, (list, tuple)):
+                for indexB, element in enumerate(value):
+                    if isinstance(element, dict):
+                        value1 = {}
+                        index = 0
+                        for keyIn in element:
+                            newkey = ".".join([key,keyIn])
+                            value1[".".join([key,keyIn])]=value[indexB][keyIn]
+                            index += 1
+                        for keyA in value1:
+                            BstRestService.flattenJson(value1, result)
+            else:
+                result[key]=value
+        return result 
+
+    @staticmethod
+    def pretty_print(d, delimiter="."):
+        """ pretty prints the json into key value pair """
+        max_len = max([len(l) for l in d.keys()])
+        max_len = 56 if max_len < 56 else max_len
+        print ""
+        for name, value in d.items():
+            actual_len = len(name)
+            delim_len = max_len - actual_len
+            delim_string = delimiter * delim_len
+            sys.stdout.write("{0} {1} {2}\n".format(name, delim_string, value))
+        print ""
+
+    @staticmethod
+    def debugJsonPrint(debug,jsonData,resp):
+        if debug == True:
+            print ""
+            print "-"*130
+            print "Request :"
+            print "-"*130
+            BstRestService.jsonData(json.loads(jsonData))
+            print "-"*130
+            print "Response :"
+            print "-"*130
+            if resp[1]:
+                resp_ = resp[1].replace('Content-Type: text/json', '')
+                BstRestService.jsonData(json.loads(resp_))
+            else:
+                print "''"
+            print "-"*130
+
+def printStepHeader():
+    print ""
+    print "="*130
+    print "%-7s | %-75s | %-8s | %-40s" % ("STEP", "DESCRIPTION", "OUTCOME", "REMARK")
+    print "="*130
+
+def printStepFooter():
+    print "="*130
+    print ""
+
+def printStepResult(step,desc,result,remark=""):
+    tmp_desc = desc[:72]+"..." if len(desc) > 75 else desc
+    print "%-7s | %-75s | %-8s | %-40s" % (step,tmp_desc,result, remark)
+    print "-" * 130
+
+
diff --git a/tests/bstRest.py b/tests/bstRest.py
new file mode 100644
index 0000000..c317e75
--- /dev/null
+++ b/tests/bstRest.py
@@ -0,0 +1,98 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+'''
+@copyright: Hewlett Packard
+This are simple libraries which will send the following REST calls:
+POST
+PUT
+DELETE
+GET
+They all have the signature of  "RestCall(url,data,XAuthToken,debug=False,errorList=[])
+where url is the url the call will be sent to. dat is the data contained in the request, and xAuthToken is the string
+which will be used for the "X-Auth-Token" part of the header.
+debug is a boolean which can be used to print to the system console the data which will be sent.
+errorList is a string which will be used to return any error found while making the call.
+
+If the call is succesful the return json object will be returned as a dictionary.
+If an error occur the return value will be None (null) and the error text will be copied to the errorString variable
+'''
+
+import urllib
+import httplib
+import json
+import re
+
+def parseUrl(url):
+    '''Parses the given URL and sends back the IP address and the server port details.'''
+    patt = r'https?://(.*?):?(\d*)/broadview/bst.*'
+    match = re.search(patt, url)
+    if match:
+        return match.group(1), match.group(2) if match.group(2) else 8080
+    else:
+        return None, None
+
+def genericREST(method,url,data,debug=True):
+    '''sends a json request using the selected method: method and using X-auth-Token: xAuthToken, and data as the body
+    if the post attempt fails "None" (null) will be returned and the text of the error
+    will be appended to errorLit[].
+    If the post attempt is successful the json response will be returned as a dictionary
+    If debug=True, then the url and data will be printed to the system screen.
+    '''
+
+    headers = {"Content-type": "application/json", "Accept": "text/plain"}
+
+    if debug == True:
+        debugLabel = "_"+method+"-REST: "
+        print ""
+        print debugLabel+ "url:          " + str(url)
+        print debugLabel+ "data:         " + str(data)
+        print ""
+
+    ip,server_port=parseUrl(url)
+
+    try:
+        conn = httplib.HTTPConnection(ip, int(server_port))
+    except Exception as e:
+        return {"response":e, "data":None}
+
+    try:
+        conn.request(method, url, data, headers)
+        response = conn.getresponse()
+        res_data = response.read()
+        conn.close()
+        return {"response":response, "data":res_data}
+    except Exception as e:
+        conn.close()
+        return {"response":e, "data":None}
+
+
+def get(url, debug=False):
+    return genericREST("GET", url, None, debug)
+
+def post(url, data, debug=False):
+    return genericREST("POST", url, data, debug)
+
+def put(url, data, debug=False):
+    return genericREST("PUT", url, data, debug)
+
+def delete(url, data, debug=False):
+    return genericREST("DELETE", url, data, debug)
+
+def head(url, debug=False):
+    return genericREST("HEAD", url,None, debug)
diff --git a/tests/bstUtil.py b/tests/bstUtil.py
new file mode 100644
index 0000000..622a8f3
--- /dev/null
+++ b/tests/bstUtil.py
@@ -0,0 +1,46 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+import ConfigParser
+
+def returnStatus(actual, expected, passmsg="", failmsg=""):
+    '''Returns a tuple with result and message after comapring two values.'''
+    return ("PASS",passmsg) if actual == expected else ("FAIL",failmsg)
+
+def dict_compare(d1, d2):
+    '''Compares the provided two python dictionaries.'''
+    d1_keys = set(d1.keys())
+    d2_keys = set(d2.keys())
+    intersect_keys = d1_keys.intersection(d2_keys)
+    added = d1_keys - d2_keys
+    removed = d2_keys - d1_keys
+    modified = {o : (d1[o], d2[o]) for o in intersect_keys if d1[o] != d2[o]}
+    same = set(o for o in intersect_keys if d1[o] == d2[o])
+    return added, removed, modified, same
+
+def get_ini_details(filename,section):
+    '''returns a dictionary by reading the given ini file and the given section.'''
+
+    config = ConfigParser.ConfigParser()
+    config.read(filename)
+    config_dict = dict(config.items(section))
+    return config_dict
diff --git a/tests/clear_bst_statistics_api_ct.py b/tests/clear_bst_statistics_api_ct.py
new file mode 100644
index 0000000..93d0876
--- /dev/null
+++ b/tests/clear_bst_statistics_api_ct.py
@@ -0,0 +1,89 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class clear_bst_statistics_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Clear BST Stats and Check for the 200 OK response"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        return returnStatus(resp[0], 200,"","Unable to get the 200 OK response, got reponse "+str(resp[0]))
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('clear_bst_statistics_api_ct'))
+    params=json_dict.get("paramslist","")
+
+    tcObj = clear_bst_statistics_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/clear_bst_thresholds_api_ct.py b/tests/clear_bst_thresholds_api_ct.py
new file mode 100644
index 0000000..5f18521
--- /dev/null
+++ b/tests/clear_bst_thresholds_api_ct.py
@@ -0,0 +1,89 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class clear_bst_thresholds_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Clear BST Thresholds and Check for the 200 OK response"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        return returnStatus(resp[0], 200,"","Unable to get the 200 OK response, got reponse "+str(resp[0]))
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('clear_bst_thresholds_api_ct'))
+    params=json_dict.get("params","")
+
+    tcObj = clear_bst_thresholds_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/configure_bst_feature_api_ct.py b/tests/configure_bst_feature_api_ct.py
new file mode 100644
index 0000000..dfdab1f
--- /dev/null
+++ b/tests/configure_bst_feature_api_ct.py
@@ -0,0 +1,134 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class configure_bst_feature_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Configure BST feature"""
+        try:
+            pprint.pprint(jsonData)
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        self.nextStepCheckParams=jsonData
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        return returnStatus(resp[0], 200,"","Unable to get the 200 OK response, got reponse "+str(resp[0]))
+
+    def step2(self,jsonData):
+        """Get BST Feature Status"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        if not resp[1]: return "FAIL","Got null response"
+        resp_ = resp[1].replace('Content-Type: text/json', '')
+        data_dict = json.loads(resp_)
+        if not "result" in data_dict: return "FAIL","No Result key in Response JSON Data"
+        resultDict = data_dict['result']
+        jsonDict = json.loads(self.nextStepCheckParams)
+        paramsDict = jsonDict['params']
+        valsCheck = True if cmp(resultDict, paramsDict) == 0 else False
+        added,removed,modified,same=dict_compare(resultDict,paramsDict)
+        if not added and not removed and not modified:
+            msg = ""
+        else:
+            params_list=paramsDict.keys()
+            diff_list=list(set(params_list) - same)
+            msg="params "+" ".join(diff_list)+" contains wrong values in response."
+        return returnStatus(valsCheck,True,"",msg)
+
+    step3, step4 = step1, step2
+    step5, step6 = step1, step2
+    step7, step8 = step1, step2
+    step9, step10 = step1, step2
+    step11, step12 = step1, step2
+    step13, step14 = step1, step2
+    step15, step16 = step1, step2
+    step17, step18 = step1, step2
+    step19, step20 = step1, step2
+    step21, step22 = step1, step2
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('configure_bst_feature_api_ct'))
+    params=json_dict.get("paramslist","")
+
+    tcObj = configure_bst_feature_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/configure_bst_thresholds_api_ct.py b/tests/configure_bst_thresholds_api_ct.py
new file mode 100644
index 0000000..d2933d2
--- /dev/null
+++ b/tests/configure_bst_thresholds_api_ct.py
@@ -0,0 +1,127 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class configure_bst_thresholds_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Configure BST thresholds"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        return returnStatus(resp[0], 200,"","Unable to get the 200 OK response, got reponse "+str(resp[0]))
+
+    def step2(self,jsonData):
+        """Get BST Thresholds"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        if not resp[1]: return "FAIL","Got null response"
+        resp_ = resp[1].replace('Content-Type: text/json', '')
+        data_dict = json.loads(resp_)
+        if not "report" in data_dict: return "FAIL","No Report key in Response JSON Data"
+        resultDict = data_dict['report']
+        realms = [ r['realm'] for r in resultDict if 'data' in r and 'realm' in r ]
+        jsonDict = json.loads(jsonData)
+        paramsDict=jsonDict['params']
+        plist = [ k.replace('include-', '') for k, v in paramsDict.items() if v == 1 ]
+        msg="Expected realm(s) " + " ".join(plist) + " not present"
+        return returnStatus(sorted(plist),sorted(realms),"",msg)
+
+    step3, step4 = step1, step2
+    step5, step6 = step1, step2
+    step7, step8 = step1, step2
+    step9, step10 = step1, step2
+    step11, step12 = step1, step2
+    step13, step14 = step1, step2
+    step15, step16 = step1, step2
+    step17, step18 = step1, step2
+    step19, step20 = step1, step2
+    step21, step22 = step1, step2
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('configure_bst_thresholds_api_ct'))
+    params=json_dict.get("params","")
+
+    tcObj = configure_bst_thresholds_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/configure_bst_tracking_api_ct.py b/tests/configure_bst_tracking_api_ct.py
new file mode 100644
index 0000000..9b01568
--- /dev/null
+++ b/tests/configure_bst_tracking_api_ct.py
@@ -0,0 +1,136 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class configure_bst_tracking_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Configure BST tracking"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        self.nextStepCheckParams=jsonData
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        return returnStatus(resp[0], 200,"","Unable to get the 200 OK response, got reponse "+str(resp[0]))
+
+    def step2(self,jsonData):
+        """Get BST Tracking Status"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        if not resp[1]: return "FAIL","Got null response"
+        resp_ = resp[1].replace('Content-Type: text/json', '')
+        data_dict = json.loads(resp_)
+        if not "result" in data_dict: return "FAIL","No Result key in Response JSON Data"
+        resultDict = data_dict['result']
+        jsonDict = json.loads(self.nextStepCheckParams)
+        paramsDict = jsonDict['params']
+        valsCheck = True if cmp(resultDict, paramsDict) == 0 else False
+        added,removed,modified,same=dict_compare(resultDict,paramsDict)
+        if not added and not removed and not modified:
+            msg = ""
+        else:
+            params_list=paramsDict.keys()
+            diff_list=list(set(params_list) - same)
+            msg="params "+" ".join(diff_list)+" contains wrong values in response."
+        return returnStatus(valsCheck,True,"",msg)
+
+    step3, step4 = step1, step2
+    step5, step6 = step1, step2
+    step7, step8 = step1, step2
+    step9, step10 = step1, step2
+    step11, step12 = step1, step2
+    step13, step14 = step1, step2
+    step15, step16 = step1, step2
+    step17, step18 = step1, step2
+    step19, step20 = step1, step2
+    step21, step22 = step1, step2
+    step23, step24 = step1, step2
+    step25, step26 = step1, step2
+    step27, step28 = step1, step2
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('configure_bst_tracking_api_ct'))
+    params=json_dict.get("params","")
+
+    tcObj = configure_bst_tracking_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/get_bst_feature_api_ct.py b/tests/get_bst_feature_api_ct.py
new file mode 100644
index 0000000..5f407f6
--- /dev/null
+++ b/tests/get_bst_feature_api_ct.py
@@ -0,0 +1,96 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class get_bst_feature_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Get BST Feature Status"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        if not resp[1]: return "FAIL","Got null response"
+        resp_ = resp[1].replace('Content-Type: text/json', '')
+        data_dict = json.loads(resp_)
+        if not "result" in data_dict: return "FAIL","No Result key in Response JSON Data"
+        result = data_dict['result']
+        plist = self.params.split(",")
+        plist = [p.strip() for p in plist]
+        return returnStatus(sorted(plist),sorted(result.keys()),"","get_bst_feature params lists contains invalid param keys")
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('get_bst_feature_api_ct'))
+    params=json_dict.get("paramslist","")
+
+    tcObj = get_bst_feature_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/get_bst_report_api_ct.py b/tests/get_bst_report_api_ct.py
new file mode 100644
index 0000000..329bd64
--- /dev/null
+++ b/tests/get_bst_report_api_ct.py
@@ -0,0 +1,121 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class get_bst_report_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Get BST Report"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        if not resp[1]: return "FAIL","Got null response"
+        resp_ = resp[1].replace('Content-Type: text/json', '')
+        data_dict = json.loads(resp_)
+        if not "report" in data_dict: return "FAIL","No Report key in Response JSON Data"
+        result = data_dict['report']
+        realms = [ r['realm'] for r in result if 'data' in r and 'realm' in r ]
+        jsonDict = json.loads(jsonData)
+        paramsDict=jsonDict['params']
+        plist = [ k.replace('include-', '') for k, v in paramsDict.items() if v == 1 ]
+        msg="Expected realm(s) " + " ".join(plist) + " not present"
+        return returnStatus(sorted(plist),sorted(realms),"",msg)
+
+    step2=step1
+
+    step3=step1
+
+    step4=step1
+
+    step5=step1
+
+    step6=step1
+
+    step7=step1
+
+    step8=step1
+
+    step9=step1
+
+    step10=step1
+
+    step11=step1
+
+    step12=step1
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('get_bst_report_api_ct'))
+    params=json_dict.get("paramslist","")
+
+    tcObj = get_bst_report_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/get_bst_thresholds_api_ct.py b/tests/get_bst_thresholds_api_ct.py
new file mode 100644
index 0000000..b67eecd
--- /dev/null
+++ b/tests/get_bst_thresholds_api_ct.py
@@ -0,0 +1,121 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class get_bst_thresholds_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Get BST Thresholds"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        if not resp[1]: return "FAIL","Got null response"
+        resp_ = resp[1].replace('Content-Type: text/json', '')
+        data_dict = json.loads(resp_)
+        if not "report" in data_dict: return "FAIL","No Report key in Response JSON Data"
+        result = data_dict['report']
+        realms = [ r['realm'] for r in result if 'data' in r and 'realm' in r ]
+        jsonDict = json.loads(jsonData)
+        paramsDict=jsonDict['params']
+        plist = [ k.replace('include-', '') for k, v in paramsDict.items() if v == 1 ]
+        msg="Expected realm(s) " + " ".join(plist) + " not present"
+        return returnStatus(sorted(plist),sorted(realms),"",msg)
+
+    step2=step1
+
+    step3=step1
+
+    step4=step1
+
+    step5=step1
+
+    step6=step1
+
+    step7=step1
+
+    step8=step1
+
+    step9=step1
+
+    step10=step1
+
+    step11=step1
+
+    step12=step1
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('get_bst_thresholds_api_ct'))
+    params=json_dict.get("paramslist","")
+
+    tcObj = get_bst_thresholds_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/get_bst_tracking_api_ct.py b/tests/get_bst_tracking_api_ct.py
new file mode 100644
index 0000000..abd6726
--- /dev/null
+++ b/tests/get_bst_tracking_api_ct.py
@@ -0,0 +1,96 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/env python
+
+import os
+import sys
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+class get_bst_tracking_api_ct(object):
+
+    def __init__(self,ip,port,params="",debug=False):
+        self.obj = BstRestService(ip,port)
+        self.debug = debug
+        self.params = params
+
+    def step1(self,jsonData):
+        """Get BST Tracking Status"""
+        try:
+            resp = self.obj.postResponse(jsonData)
+            if resp[0] == "INVALID":
+                return "FAIL","Connection refused/Invalid JSON request... Please check the ip address provided in 'ini' file/BroadViewAgent is running or not/JSON data is valid or not ..."
+        except Exception,e:
+            return "FAIL","Unable to perform the rest call with given JSON data, Occured Exception ... "+str(e)
+
+        try:
+            self.obj.debugJsonPrint(self.debug,jsonData,resp)
+        except:
+            return "FAIL","Invalid JSON Response data received"
+
+        if returnStatus(resp[0], 200)[0] == "FAIL": return "FAIL","Obtained {0}".format(resp[0])
+        if not resp[1]: return "FAIL","Got null response"
+        resp_ = resp[1].replace('Content-Type: text/json', '')
+        data_dict = json.loads(resp_)
+        if not "result" in data_dict: return "FAIL","No Result key in Response JSON Data"
+        result = data_dict['result']
+        plist = self.params.split(",")
+        plist = [p.strip() for p in plist]
+        return returnStatus(sorted(plist),sorted(result.keys()),"","get_bst_tracking params lists contains invalid param keys")
+
+    def getSteps(self):
+        return sorted([ i for i in dir(self) if i.startswith('step') ], key=lambda item: int(item.replace('step','')))
+
+def main(ip_address,port):
+    jsonText = ConfigParser.ConfigParser()
+    jsonText.read('testCaseJsonStrings.ini')
+    json_dict = dict(jsonText.items('get_bst_tracking_api_ct'))
+    params=json_dict.get("paramslist","")
+
+    tcObj = get_bst_tracking_api_ct(ip_address,port,params,debug=True)
+
+    stepResultMap = {}
+    printStepHeader()
+    for step in tcObj.getSteps():
+        if step in json_dict:
+            resp=getattr(tcObj,step)(json_dict[step])
+            desc=getattr(tcObj,step).__doc__
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        else:
+            resp=getattr(tcObj,step)()
+            desc=""
+            stepResultMap[step] = resp
+            printStepResult(step,desc,resp[0], resp[1])
+        if resp[0] == 'FAIL': break
+    printStepFooter()
+    statusMsgTuple = [ s for s in stepResultMap.values() if s[0] == "FAIL" ]
+    if statusMsgTuple:
+        return False, statusMsgTuple[0][1]
+    return True, "Test Case Passed"
+
+if __name__ == '__main__':
+    main()
diff --git a/tests/serverDetails.ini b/tests/serverDetails.ini
new file mode 100644
index 0000000..1a0f82e
--- /dev/null
+++ b/tests/serverDetails.ini
@@ -0,0 +1,4 @@
+[server_details]
+switch_type=genericx86-64
+agent_server_ip=10.18.20.234
+agent_server_port=8080
diff --git a/tests/testCaseJsonStrings.ini b/tests/testCaseJsonStrings.ini
new file mode 100644
index 0000000..c39eb67
--- /dev/null
+++ b/tests/testCaseJsonStrings.ini
@@ -0,0 +1,119 @@
+[get_bst_feature_api_ct]
+paramslist=stat-units-in-cells,stats-in-percentage,collection-interval,async-full-reports,send-async-reports,send-snapshot-on-trigger,trigger-rate-limit,trigger-rate-limit-interval,bst-enable
+step1={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+
+[get_bst_tracking_api_ct]
+paramslist=track-peak-stats,track-ingress-port-priority-group,track-ingress-port-service-pool,track-ingress-service-pool,track-egress-port-service-pool,track-egress-service-pool,track-egress-uc-queue,track-egress-uc-queue-group,track-egress-mc-queue,track-egress-cpu-queue,track-egress-rqe-queue,track-device
+step1={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+
+[get_bst_thresholds_api_ct]
+step1={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step2={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 1, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step3={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 1, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step4={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 1, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step5={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 1, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step6={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 1, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step7={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 1, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step8={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 1, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step9={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 1, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step10={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 1, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step11={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 1 }, "id": 1, "asic-id":"1"}
+step12={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 1, "include-ingress-service-pool": 1, "include-egress-port-service-pool": 1, "include-egress-service-pool": 1, "include-egress-uc-queue": 1, "include-egress-uc-queue-group": 1, "include-egress-mc-queue": 1, "include-egress-cpu-queue": 1, "include-egress-rqe-queue": 1, "include-device": 1 }, "id": 1, "asic-id":"1"}
+
+[get_bst_report_api_ct]
+step1={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step2={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 1, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step3={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 1, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step4={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 1, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step5={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 1, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step6={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 1, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step7={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 1, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step8={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 1, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step9={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 1, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step10={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 1, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step11={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 1 }, "id": 1, "asic-id":"1"}
+step12={"jsonrpc": "2.0", "method": "get-bst-report", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 1, "include-ingress-service-pool": 1, "include-egress-port-service-pool": 1, "include-egress-service-pool": 1, "include-egress-uc-queue": 1, "include-egress-uc-queue-group": 1, "include-egress-mc-queue": 1, "include-egress-cpu-queue": 1, "include-egress-rqe-queue": 1, "include-device": 1 }, "id": 1, "asic-id":"1"}
+
+[clear_bst_statistics_api_ct]
+step1={"jsonrpc": "2.0", "method": "clear-bst-statistics", "params": { }, "id": 1, "asic-id":"1"}
+
+[clear_bst_thresholds_api_ct]
+step1={"jsonrpc": "2.0", "method": "clear-bst-thresholds", "params": { }, "id": 1, "asic-id":"1"}
+
+[configure_bst_feature_api_ct]
+step1={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step2={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step3={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 1, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step4={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step5={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 1, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step6={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step7={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 1, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step8={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step9={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 1, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step10={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step11={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 1, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step12={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step13={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 10, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step14={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step15={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 1, "trigger-rate-limit-interval": 1, "async-full-reports": 0}}
+step16={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step17={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 10, "async-full-reports": 0}}
+step18={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step19={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 0, "collection-interval": 0, "send-async-reports": 0, "stats-in-percentage": 0, "stat-units-in-cells": 0, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 0, "trigger-rate-limit-interval": 1, "async-full-reports": 1}}
+step20={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+step21={"jsonrpc": "2.0", "method": "configure-bst-feature", "id": 1, "asic-id": "1", "params": {"bst-enable": 1, "collection-interval": 1, "send-async-reports": 1, "stats-in-percentage": 1, "stat-units-in-cells": 1, "trigger-rate-limit": 1, "send-snapshot-on-trigger": 1, "trigger-rate-limit-interval": 1, "async-full-reports": 1 }}
+step22={"jsonrpc": "2.0", "method": "get-bst-feature", "params": { }, "id": 1, "asic-id":"1"}
+
+[configure_bst_tracking_api_ct]
+step1={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step2={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step3={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 1, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step4={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step5={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 1, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step6={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step7={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 1, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step8={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step9={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 1, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step10={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step11={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 1, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step12={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step13={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 1, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step14={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step15={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 1, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step16={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step17={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 1, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step18={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step19={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 1, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step20={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step21={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 1, "track-egress-rqe-queue" : 0, "track-device" : 0}, "id": 1}
+step22={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step23={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 1, "track-device" : 0}, "id": 1}
+step24={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step25={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 0, "track-ingress-port-priority-group" : 0, "track-ingress-port-service-pool" : 0, "track-ingress-service-pool" : 0, "track-egress-port-service-pool" : 0, "track-egress-service-pool" : 0, "track-egress-uc-queue" : 0, "track-egress-uc-queue-group" : 0, "track-egress-mc-queue" : 0, "track-egress-cpu-queue" : 0, "track-egress-rqe-queue" : 0, "track-device" : 1}, "id": 1}
+step26={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+step27={"jsonrpc": "2.0", "method": "configure-bst-tracking", "asic-id": "1", "params": {"track-peak-stats" : 1, "track-ingress-port-priority-group" : 1, "track-ingress-port-service-pool" : 1, "track-ingress-service-pool" : 1, "track-egress-port-service-pool" : 1, "track-egress-service-pool" : 1, "track-egress-uc-queue" : 1, "track-egress-uc-queue-group" : 1, "track-egress-mc-queue" : 1, "track-egress-cpu-queue" : 1, "track-egress-rqe-queue" : 1, "track-device" : 1}, "id": 1}
+step28={"jsonrpc": "2.0", "method": "get-bst-tracking", "params": { }, "id": 1, "asic-id":"1"}
+
+[configure_bst_thresholds_api_ct]
+step1={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "ingress-port-priority-group", "port": "1", "priority-group": 1, "um-share-threshold": 10, "um-headroom-threshold": 10  }, "id": 1, "asic-id":"1"}
+step2={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 1, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step3={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "ingress-port-service-pool", "port": "1", "service-pool": 1, "um-share-threshold": 10 }, "id": 1, "asic-id":"1"}
+step4={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 1, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step5={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "ingress-service-pool", "service-pool": 1, "um-share-threshold": 10 }, "id": 1, "asic-id":"1"}
+step6={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 1, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step7={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-port-service-pool", "port": "1", "service-pool": 1, "uc-share-threshold": 10, "um-share-threshold": 10, "mc-share-threshold": 10, "mc-share-queue-entries-threshold": 10 }, "id": 1, "asic-id":"1"}
+step8={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 1, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step9={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-service-pool", "service-pool": 1, "um-share-threshold": 10, "mc-share-threshold": 10, "mc-share-queue-entries-threshold": 10  }, "id": 1, "asic-id":"1"}
+step10={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 1, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step11={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-uc-queue", "queue": 1, "uc-threshold": 10 }, "id": 1, "asic-id":"1"}
+step12={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 1, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step13={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-uc-queue-group", "queue-group": 1, "uc-threshold": 10 }, "id": 1, "asic-id":"1"}
+step14={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 1, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step15={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-mc-queue", "queue": 1, "mc-threshold": 10, "mc-queue-entries-threshold": 10 }, "id": 1, "asic-id":"1"}
+step16={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 1, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step17={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-cpu-queue", "queue": 1, "cpu-threshold": 10 }, "id": 1, "asic-id":"1"}
+step18={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 1, "include-egress-rqe-queue": 0, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step19={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "egress-rqe-queue", "queue": 1, "rqe-threshold": 10 }, "id": 1, "asic-id":"1"}
+step20={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 1, "include-device": 0 }, "id": 1, "asic-id":"1"}
+step21={"jsonrpc": "2.0", "method": "configure-bst-thresholds", "params": { "realm": "device", "threshold": 10 }, "id": 1, "asic-id":"1"}
+step22={"jsonrpc": "2.0", "method": "get-bst-thresholds", "params": { "include-ingress-port-priority-group": 0, "include-ingress-port-service-pool": 0, "include-ingress-service-pool": 0, "include-egress-port-service-pool": 0, "include-egress-service-pool": 0, "include-egress-uc-queue": 0, "include-egress-uc-queue-group": 0, "include-egress-mc-queue": 0, "include-egress-cpu-queue": 0, "include-egress-rqe-queue": 0, "include-device": 1 }, "id": 1, "asic-id":"1"}
diff --git a/tests/test_bstd_ct_rest_all.py b/tests/test_bstd_ct_rest_all.py
new file mode 100644
index 0000000..58dd7c7
--- /dev/null
+++ b/tests/test_bstd_ct_rest_all.py
@@ -0,0 +1,218 @@
+'''
+  *
+  * (C) Copyright Broadcom Corporation 2015
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  *
+  * You may obtain a copy of the License at
+  * http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+'''
+
+#!/usr/bin/python
+#
+# Copyright (C) 2015 Hewlett-Packard Development Company, L.P.
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+
+import os
+import sys
+import pytest
+import subprocess
+import time
+
+import ConfigParser
+import json
+import pprint
+
+from bstUtil import *
+
+from BstRestService import *
+import bstRest as rest
+
+import get_bst_feature_api_ct
+import get_bst_tracking_api_ct
+import get_bst_thresholds_api_ct
+import get_bst_report_api_ct
+import clear_bst_statistics_api_ct
+import clear_bst_thresholds_api_ct
+import configure_bst_feature_api_ct
+import configure_bst_tracking_api_ct
+import configure_bst_thresholds_api_ct
+
+config_dict = get_ini_details("serverDetails.ini","server_details")
+sw_type = config_dict.get('switch_type',"").strip()
+if sw_type in ['',"genericx86-64"]:
+    from opsvsi.docker import *
+    from opsvsi.opsvsitest import *
+elif sw_type == "as5712":
+    OpsVsiTest = object
+else:
+    assert False,"Unknown platform is provided in the serverDetails.ini file..."
+
+class bstTest( OpsVsiTest ):
+
+    def setupNet(self):
+        # if you override this function, make sure to
+        # either pass getNodeOpts() into hopts/sopts of the topology that
+        # you build or into addHost/addSwitch calls
+
+        config_dict = get_ini_details("serverDetails.ini","server_details")
+        sw_type = config_dict.get('switch_type',"").strip()
+        if sw_type in ['',"genericx86-64"]:
+            topo=SingleSwitchTopo(
+                k=1,
+                hopts=self.getHostOpts(),
+                sopts=self.getSwitchOpts())
+            self.net = Mininet(topo=topo,
+                switch=VsiOpenSwitch,
+                host=Host,
+                link=OpsVsiLink, controller=None,
+                build=True)
+            self.s1 = self.net.switches[0]
+
+    def get_bst_feature(self):
+        result,message = get_bst_feature_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def get_bst_tracking(self):
+        result,message = get_bst_tracking_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def get_bst_thresholds(self):
+        result,message = get_bst_thresholds_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def get_bst_report(self):
+        result,message = get_bst_report_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def configure_bst_feature(self):
+        result,message = configure_bst_feature_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def configure_bst_tracking(self):
+        result,message = configure_bst_tracking_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def configure_bst_thresholds(self):
+        result,message = configure_bst_thresholds_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def clear_bst_statistics(self):
+        result,message = clear_bst_statistics_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def clear_bst_thresholds(self):
+        result,message = clear_bst_thresholds_api_ct.main(self.ip_address,self.port)
+        assert result,message
+
+    def start_agent(self):
+        sw_type = self.config_dict.get('switch_type',"").strip()
+        if sw_type in ['',"genericx86-64"]:
+            out = self.s1.cmd("/usr/bin/ops-broadview &")
+            time.sleep(60)
+            out = self.s1.cmd("pgrep ops-broadview")
+            out = out.split("\n")
+            if len(out) == 1:
+                self.broadview_pid = out[0]
+            else:
+                self.broadview_pid = None
+
+    def stop_agent(self):
+        sw_type = self.config_dict.get('switch_type',"").strip()
+        if sw_type in ['',"genericx86-64"]:
+            if self.broadview_pid is not None:
+                out = self.s1.cmd("kill -9 "+self.broadview_pid)
+                time.sleep(3)
+
+    def getSwitchIp(self):
+        sw_type = self.config_dict.get('switch_type',"").strip()
+        if sw_type in ['',"genericx86-64"]:
+            out = self.s1.cmd("ifconfig eth0")
+            self.ip_address = out.split("\n")[1].split()[1][5:]
+            self.port = "8080"
+        else:
+            self.ip_address = self.config_dict.get('agent_server_ip',"127.0.0.1")
+            self.port = self.config_dict.get('agent_server_port',"8080")
+
+    def getConfigDetails(self,filename,section):
+        self.config_dict = get_ini_details(filename,section)
+
+
+class Test_bstd:
+
+    def setup(self):
+        pass
+
+    def teardown(self):
+        pass
+
+    def setup_class(cls):
+        # Create the Mininet topology based on mininet.
+        Test_bstd.test = bstTest()
+        Test_bstd.test.getConfigDetails("serverDetails.ini","server_details")
+        Test_bstd.test.getSwitchIp()
+        Test_bstd.test.start_agent()
+
+    def teardown_class(cls):
+        Test_bstd.test.stop_agent()
+        if hasattr(Test_bstd.test,"net"):
+            Test_bstd.test.net.stop()
+
+    def setup_method(self, method):
+        pass
+
+    def teardown_method(self, method):
+        pass
+
+    def __del__(self):
+        if hasattr(self, 'test'):
+            del self.test
+
+    def test_get_bst_feature(self):
+        self.test.get_bst_feature()
+
+    def test_get_bst_tracking(self):
+        self.test.get_bst_tracking()
+
+    def test_get_bst_thresholds(self):
+        self.test.get_bst_thresholds()
+
+    def test_get_bst_report(self):
+        self.test.get_bst_report()
+
+    def test_configure_bst_feature(self):
+        self.test.configure_bst_feature()
+
+    def test_configure_bst_tracking(self):
+        self.test.configure_bst_tracking()
+
+    def test_configure_bst_thresholds(self):
+        self.test.configure_bst_thresholds()
+
+    def test_clear_bst_thresholds(self):
+        self.test.clear_bst_thresholds()
+
+    def test_clear_bst_thresholds(self):
+        self.test.clear_bst_thresholds()
+
diff --git a/tools/Make.common b/tools/Make.common
new file mode 100755
index 0000000..711154a
--- /dev/null
+++ b/tools/Make.common
@@ -0,0 +1,552 @@
+#
+#/*****************************************************************************
+#*
+#* (C) Copyright Broadcom Corporation 2015
+#*
+#* Licensed under the Apache License, Version 2.0 (the "License");
+#* you may not use this file except in compliance with the License.
+#*
+#* You may obtain a copy of the License at
+#* http://www.apache.org/licenses/LICENSE-2.0
+#*
+#* Unless required by applicable law or agreed to in writing, software
+#* distributed under the License is distributed on an "AS IS" BASIS,
+#* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#* See the License for the specific language governing permissions and
+#* limitations under the License.
+#*
+#***************************************************************************/
+
+#
+# The valid command line targets begin in the section "Command Line Targets".
+#
+
+# This make file is common for all builds.  It is expected that
+# several global variables have already been defined:
+# 	CROSS_COMPILE - base name of the cross compiler tools
+# 	OPENAPPS_BASE - top level directory of the OPENAPPS code
+# 	OPENAPPS_OUTPATH       - directory where the generated output is placed
+# 	platform      - Linux platform -- used primarily by the SDK
+#
+
+#
+# SDK make variables:
+# 	MAKE_LOCAL 	 - the name of a local makefile to be included by Make.config
+# 	NO_LOCAL_TARGETS - if set, do not copy targets to the SDK directory (leave in output)
+# 	QUIET      	 - reduces the output of the SDK make process (defined based on dmode)
+# 	SDK      	 - top level directory of the SDK code
+# 	SDKBUILD 	 - directory for SDK generated output relative to $(SDK)
+#
+
+#
+# Get the version info for this build from package.cfg
+#
+
+ifeq ($(BCM_REL_NUM),)
+   BCM_REL_NUM=0
+endif
+
+ifeq ($(BCM_VER_NUM),)
+   BCM_VER_NUM=0
+endif
+
+ifeq ($(BCM_MAINT_NUM),)
+   BCM_MAINT_NUM=0
+endif
+
+ifeq ($(BCM_BUILD_NUM),)
+   BCM_BUILD_NUM=1
+endif
+
+export BCM_REL_NUM
+export BCM_VER_NUM
+export BCM_MAINT_NUM
+export BCM_BUILD_NUM
+
+ifneq ($(OUTPATH),)
+   OPENAPPS_OUTPATH:=$(OUTPATH)
+   export OPENAPPS_OUTPATH
+endif
+export OUTPATH :=
+
+RELEASE_FILE = $(abspath $(OPENAPPS_BASE)/RELEASE)
+OPENAPPS_RELEASE = broadview-$(BCM_REL_NUM).$(BCM_VER_NUM).$(BCM_MAINT_NUM).$(BCM_BUILD_NUM)
+OPENAPPS_RELEASE_NUMBER = $(BCM_REL_NUM)$(BCM_VER_NUM)$(BCM_MAINT_NUM)$(BCM_BUILD_NUM)
+
+ifeq ($(CPU_BASE_DIR),)
+   CPU_BASE_DIR = $(abspath $(OPENAPPS_BASE)/platform/cpu/)
+endif
+export CPU_BASE_DIR
+
+#
+# Make variables
+#
+export AR      = $(CROSS_COMPILE)ar
+export AS      = $(CROSS_COMPILE)as
+export CC      = $(CROSS_COMPILE)gcc
+export LD      = $(CROSS_COMPILE)ld
+export NM      = $(CROSS_COMPILE)nm
+export OBJCOPY = $(CROSS_COMPILE)objcopy
+export OBJDUMP = $(CROSS_COMPILE)objdump
+export PERL    = perl
+export RANLIB  = $(CROSS_COMPILE)ranlib
+export RM      = rm
+export SED     = sed
+export SPLINT  = splint
+export STRIP   = $(CROSS_COMPILE)strip
+
+#
+# Other variables:
+# 	OPENAPPS_BUILD_DELIVERABLES_DIR - the directory containing the results of building
+# 			   E.g., the /tftpboot/ directory
+#   OPENAPPS_LIBRARIES_DIR    - the directory in which the linkable objects will be placed
+# 	OPENAPPS_CFLAGS   - CFLAGS that only apply to OPENAPPS (i.e., not the SDK)
+# 	PACKAGES_DIR	   - the directory into which the openapps packages are generated
+# 	dmode            - for debugging.  The following are valid values:
+#                               d  -- turn off optimization and enable debug symbols to be generated.
+#                                     This includes setting the SDK variables DEBUG_SYMBOLS
+#                                     and DEBUG_OPTIMIZE such that our settings in CFLAGS
+#                                     are used and not overridden by SDK settings.
+# 				i  -- turn on only POSIX IEEE Std 1003.2 APIs
+# 				m  -- turn on some make debugging
+# 				p  -- turn on profiling code generation for gprof tool
+# 				r  -- turn on debugging for the rpcgen script
+# 				vv -- echoes the SDK compiler invocation commands
+#				   -- any value will cause some make variables to be displayed
+#
+
+ifeq ($(OPENAPPS_BUILD_DELIVERABLES_DIR),)
+   OPENAPPS_BUILD_DELIVERABLES_DIR=$(abspath $(OPENAPPS_OUTPATH)/build/)
+endif
+export OPENAPPS_BUILD_DELIVERABLES_DIR
+
+OPENAPP_DELIVERABLES_DIR ?= $(abspath $(OPENAPPS_OUTPATH)/deliverables/)
+export OPENAPP_DELIVERABLES_DIR
+
+ifeq ($(OPENAPPS_LIBRARIES_DIR),)
+   OPENAPPS_LIBRARIES_DIR=$(abspath $(OPENAPPS_OUTPATH)/libraries)
+endif
+export OPENAPPS_LIBRARIES_DIR
+
+export add_target
+export del_target
+export del_target_object
+export agent_app_target
+export ref_app_target
+export sb_plugin_target
+export SDK_LOCAL
+export bst_ref_app_name=BroadViewBstApp
+export pt_ref_app_name=BroadViewPacketTraceApp
+export vend_cjson_name=vend_cjson.a
+export example_cfg_app_name=ExampleCfgApp
+
+
+PACKAGES_DIR ?= $(abspath $(OPENAPPS_OUTPATH)/packages)
+
+ifneq ($(dmode),)
+   ifeq ($(findstring d,$(dmode)),d)
+      OPENAPPS_CFLAGS += -ggdb2 -O0
+      export DEBUG_OPTIMIZE = -ggdb2 -O0
+   else
+      OPENAPPS_CFLAGS += -O2
+   endif
+   ifeq ($(findstring i,$(dmode)),i)
+      # for now, not turning on ansi -- too many warnings
+      #OPENAPPS_CFLAGS += -ansi -pedantic -D_POSIX_SOURCE -D_POSIX_C_SOURCE=2
+      # _XOPEN_SOURCE implies POSIX support (see features.h)
+      OPENAPPS_CFLAGS += -D_XOPEN_SOURCE=700
+   endif
+   ifeq ($(findstring m,$(dmode)),m)
+      export DEBUG_PARMS += --debug=v,j,m
+   endif
+   ifeq ($(findstring p,$(dmode)),p)
+      export CFLAGS += -pg
+      export LDFLAGS += -pg
+   endif
+   ifeq ($(findstring vv,$(dmode)),)
+      export QUIET = 1
+   endif
+else
+   OPENAPPS_CFLAGS += -O2
+   ifeq ($(QUIET),)
+      export QUIET = 1
+   endif
+endif
+
+export dmode
+
+#FEATURE_LIST and DISPATCH_LIST depends on the modules present in this package
+ifeq ($(FEATURE_LIST),)
+   FEATURE_LIST = L3
+endif
+ifeq ($(DISPATCH_LIST),)
+   DISPATCH_LIST = RPC
+endif
+
+DYNLIB_FLAGS = -fPIC
+
+export CFLAGS += -Wall -Wimplicit-function-declaration -DOPENAPPS_BUILDING_LIB $(DYNLIB_FLAGS) -Werror
+
+export OPENAPPS_CFLAGS
+
+
+#To create list of files recursively
+rwildcard=$(wildcard $1$2) $(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2))
+
+#
+# Variables for Source Archiving
+#
+# The relative path of OPENAPPS_OUTPATH directory w.r.t the OPENAPPS_BASE
+# would be helpful
+#
+outpath_relative = $(shell $(OPENAPPS_BASE)/tools/relativepath $(OPENAPPS_BASE) $(OPENAPPS_OUTPATH))
+
+#Include files if present
+include $(OPENAPPS_BASE)/tools/Make.common.platform
+-include $(OPENAPPS_BASE)/tools/Make.common.local
+-include $(OPENAPPS_BASE)/tools/Make.common.sdk
+-include $(OPENAPPS_BASE)/tools/Make.common.opennsl
+-include $(OPENAPPS_BASE)/tools/Make.common.ovsdb
+
+export infra_target
+infra_target += \
+	log \
+	rest \
+	modulemgr \
+	openappsdoc 
+
+
+#
+# First declare most of the targets in this make file to be phony (not real files)
+#
+.PHONY: clean clean-all dump-variables openapps all release $(infra_target) $(agent_app_target) $(ref_app_target) sbredirector $(sb_plugin_target)
+
+.DEFAULT_GOAL := all
+
+#
+# Command Line Targets
+#
+# The following group of targets may be specified on the command line.
+#
+
+#
+# These targets are the usual targets for complete builds:
+#
+# all		  : builds everything and is the default target
+# examples        : builds the example applications.
+# openapps        : builds the openapps shared object library.
+
+#CHIP specific macros
+ifeq ($(PLATFORM), td2_svk)
+    export CFLAGS += -DBVIEW_CHIP_TD2
+endif 
+
+ifeq ($(PLATFORM), th_svk)
+    export CFLAGS += -DBVIEW_CHIP_TOMAHAWK
+endif
+ 
+ifeq ($(PLATFORM), im_n2948_6xlm)
+   export CFLAGS += -DBVIEW_CHIP_TD2
+endif
+
+ifeq ($(PLATFORM), s6000)
+   export CFLAGS += -DBVIEW_CHIP_TD2
+endif
+
+ifneq (,$(filter vendor_init,$(COMPONENTS)))
+   vend_target += vendorinit
+    ref_app_target += examplecfgapp
+endif
+
+ifneq (,$(filter bst,$(COMPONENTS)))
+    app_target += bst
+    agent_app_target += bst
+    ref_app_target += bviewbstapp
+    app_arc += $(OPENAPPS_OUTPATH)/bst/bst.a
+endif
+
+ifneq (,$(filter pt,$(COMPONENTS)))
+    app_target += packet_trace
+    agent_app_target += packet_trace
+    ref_app_target += bviewpackettraceapp
+    app_arc += $(OPENAPPS_OUTPATH)/packet_trace/packet_trace.a
+endif
+
+ifneq ($(TARGETOS_VARIANT),wrl_2.0)
+MYCFLAGS := $(CFLAGS)
+else
+MYCFLAGS := 
+endif 
+
+export static_lib
+static_lib += \
+	$(OPENAPPS_OUTPATH)/log/log.a \
+	$(OPENAPPS_OUTPATH)/system/system.a \
+	$(OPENAPPS_OUTPATH)/modulemgr/modulemgr.a \
+	$(OPENAPPS_OUTPATH)/sbredirector/sbredirector.a \
+	$(OPENAPPS_OUTPATH)/vend_cjson/$(vend_cjson_name) \
+	$(OPENAPPS_OUTPATH)/rest/rest.a \
+	$(app_arc)
+
+dynamic_lib += \
+		-lpthread -lrt -lm \
+		$(dynamic_sb_lib)
+
+release:
+	@touch $(OPENAPPS_OUTPATH)/version.h
+	@echo "#define RELEASE_STRING ""\"$(BCM_REL_NUM).$(BCM_VER_NUM).$(BCM_MAINT_NUM).$(BCM_BUILD_NUM)\"" > $(OPENAPPS_OUTPATH)/version.h
+
+export infra_target_all
+infra_target_all += \
+	log \
+	system \
+	vend_cjson \
+	rest \
+	modulemgr \
+	sbredirector
+
+export common_include_list
+common_include_list += \
+	-I$(OPENAPPS_BASE)/src/public \
+	-I$(OPENAPPS_OUTPATH) \
+	-c \
+	$(OPENAPPS_BASE)/src/apps/agent/agent.c \
+	-o \
+	 $(OPENAPPS_OUTPATH)/agent.o
+
+all: release openapps_out_dir $(add_target) openapps $(vend_target) $(infra_target_all) $(app_target) $(ref_app_target)
+
+	$(CC) $(CFLAGS) $(common_include_list)
+	$(CC) $(MYCFLAGS) -o $(OPENAPP_DELIVERABLES_DIR)/BroadViewAgent $(OPENAPPS_OUTPATH)/agent.o \
+		-Wl,--start-group \
+			$(static_lib) \
+		-Wl,--end-group \
+		-L$(OPENAPP_DELIVERABLES_DIR) \
+		-Wl,-Bdynamic $(dynamic_lib)
+	cp -rf $(OPENAPPS_BUILD_DELIVERABLES_DIR)/* $(OPENAPP_DELIVERABLES_DIR) 2>/dev/null || :
+ifeq ($(PLATFORM), OP-OVSDB)
+	cp -f $(OPENAPPS_BASE)/src/nb_plugin/rest/agent_config.cfg $(OPENAPP_DELIVERABLES_DIR)/broadview_config.cfg
+	cp -f $(OPENAPPS_BASE)/src/sb_plugin/sb_ovsdb/ovsdb_config.cfg $(OPENAPP_DELIVERABLES_DIR)/broadview_ovsdb_config.cfg
+endif
+
+
+
+#Creates BroadViewBstApp for BST features
+bviewbstapp : release $(OPENAPP_DELIVERABLES_DIR) 
+	@echo Making bviewbstapp 
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/example/bst_app/ $@
+	$(CC) $(MYCFLAGS) -o $(OPENAPP_DELIVERABLES_DIR)/$(bst_ref_app_name) $(OPENAPPS_OUTPATH)/bviewbstapp/bstapp_main.o \
+	-Wl,--start-group \
+	$(OPENAPPS_OUTPATH)/vend_cjson/$(vend_cjson_name) \
+	$(OPENAPPS_OUTPATH)/bviewbstapp/bviewbstapp.a \
+	-Wl,--end-group \
+	-Wl,-Bdynamic \
+	-lpthread -lm
+
+#Cleans BroadViewBstApp
+clean-bviewbstapp debug-bviewbstapp:
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/example/bst_app/ $@
+
+
+#Creates BroadViewPtApp for Packet trace features
+bviewpackettraceapp : release $(OPENAPP_DELIVERABLES_DIR) 
+	@echo Making bviewpackettraceapp 
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/example/packet_trace_app/ $@
+	$(CC) $(MYCFLAGS) -o $(OPENAPP_DELIVERABLES_DIR)/$(pt_ref_app_name) $(OPENAPPS_OUTPATH)/bviewpackettraceapp/ptapp_main.o \
+	-Wl,--start-group \
+	$(OPENAPPS_OUTPATH)/vend_cjson/$(vend_cjson_name) \
+	$(OPENAPPS_OUTPATH)/bviewpackettraceapp/bviewpackettraceapp.a \
+	-Wl,--end-group \
+	-Wl,-Bdynamic \
+	-lpthread -lm -lrt
+
+#Cleans BroadViewPtApp
+clean-bviewpackettraceapp debug-bviewpackettraceapp:
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/example/packet_trace_app/ $@
+
+#Creates ExampleCfgApp for Packet trace features
+examplecfgapp :
+	@echo Making ExampleCfgApp 
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/example/example_cfg_app/ $@
+	$(CC) $(MYCFLAGS) -o $(OPENAPP_DELIVERABLES_DIR)/$(example_cfg_app_name) $(OPENAPPS_OUTPATH)/examplecfgapp/example_client.o \
+	-Wl,--start-group \
+	$(OPENAPPS_OUTPATH)/examplecfgapp/examplecfgapp.a \
+	-Wl,--end-group \
+	-Wl,-Bdynamic \
+	-lpthread -lm -lrt
+
+#Cleans BroadViewPtApp
+clean-examplecfgapp debug-examplecfgapp:
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/example/example_cfg_app/ $@
+
+
+#Compiles Module Manager
+modulemgr clean-modulemgr debug-modulemgr:
+	@echo Making Module Manager
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/infrastructure/module_mgr/ $@
+
+#Compiles REST
+rest clean-rest debug-rest:
+	@echo Making REST 
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/nb_plugin/rest/ $@
+
+#Compiles BST
+bst clean-bst debug-bst:
+	@echo Making BST
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/apps/bst/ $@
+
+#Compiles Packet Trace
+packet_trace clean-packet_trace debug-packet_trace:
+	@echo Making PACKET TRACE
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/apps/packet_trace/ $@
+
+
+#Creates shared library for SDK code
+$(openapps_so_library): $(OPENAPPS_BUILD_DELIVERABLES_DIR) ${SDK_LOCAL}  
+	$(eval openapps_lib_files := $(call rwildcard,$(OPENAPPS_OUTPATH)/libraries/,*.a))
+ifeq ($(TARGETOS_VARIANT),wrl_2.0)
+	$(LD) -shared -soname $(@F) -o $@ $(PLAT_OBJS) --whole-archive $(openapps_lib_files) --no-whole-archive -lc -lpthread -lm -lrt ${PLAT_LIBS}
+else
+	$(CC) ${CFLAGS} -shared -Wl,-soname,$(@F) -o $@ $(PLAT_OBJS) -Wl,--whole-archive $(openapps_lib_files) -Wl,--no-whole-archive -lc -lpthread -lm -lrt ${PLAT_LIBS}
+endif
+	$(STRIP) --strip-unneeded $@
+
+#openaps target depends on the appropriate driver
+openapps: $(sbdriver)
+
+#Compiles CJSON
+vend_cjson clean-vend_cjson debug-vend_cjson:
+	@echo Making CJSON
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/vendor/cjson/ $@
+
+#Compiles System Module
+system clean-system debug-system::
+	@echo Making System
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/infrastructure/system/ $@
+
+#Compiles Logging Module
+log clean-log debug-log:
+	@echo Making bviewLogging
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/infrastructure/logging/ $@
+
+#Compiles Vendorinit
+vendorinit clean-vendorinit debug-vendorinit::
+	@echo Making VENDOR INIT
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/vendor/driver/ $@
+ifeq ($(TARGETOS_VARIANT),wrl_2.0)
+	$(LD) -shared -soname libvendorinit.so.1 -o $(OPENAPPS_BUILD_DELIVERABLES_DIR)/libvendorinit.so.1 $(PLAT_OBJS) --whole-archive $(OPENAPPS_OUTPATH)/vendorinit/vendorinit.a --no-whole-archive -lc -lpthread -lm -lrt ${PLAT_LIBS}
+else
+	$(CC) ${CFLAGS} -shared -Wl,-soname,libvendorinit.so.1 -o $(OPENAPPS_BUILD_DELIVERABLES_DIR)/libvendorinit.so.1 $(PLAT_OBJS) -Wl,--whole-archive $(OPENAPPS_OUTPATH)/vendorinit/vendorinit.a -Wl,--no-whole-archive -lc -lpthread -lm -lrt ${PLAT_LIBS}
+endif
+
+
+sbredirector clean-sbredirector debug-sbredirector::
+	@echo Making SB-Redirector
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/sb_plugin/sb_redirector/ $@
+
+
+# Simple file that contains version information.
+
+ifneq ($(dmode),)
+tar_options = --show-transformed-names -v
+endif
+
+#
+# These are targets for cleaning:
+#
+# clean: cleans all but the SDK (which takes the longest time to build)
+# clean-all: cleans everything
+#
+
+clean:
+	for dir in $$(find $(OPENAPPS_OUTPATH) -maxdepth 1 -mindepth 1 -type d) ; do 	\
+		if [ "`basename $$dir`" != "sdk" ]; then 			\
+			(cd $$dir; $(RM) -rf *); 				\
+			rmdir $$dir; 						\
+		fi 								\
+	done
+	rm -f $(OPENAPPS_OUTPATH)/agent.o
+	rm -f $(OPENAPPS_OUTPATH)/version.h
+
+clean-all: $(del_target) $(del_target_object)
+	for dir in $$(find $(OPENAPPS_OUTPATH) -maxdepth 1 -mindepth 1 -type d) ; do 	\
+		(cd $$dir; $(RM) -rf *); 					\
+		rmdir $$dir; 							\
+	done
+	rm -f $(OPENAPPS_OUTPATH)/agent.o
+	rm -f $(OPENAPPS_OUTPATH)/version.h
+	rm -rf $(PACKAGES_DIR)
+#
+# end of Command Line Targets
+#
+
+#
+# The rest of the targets are supporting targets.  These should never be specified in the make command.
+#
+
+openapps_out_dir: $(OPENAPPS_BUILD_DELIVERABLES_DIR) $(OPENAPPS_LIBRARIES_DIR) $(OPENAPP_DELIVERABLES_DIR)
+
+$(OPENAPPS_BUILD_DELIVERABLES_DIR) $(OPENAPPS_LIBRARIES_DIR) $(OPENAPP_DELIVERABLES_DIR):
+	mkdir -p $@
+
+
+#
+# Debugging targets
+#
+dump-variables:
+	@echo AR 			= $(AR)
+	@echo AS 			= $(AS)
+	@echo CC 			= $(CC)
+	@echo CFLAGS 		    	= $(CFLAGS)
+	@echo DYNLIB_FLAGS          = $(DYNLIB_FLAGS)
+	@echo CROSS_COMPILE 		= $(CROSS_COMPILE)
+	@echo DEBUG_OPTIMIZE 		= $(DEBUG_OPTIMIZE)
+	@echo DEBUG_PARMS 		= $(DEBUG_PARMS)
+	@echo DEBUG_SYMBOLS 		= $(DEBUG_SYMBOLS)
+	@echo OPENAPPS_BUILD_DELIVERABLES_DIR 		= $(OPENAPPS_BUILD_DELIVERABLES_DIR)
+	@echo OPENAPP_DELIVERABLES_DIR 	= $(OPENAPP_DELIVERABLES_DIR)
+	@echo CPU			= $(CPU)
+	@echo BCM_CPU_ARCH		= $(BCM_CPU_ARCH)
+	@echo TARGETOS_VARIANT          = $(TARGETOS_VARIANT)
+	@echo LD 			= $(LD)
+	@echo LDFLAGS 			= $(LDFLAGS)
+	@echo LINUX_INCLUDE 		= $(LINUX_INCLUDE)
+	@echo MAKE_LOCAL 		= $(MAKE_LOCAL)
+	@echo NM 			= $(NM)
+	@echo NO_LOCAL_TARGETS 		= $(NO_LOCAL_TARGETS)
+	@echo OBJCOPY 			= $(OBJCOPY)
+	@echo OBJDUMP 			= $(OBJDUMP)
+	@echo OPENAPPS_BASE 		= $(OPENAPPS_BASE)
+	@echo OPENAPPS_CFLAGS 		= $(OPENAPPS_CFLAGS)
+	@echo OPENAPPS_RELEASE 		= $(OPENAPPS_RELEASE)
+	@echo OPENAPPS_OUTPATH 		= $(OPENAPPS_OUTPATH)
+	@echo OF_ONIE_DIR 		= $(OF_ONIE_DIR)
+	@echo PERL 			= $(PERL)
+	@echo BCM_REL_NUM      = $(BCM_REL_NUM)
+	@echo BCM_VER_NUM      = $(BCM_VER_NUM)
+	@echo BCM_MAINT_NUM    = $(BCM_MAINT_NUM)
+	@echo BCM_BUILD_NUM    = $(BCM_BUILD_NUM)
+	@echo PLATFORM_CODE 		= $(PLATFORM_CODE)
+	@echo QUIET 			= $(QUIET)
+	@echo RANLIB 			= $(RANLIB)
+	@echo RM 			= $(RM)
+	@echo SDK 			= $(SDK)
+	@echo SDK_PATCH 		= $(SDK_PATCH)
+	@echo SDKBUILD 			= $(SDKBUILD)
+	@echo SDK_LOCAL 		= $(SDK_LOCAL)
+	@echo OPENAPPS_SDK_PATCH	= $(OPENAPPS_SDK_PATCH)
+	@echo SED 			= $(SED)
+	@echo SPLINT 			= $(SPLINT)
+	@echo STRIP 			= $(STRIP)
+	@echo VIEWNAME 			= $(VIEWNAME)
+	@echo a_generated_file 		= $(a_generated_file)
+	@echo build_specific_files 	= $(build_specific_files)
+	@echo core_archive 		= $(core_archive)
+	@echo dmode 			= $(dmode)
+	@echo platform 			= $(platform)
+	@echo openapps_so_library 	= $(openapps_so_library)
+	@echo sdk_release	    	= $(sdk_release)
+	@echo PLAT_LIBS 	    	= $(PLAT_LIBS)
+	@echo OUTPATH   	    	= $(OUTPATH)
+	@echo dynamic_sb_lib   	    	= $(dynamic_sb_lib)
+	@echo common_include_list   	= $(common_include_list)
diff --git a/tools/Make.common.ovsdb b/tools/Make.common.ovsdb
new file mode 100755
index 0000000..772c8aa
--- /dev/null
+++ b/tools/Make.common.ovsdb
@@ -0,0 +1,62 @@
+# -*- mode: makefile; -*-
+#/*****************************************************************************
+#*
+#* (C) Copyright Broadcom Corporation 2015
+#*
+#* Licensed under the Apache License, Version 2.0 (the "License");
+#* you may not use this file except in compliance with the License.
+#*
+#* You may obtain a copy of the License at
+#* http://www.apache.org/licenses/LICENSE-2.0
+#*
+#* Unless required by applicable law or agreed to in writing, software
+#* distributed under the License is distributed on an "AS IS" BASIS,
+#* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#* See the License for the specific language governing permissions and
+#* limitations under the License.
+#*
+#***************************************************************************/
+
+
+ifeq ($(SBPLUGIN), ovsdb)
+
+    OPENAPPS_RELEASE = broadview-openprime-$(BCM_REL_NUM).$(BCM_VER_NUM).$(BCM_MAINT_NUM).$(BCM_BUILD_NUM)
+
+    sbdriver = sbovsdb
+    sb_ovsdb_arc = \
+        $(OPENAPPS_OUTPATH)/sbovsdb/sbovsdb.a
+endif
+
+ifeq ($(PLATFORM), UB-OVSDB)
+  vend_target += ovsdb
+  export CFLAGS += -DBVIEW_CHIP_OVSDB
+  static_lib += \
+        $(sb_ovsdb_arc) \
+        $(OVSDB)/lib/.libs/libopenvswitch.a \
+        $(OVSDB)/ovsdb/.libs/libovsdb.a
+
+endif
+
+ifeq ($(PLATFORM), OP-OVSDB)
+  export CFLAGS += -DBVIEW_CHIP_OVSDB --sysroot=$(BV_TARGET_SYSROOT)
+  static_lib += \
+        $(sb_ovsdb_arc) 
+
+  dynamic_sb_lib += -lovscommon
+
+#                    -lopenvswitch \
+#                    -lovscommon
+
+endif
+
+sbovsdb clean-sbovsdb debug-sbovsdb::
+	@echo Making SDK SB-OVSDB
+	@export
+	$(MAKE) $(DEBUG_PARMS) -C $(OPENAPPS_BASE)/src/sb_plugin/sb_ovsdb/ $@
+
+ifeq ($(PLATFORM), UB-OVSDB)
+ovsdb:
+	@echo Making openvswitch
+	cd $(OVSDB);sh $(OPENAPPS_BASE)/tools/openvswtich_build.sh
+endif
+
diff --git a/tools/Make.common.platform b/tools/Make.common.platform
new file mode 100755
index 0000000..6393729
--- /dev/null
+++ b/tools/Make.common.platform
@@ -0,0 +1,115 @@
+# -*- mode: makefile; -*-
+#/*****************************************************************************
+#*
+#* (C) Copyright Broadcom Corporation 2015
+#*
+#* Licensed under the Apache License, Version 2.0 (the "License");
+#* you may not use this file except in compliance with the License.
+#*
+#* You may obtain a copy of the License at
+#* http://www.apache.org/licenses/LICENSE-2.0
+#*
+#* Unless required by applicable law or agreed to in writing, software
+#* distributed under the License is distributed on an "AS IS" BASIS,
+#* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#* See the License for the specific language governing permissions and
+#* limitations under the License.
+#*
+#***************************************************************************/
+
+
+
+ifeq ($(CPU),xlp)
+ifeq ($(TARGETOS_VARIANT),wrx_3.7)
+   override platform = wrx-3_7
+   export platform
+
+   override kernel_version = 3_7
+   export kernel_version
+
+   LINUX_MAKE_USER = 1
+   export LINUX_MAKE_USER
+   LINKER_RELAX = 1
+   export LINKER_RELAX = 1
+
+   XMC ?= /projects/ntsw-tools/toolchains/xlp/xlp2xx/sdk-base/buildroot/output/build
+   TOOLS_DIR = $(XMC)/toolchains_bin/mipscross/linux/bin
+
+   export CFLAGS += -fPIC -mabi=32 -DWRX_PLT -O2 -D_REENTRANT -DLINUX
+   export PHYMOD_CFLAGS += -fPIC
+
+endif
+endif
+
+ifeq ($(CPU),x86_64)
+ifeq ($(TARGETOS_VARIANT),ubuntu_12)
+   override platform = x86-smp_generic_64-2_6
+   export platform
+   export BUILD_SDK_CFLAGS = -DINCLUDE_IM_BOARDKEEPER -Wno-unused-result -Wno-error=format -Wno-error=format-security
+   export CFLAGS += -fno-common -fno-strict-aliasing -fomit-frame-pointer -funit-at-a-time -msoft-float -I$(KERNEL_SRC)/arch/x86/include/generated/
+   export OPENNSL_IM_FIXUP = 1
+
+
+   export CFLAGS += -fno-common -fno-strict-aliasing -fomit-frame-pointer -funit-at-a-time -msoft-float -fPIC
+
+ifeq ($(KERNEL_SRC),)
+   KERNEL_SRC = $(OPENAPPS_OUTPATH)/headers/usr/src/linux-headers-3.5.0-54-generic
+endif
+   export KERNEL_SRC
+
+ifeq ($(KERNDIR),)
+   KERNDIR = $(KERNEL_SRC)
+endif
+   export KERNDIR
+ifeq ($(SBPLUGIN),sdk)
+include $(abspath $(OPENAPPS_BASE)/platform/cpu/common/$(TARGETOS_VARIANT)/kernel.cfg)
+endif
+endif
+
+ifeq ($(TARGETOS_VARIANT),debian7.6)
+   override platform = x86-smp_generic_64-2_6
+   export platform
+   export BUILD_SDK_CFLAGS = -Wno-unused-result -Wno-error=format -Wno-error=format-security
+   export OPENNSL_IM_FIXUP = 1
+
+
+   export CFLAGS += -fno-common -fno-strict-aliasing -fomit-frame-pointer -funit-at-a-time -msoft-float -fPIC
+
+ifeq ($(KERNEL_SRC),)
+   KERNEL_SRC = $(OPENAPPS_OUTPATH)/headers/usr/src/linux-headers-3.2.46+
+endif
+   export KERNEL_SRC
+
+ifeq ($(KERNDIR),)
+   KERNDIR = $(KERNEL_SRC)
+endif
+   export KERNDIR
+ifeq ($(SBPLUGIN),sdk)
+include $(abspath $(OPENAPPS_BASE)/platform/cpu/common/$(TARGETOS_VARIANT)/kernel.cfg)
+endif
+endif
+
+ifeq ($(TARGETOS_VARIANT),debian8.0)
+   override platform = x86-smp_generic_64-2_6
+   export platform
+   export BUILD_SDK_CFLAGS = -Wno-unused-result -Wno-error=format -Wno-error=format-security
+   export OPENNSL_IM_FIXUP = 1
+   export LINUX_UAPI_SPLIT=1
+
+   export CFLAGS += -fno-common -fno-strict-aliasing -fomit-frame-pointer -funit-at-a-time -msoft-float -fPIC -Wno-sizeof-pointer-memaccess
+
+ifeq ($(KERNEL_SRC),)
+   KERNEL_SRC = $(OPENAPPS_OUTPATH)/headers/usr/src/linux-headers-3.16.7-ckt7
+endif
+   export KERNEL_SRC
+
+ifeq ($(KERNDIR),)
+   KERNDIR = $(KERNEL_SRC)
+endif
+   export KERNDIR
+ifeq ($(SBPLUGIN),sdk)
+include $(abspath $(OPENAPPS_BASE)/platform/cpu/common/$(TARGETOS_VARIANT)/kernel.cfg)
+endif
+endif
+
+endif
diff --git a/tools/Make.local b/tools/Make.local
new file mode 100755
index 0000000..c19d1a3
--- /dev/null
+++ b/tools/Make.local
@@ -0,0 +1,51 @@
+# -*- mode: makefile; -*-
+#/*****************************************************************************
+#*
+#* (C) Copyright Broadcom Corporation 2015
+#*
+#* Licensed under the Apache License, Version 2.0 (the "License");
+#* you may not use this file except in compliance with the License.
+#*
+#* You may obtain a copy of the License at
+#* http://www.apache.org/licenses/LICENSE-2.0
+#*
+#* Unless required by applicable law or agreed to in writing, software
+#* distributed under the License is distributed on an "AS IS" BASIS,
+#* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#* See the License for the specific language governing permissions and
+#* limitations under the License.
+#*
+#***************************************************************************/
+
+export CFLAGS += -DOPENAPPS_FIXUP
+
+ifneq ($(BCM_PLATFORM), bcmsim)
+ifneq (wrl_2.0,$(TARGETOS_VARIANT))
+export CFLAGS += -Wno-unused-but-set-variable -Wno-address -Wno-uninitialized $(BUILD_SDK_CFLAGS)
+endif
+
+ifeq ($(FEATURE_LIST),)
+#   FEATURE_LIST=BCMX BCMX_DIAG BFD BHH CES CHASSIS CINT CUSTOMER EDITLINE I2C L3 MEM_SCAN RCPU TEST
+   FEATURE_LIST=CINT CUSTOMER EDITLINE L3 MEM_SCAN TEST ETH_LM_DM
+endif
+
+export BCM_PHY_LIST := 84740 8750 84328
+BCM_PTL_SPT = 1
+#BCM_56634_A0 = 1
+BCM_56840_A0 = 1
+BCM_56840_B0 = 1
+BCM_56850_A0 = 1
+BCM_56960_A0 = 1
+#Adding the following one to define HERCULES constants for now. Need to revisit this. TBD.
+BCM_5675_A0 = 1
+
+CFGFLAGS += -DBCM_PORT_DEFAULT_DISABLE
+CFGFLAGS += -DBCM_VLAN_NO_DEFAULT_ETHER
+CFGFLAGS += -DBCM_VLAN_NO_DEFAULT_CPU
+CFGFLAGS += -DSAL_CONFIG_FILE_DISABLE
+endif
+
+
+ifdef CDP_EXCLUDE
+CFLAGS += $(VISIBILITY_FLAGS)
+endif
diff --git a/tools/make.configure b/tools/make.configure
new file mode 100755
index 0000000..e69de29
diff --git a/tools/relativepath b/tools/relativepath
new file mode 100755
index 0000000..0b6345b
--- /dev/null
+++ b/tools/relativepath
@@ -0,0 +1,29 @@
+#!/bin/sh
+#***********************************************************************
+# (C) Copyright Broadcom Corporation 2014
+#
+#**********************************************************************
+#
+# @filename relativepath
+#
+# @purpose Target specific make file to build Openapps features
+#
+# @component base
+#
+# @comments
+#
+# @create 11/15/2014
+#
+# @author sagrawal
+# @end
+#
+#*********************************************************************
+
+if [ $# -lt 2 ]; then
+        echo "Usage: $(basename $0) <base path> <target path>"
+        exit 1
+fi
+
+relative=$(perl -MFile::Spec -e 'print File::Spec->abs2rel("'$2'","'$1'")')
+
+echo $relative
diff --git a/vendor/cjson/Makefile b/vendor/cjson/Makefile
new file mode 100755
index 0000000..57d66d9
--- /dev/null
+++ b/vendor/cjson/Makefile
@@ -0,0 +1,31 @@
+MODULE := vend_cjson
+
+CC ?= gcc
+AR ?= ar
+OPENAPPS_OUTPATH ?= .
+
+CFLAGS += -Wall -std=c99 -g -I. -I../../public/ 
+
+export OUT_VEND_CJSON=$(OPENAPPS_OUTPATH)/$(MODULE)
+export LIBS_VEND_CJSON=$(MODULE).a
+
+OBJECTS_VEND_CJSON := $(patsubst %.c,%.o,$(wildcard *.c))
+
+$(OUT_VEND_CJSON)/%.o : %.c
+	@mkdir -p $(OUT_VEND_CJSON) 
+	$(CC) $(CFLAGS) -c  $< -o $@ 
+
+# target for .a 
+$(OUT_VEND_CJSON)/$(LIBS_VEND_CJSON): $(patsubst %,$(OUT_VEND_CJSON)/%,$(subst :, ,$(OBJECTS_VEND_CJSON))) 
+	@cd $(OUT_VEND_CJSON) && $(AR) rvs $(MODULE).a $(OBJECTS_VEND_CJSON)  
+
+#default target
+$(MODULE) all: $(OUT_VEND_CJSON)/$(LIBS_VEND_CJSON) 
+
+clean-$(MODULE) clean: 
+	rm -rf $(OUT_VEND_CJSON)
+
+#target to print all exported variables
+debug-$(MODULE) dump-variables: 
+	@echo "OUT_VEND_CJSON=$(OUT_VEND_CJSON)"
+	@echo "LIBS_VEND_CJSON=$(LIBS_VEND_CJSON)"
diff --git a/vendor/cjson/cJSON.c b/vendor/cjson/cJSON.c
new file mode 100755
index 0000000..35452cb
--- /dev/null
+++ b/vendor/cjson/cJSON.c
@@ -0,0 +1,596 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+/* cJSON */
+/* JSON parser in C. */
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+#include <float.h>
+#include <limits.h>
+#include <ctype.h>
+#include "cJSON.h"
+
+static const char *ep;
+
+const char *cJSON_GetErrorPtr(void) {return ep;}
+
+static int cJSON_strcasecmp(const char *s1,const char *s2)
+{
+	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
+	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
+	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
+}
+
+static void *(*cJSON_malloc)(size_t sz) = malloc;
+static void (*cJSON_free)(void *ptr) = free;
+
+static char* cJSON_strdup(const char* str)
+{
+      size_t len;
+      char* copy;
+
+      len = strlen(str) + 1;
+      if (!(copy = (char*)cJSON_malloc(len))) return 0;
+      memcpy(copy,str,len);
+      return copy;
+}
+
+void cJSON_InitHooks(cJSON_Hooks* hooks)
+{
+    if (!hooks) { /* Reset hooks */
+        cJSON_malloc = malloc;
+        cJSON_free = free;
+        return;
+    }
+
+	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
+	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
+}
+
+/* Internal constructor. */
+static cJSON *cJSON_New_Item(void)
+{
+	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
+	if (node) memset(node,0,sizeof(cJSON));
+	return node;
+}
+
+/* Delete a cJSON structure. */
+void cJSON_Delete(cJSON *c)
+{
+	cJSON *next;
+	while (c)
+	{
+		next=c->next;
+		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
+		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
+		if (c->string) cJSON_free(c->string);
+		cJSON_free(c);
+		c=next;
+	}
+}
+
+/* Parse the input text to generate a number, and populate the result into item. */
+static const char *parse_number(cJSON *item,const char *num)
+{
+	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
+
+	if (*num=='-') sign=-1,num++;	/* Has sign? */
+	if (*num=='0') num++;			/* is zero */
+	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
+	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
+	if (*num=='e' || *num=='E')		/* Exponent? */
+	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
+		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
+	}
+
+	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
+	
+	item->valuedouble=n;
+	item->valueint=(int)n;
+	item->type=cJSON_Number;
+	return num;
+}
+
+/* Render the number nicely from the given item into a string. */
+static char *print_number(cJSON *item)
+{
+	char *str;
+	double d=item->valuedouble;
+	if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
+	{
+		str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
+		if (str) sprintf(str,"%d",item->valueint);
+	}
+	else
+	{
+		str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
+		if (str)
+		{
+			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
+			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
+			else												sprintf(str,"%f",d);
+		}
+	}
+	return str;
+}
+
+static unsigned parse_hex4(const char *str)
+{
+	unsigned h=0;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	h=h<<4;str++;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	h=h<<4;str++;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	h=h<<4;str++;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	return h;
+}
+
+/* Parse the input text into an unescaped cstring, and populate item. */
+static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+static const char *parse_string(cJSON *item,const char *str)
+{
+	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
+	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
+	
+	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
+	
+	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
+	if (!out) return 0;
+	
+	ptr=str+1;ptr2=out;
+	while (*ptr!='\"' && *ptr)
+	{
+		if (*ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			ptr++;
+			switch (*ptr)
+			{
+				case 'b': *ptr2++='\b';	break;
+				case 'f': *ptr2++='\f';	break;
+				case 'n': *ptr2++='\n';	break;
+				case 'r': *ptr2++='\r';	break;
+				case 't': *ptr2++='\t';	break;
+				case 'u':	 /* transcode utf16 to utf8. */
+					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */
+
+					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
+
+					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
+					{
+						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
+						uc2=parse_hex4(ptr+3);ptr+=6;
+						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
+						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
+					}
+
+					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
+					
+					switch (len) {
+						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 1: *--ptr2 =(uc | firstByteMark[len]);
+					}
+					ptr2+=len;
+					break;
+				default:  *ptr2++=*ptr; break;
+			}
+			ptr++;
+		}
+	}
+	*ptr2=0;
+	if (*ptr=='\"') ptr++;
+	item->valuestring=out;
+	item->type=cJSON_String;
+	return ptr;
+}
+
+/* Render the cstring provided to an escaped version that can be printed. */
+static char *print_string_ptr(const char *str)
+{
+	const char *ptr;char *ptr2,*out;int len=0;unsigned char token;
+	
+	if (!str) return cJSON_strdup("");
+	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
+	
+	out=(char*)cJSON_malloc(len+3);
+	if (!out) return 0;
+
+	ptr2=out;ptr=str;
+	*ptr2++='\"';
+	while (*ptr)
+	{
+		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			*ptr2++='\\';
+			switch (token=*ptr++)
+			{
+				case '\\':	*ptr2++='\\';	break;
+				case '\"':	*ptr2++='\"';	break;
+				case '\b':	*ptr2++='b';	break;
+				case '\f':	*ptr2++='f';	break;
+				case '\n':	*ptr2++='n';	break;
+				case '\r':	*ptr2++='r';	break;
+				case '\t':	*ptr2++='t';	break;
+				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
+			}
+		}
+	}
+	*ptr2++='\"';*ptr2++=0;
+	return out;
+}
+/* Invote print_string_ptr (which is useful) on an item. */
+static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}
+
+/* Predeclare these prototypes. */
+static const char *parse_value(cJSON *item,const char *value);
+static char *print_value(cJSON *item,int depth,int fmt);
+static const char *parse_array(cJSON *item,const char *value);
+static char *print_array(cJSON *item,int depth,int fmt);
+static const char *parse_object(cJSON *item,const char *value);
+static char *print_object(cJSON *item,int depth,int fmt);
+
+/* Utility to jump whitespace and cr/lf */
+static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
+
+/* Parse an object - create a new root, and populate. */
+cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
+{
+	const char *end=0;
+	cJSON *c=cJSON_New_Item();
+	ep=0;
+	if (!c) return 0;       /* memory fail */
+
+	end=parse_value(c,skip(value));
+	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
+
+	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
+	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
+	if (return_parse_end) *return_parse_end=end;
+	return c;
+}
+/* Default options for cJSON_Parse */
+cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}
+
+/* Render a cJSON item/entity/structure to text. */
+char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}
+char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}
+
+/* Parser core - when encountering text, process appropriately. */
+static const char *parse_value(cJSON *item,const char *value)
+{
+	if (!value)						return 0;	/* Fail on null. */
+	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
+	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
+	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
+	if (*value=='\"')				{ return parse_string(item,value); }
+	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
+	if (*value=='[')				{ return parse_array(item,value); }
+	if (*value=='{')				{ return parse_object(item,value); }
+
+	ep=value;return 0;	/* failure. */
+}
+
+/* Render a value to text. */
+static char *print_value(cJSON *item,int depth,int fmt)
+{
+	char *out=0;
+	if (!item) return 0;
+	switch ((item->type)&255)
+	{
+		case cJSON_NULL:	out=cJSON_strdup("null");	break;
+		case cJSON_False:	out=cJSON_strdup("false");break;
+		case cJSON_True:	out=cJSON_strdup("true"); break;
+		case cJSON_Number:	out=print_number(item);break;
+		case cJSON_String:	out=print_string(item);break;
+		case cJSON_Array:	out=print_array(item,depth,fmt);break;
+		case cJSON_Object:	out=print_object(item,depth,fmt);break;
+	}
+	return out;
+}
+
+/* Build an array from input text. */
+static const char *parse_array(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='[')	{ep=value;return 0;}	/* not an array! */
+
+	item->type=cJSON_Array;
+	value=skip(value+1);
+	if (*value==']') return value+1;	/* empty array. */
+
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;		 /* memory fail */
+	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_value(child,skip(value+1)));
+		if (!value) return 0;	/* memory fail */
+	}
+
+	if (*value==']') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an array to text */
+static char *print_array(cJSON *item,int depth,int fmt)
+{
+	char **entries;
+	char *out=0,*ptr,*ret;int len=5;
+	cJSON *child=item->child;
+	int numentries=0,i=0,fail=0;
+	
+	/* How many entries in the array? */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle numentries==0 */
+	if (!numentries)
+	{
+		out=(char*)cJSON_malloc(3);
+		if (out) strcpy(out,"[]");
+		return out;
+	}
+	/* Allocate an array to hold the values for each */
+	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!entries) return 0;
+	memset(entries,0,numentries*sizeof(char*));
+	/* Retrieve all the results: */
+	child=item->child;
+	while (child && !fail)
+	{
+		ret=print_value(child,depth+1,fmt);
+		entries[i++]=ret;
+		if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
+		child=child->next;
+	}
+	
+	/* If we didn't fail, try to malloc the output string */
+	if (!fail) out=(char*)cJSON_malloc(len);
+	/* If that fails, we fail. */
+	if (!out) fail=1;
+
+	/* Handle failure. */
+	if (fail)
+	{
+		for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
+		cJSON_free(entries);
+		return 0;
+	}
+	
+	/* Compose the output array. */
+	*out='[';
+	ptr=out+1;*ptr=0;
+	for (i=0;i<numentries;i++)
+	{
+		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
+		if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
+		cJSON_free(entries[i]);
+	}
+	cJSON_free(entries);
+	*ptr++=']';*ptr++=0;
+	return out;	
+}
+
+/* Build an object from the text. */
+static const char *parse_object(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
+	
+	item->type=cJSON_Object;
+	value=skip(value+1);
+	if (*value=='}') return value+1;	/* empty array. */
+	
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;
+	value=skip(parse_string(child,skip(value)));
+	if (!value) return 0;
+	child->string=child->valuestring;child->valuestring=0;
+	if (*value!=':') {ep=value;return 0;}	/* fail! */
+	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+	
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_string(child,skip(value+1)));
+		if (!value) return 0;
+		child->string=child->valuestring;child->valuestring=0;
+		if (*value!=':') {ep=value;return 0;}	/* fail! */
+		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+		if (!value) return 0;
+	}
+	
+	if (*value=='}') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an object to text. */
+static char *print_object(cJSON *item,int depth,int fmt)
+{
+	char **entries=0,**names=0;
+	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
+	cJSON *child=item->child;
+	int numentries=0,fail=0;
+	/* Count the number of entries. */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle empty object case */
+	if (!numentries)
+	{
+		out=(char*)cJSON_malloc(fmt?depth+4:3);
+		if (!out)	return 0;
+		ptr=out;*ptr++='{';
+		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
+		*ptr++='}';*ptr++=0;
+		return out;
+	}
+	/* Allocate space for the names and the objects */
+	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!entries) return 0;
+	names=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!names) {cJSON_free(entries);return 0;}
+	memset(entries,0,sizeof(char*)*numentries);
+	memset(names,0,sizeof(char*)*numentries);
+
+	/* Collect all the results into our arrays: */
+	child=item->child;depth++;if (fmt) len+=depth;
+	while (child)
+	{
+		names[i]=str=print_string_ptr(child->string);
+		entries[i++]=ret=print_value(child,depth,fmt);
+		if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
+		child=child->next;
+	}
+	
+	/* Try to allocate the output string */
+	if (!fail) out=(char*)cJSON_malloc(len);
+	if (!out) fail=1;
+
+	/* Handle failure */
+	if (fail)
+	{
+		for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
+		cJSON_free(names);cJSON_free(entries);
+		return 0;
+	}
+	
+	/* Compose the output: */
+	*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
+	for (i=0;i<numentries;i++)
+	{
+		if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
+		strcpy(ptr,names[i]);ptr+=strlen(names[i]);
+		*ptr++=':';if (fmt) *ptr++='\t';
+		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
+		if (i!=numentries-1) *ptr++=',';
+		if (fmt) *ptr++='\n';*ptr=0;
+		cJSON_free(names[i]);cJSON_free(entries[i]);
+	}
+	
+	cJSON_free(names);cJSON_free(entries);
+	if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
+	*ptr++='}';*ptr++=0;
+	return out;	
+}
+
+/* Get Array size/item / object item. */
+int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
+cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
+cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
+
+/* Utility for array list handling. */
+static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
+/* Utility for handling references. */
+static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
+
+/* Add item to array/object. */
+void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
+void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
+void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
+void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
+
+cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
+	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
+void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
+cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
+void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}
+
+/* Replace array/object items with new ones. */
+void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
+	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
+	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
+void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}
+
+/* Create basic types: */
+cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
+cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
+cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
+cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
+cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
+cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
+cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
+cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
+
+/* Create Arrays: */
+cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+
+/* Duplication */
+cJSON *cJSON_Duplicate(cJSON *item,int recurse)
+{
+	cJSON *newitem,*cptr,*nptr=0,*newchild;
+	/* Bail on bad ptr */
+	if (!item) return 0;
+	/* Create new item */
+	newitem=cJSON_New_Item();
+	if (!newitem) return 0;
+	/* Copy over all vars */
+	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
+	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
+	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
+	/* If non-recursive, then we're done! */
+	if (!recurse) return newitem;
+	/* Walk the ->next chain for the child. */
+	cptr=item->child;
+	while (cptr)
+	{
+		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
+		if (!newchild) {cJSON_Delete(newitem);return 0;}
+		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
+		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
+		cptr=cptr->next;
+	}
+	return newitem;
+}
+
+void cJSON_Minify(char *json)
+{
+	char *into=json;
+	while (*json)
+	{
+		if (*json==' ') json++;
+		else if (*json=='\t') json++;	// Whitespace characters.
+		else if (*json=='\r') json++;
+		else if (*json=='\n') json++;
+		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	// double-slash comments, to end of line.
+		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	// multiline comments.
+		else if (*json=='\"'){*into++=*json++;while (*json && *json!='\"'){if (*json=='\\') *into++=*json++;*into++=*json++;}*into++=*json++;} // string literals, which are \" sensitive.
+		else *into++=*json++;			// All other characters.
+	}
+	*into=0;	// and null-terminate.
+}
diff --git a/vendor/cjson/cJSON.h b/vendor/cjson/cJSON.h
new file mode 100755
index 0000000..867b7c3
--- /dev/null
+++ b/vendor/cjson/cJSON.h
@@ -0,0 +1,143 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+ 
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+ 
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+ 
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+#ifndef cJSON__h
+#define cJSON__h
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* cJSON Types: */
+#define cJSON_False 0
+#define cJSON_True 1
+#define cJSON_NULL 2
+#define cJSON_Number 3
+#define cJSON_String 4
+#define cJSON_Array 5
+#define cJSON_Object 6
+	
+#define cJSON_IsReference 256
+
+/* The cJSON structure: */
+typedef struct cJSON {
+	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
+	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
+
+	int type;					/* The type of the item, as above. */
+
+	char *valuestring;			/* The item's string, if type==cJSON_String */
+	int valueint;				/* The item's number, if type==cJSON_Number */
+	double valuedouble;			/* The item's number, if type==cJSON_Number */
+
+	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
+} cJSON;
+
+typedef struct cJSON_Hooks {
+      void *(*malloc_fn)(size_t sz);
+      void (*free_fn)(void *ptr);
+} cJSON_Hooks;
+
+/* Supply malloc, realloc and free functions to cJSON */
+extern void cJSON_InitHooks(cJSON_Hooks* hooks);
+
+
+/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
+extern cJSON *cJSON_Parse(const char *value);
+/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
+extern char  *cJSON_Print(cJSON *item);
+/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
+extern char  *cJSON_PrintUnformatted(cJSON *item);
+/* Delete a cJSON entity and all subentities. */
+extern void   cJSON_Delete(cJSON *c);
+
+/* Returns the number of items in an array (or object). */
+extern int	  cJSON_GetArraySize(cJSON *array);
+/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
+extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
+/* Get item "string" from object. Case insensitive. */
+extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);
+
+/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
+extern const char *cJSON_GetErrorPtr(void);
+	
+/* These calls create a cJSON item of the appropriate type. */
+extern cJSON *cJSON_CreateNull(void);
+extern cJSON *cJSON_CreateTrue(void);
+extern cJSON *cJSON_CreateFalse(void);
+extern cJSON *cJSON_CreateBool(int b);
+extern cJSON *cJSON_CreateNumber(double num);
+extern cJSON *cJSON_CreateString(const char *string);
+extern cJSON *cJSON_CreateArray(void);
+extern cJSON *cJSON_CreateObject(void);
+
+/* These utilities create an Array of count items. */
+extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);
+extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);
+extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);
+extern cJSON *cJSON_CreateStringArray(const char **strings,int count);
+
+/* Append item to the specified array/object. */
+extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
+/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
+extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);
+
+/* Remove/Detatch items from Arrays/Objects. */
+extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
+extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
+extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
+extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
+	
+/* Update array items. */
+extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
+extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
+
+/* Duplicate a cJSON item */
+extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);
+/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
+need to be released. With recurse!=0, it will duplicate any children connected to the item.
+The item->next and ->prev pointers are always zero on return from Duplicate. */
+
+/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
+extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);
+
+extern void cJSON_Minify(char *json);
+
+/* Macros for creating things quickly. */
+#define cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())
+#define cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
+#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
+#define cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))
+#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
+#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))
+
+/* When assigning an integer value, it needs to be propagated to valuedouble too. */
+#define cJSON_SetIntValue(object,val)			((object)?(object)->valueint=(object)->valuedouble=(val):(val))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
-- 
2.1.4

